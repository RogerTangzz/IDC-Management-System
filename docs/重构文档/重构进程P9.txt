## Phase 9: å®‰å…¨åŠ å›ºï¼ˆ2å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1**: Milestone 9.1 èº«ä»½è®¤è¯ä¸æˆæƒå¢å¼º
- **Day 2**: Milestone 9.2 æ•°æ®å®‰å…¨ä¸å®¡è®¡

---

## Milestone 9.1: èº«ä»½è®¤è¯ä¸æˆæƒå¢å¼ºï¼ˆ1å¤©ï¼‰

### Day 1: è®¤è¯æˆæƒå®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. JWTè®¤è¯æœåŠ¡
```typescript
// src/security/auth/JwtAuthService.ts
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { Redis } from 'ioredis';

@Injectable()
export class JwtAuthService {
  private readonly accessTokenSecret: string;
  private readonly refreshTokenSecret: string;
  private readonly accessTokenExpiry = '15m';
  private readonly refreshTokenExpiry = '7d';
  private redis: Redis;
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('Logger') private logger: Logger,
    @Inject('Redis') redis: Redis
  ) {
    this.accessTokenSecret = this.config.get('auth.jwt.accessSecret');
    this.refreshTokenSecret = this.config.get('auth.jwt.refreshSecret');
    this.redis = redis;
  }
  
  async generateTokenPair(user: User): Promise<TokenPair> {
    const tokenId = crypto.randomBytes(16).toString('hex');
    
    // ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    const accessToken = jwt.sign(
      {
        sub: user.id,
        username: user.username,
        roles: user.roles,
        permissions: user.permissions,
        jti: tokenId,
        type: 'access'
      },
      this.accessTokenSecret,
      {
        expiresIn: this.accessTokenExpiry,
        issuer: 'auth-service',
        audience: 'api'
      }
    );
    
    // ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
    const refreshToken = jwt.sign(
      {
        sub: user.id,
        jti: tokenId,
        type: 'refresh'
      },
      this.refreshTokenSecret,
      {
        expiresIn: this.refreshTokenExpiry,
        issuer: 'auth-service'
      }
    );
    
    // å­˜å‚¨åˆ·æ–°ä»¤ç‰Œåˆ°Redis
    await this.redis.setex(
      `refresh_token:${user.id}:${tokenId}`,
      7 * 24 * 60 * 60, // 7å¤©
      JSON.stringify({
        userId: user.id,
        tokenId,
        createdAt: new Date().toISOString(),
        userAgent: this.getUserAgent(),
        ip: this.getClientIp()
      })
    );
    
    // è®°å½•ç™»å½•å®¡è®¡æ—¥å¿—
    await this.auditLog('auth.login', {
      userId: user.id,
      tokenId,
      method: 'jwt'
    });
    
    return {
      accessToken,
      refreshToken,
      expiresIn: 900, // 15åˆ†é’Ÿ
      tokenType: 'Bearer'
    };
  }
  
  async verifyAccessToken(token: string): Promise<TokenPayload> {
    try {
      const payload = jwt.verify(token, this.accessTokenSecret, {
        issuer: 'auth-service',
        audience: 'api'
      }) as TokenPayload;
      
      // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
      const isBlacklisted = await this.redis.exists(`blacklist:${payload.jti}`);
      if (isBlacklisted) {
        throw new UnauthorizedError('Token has been revoked');
      }
      
      return payload;
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new UnauthorizedError('Access token expired');
      }
      if (error.name === 'JsonWebTokenError') {
        throw new UnauthorizedError('Invalid access token');
      }
      throw error;
    }
  }
  
  async refreshAccessToken(refreshToken: string): Promise<TokenPair> {
    try {
      const payload = jwt.verify(refreshToken, this.refreshTokenSecret, {
        issuer: 'auth-service'
      }) as RefreshTokenPayload;
      
      // éªŒè¯åˆ·æ–°ä»¤ç‰Œæ˜¯å¦å­˜åœ¨äºRedis
      const storedToken = await this.redis.get(`refresh_token:${payload.sub}:${payload.jti}`);
      if (!storedToken) {
        throw new UnauthorizedError('Refresh token not found or expired');
      }
      
      // è·å–ç”¨æˆ·æœ€æ–°ä¿¡æ¯
      const user = await this.userRepository.findById(payload.sub);
      if (!user || !user.isActive) {
        throw new UnauthorizedError('User not found or inactive');
      }
      
      // ç”Ÿæˆæ–°çš„ä»¤ç‰Œå¯¹
      const newTokens = await this.generateTokenPair(user);
      
      // å¯é€‰ï¼šå®ç°åˆ·æ–°ä»¤ç‰Œè½®æ¢
      if (this.config.get('auth.jwt.rotateRefreshToken')) {
        // åˆ é™¤æ—§çš„åˆ·æ–°ä»¤ç‰Œ
        await this.redis.del(`refresh_token:${payload.sub}:${payload.jti}`);
      }
      
      return newTokens;
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new UnauthorizedError('Refresh token expired');
      }
      if (error.name === 'JsonWebTokenError') {
        throw new UnauthorizedError('Invalid refresh token');
      }
      throw error;
    }
  }
  
  async revokeToken(tokenId: string): Promise<void> {
    // å°†ä»¤ç‰ŒåŠ å…¥é»‘åå•
    await this.redis.setex(
      `blacklist:${tokenId}`,
      900, // ä¸è®¿é—®ä»¤ç‰Œè¿‡æœŸæ—¶é—´ä¸€è‡´
      '1'
    );
    
    // åˆ é™¤å¯¹åº”çš„åˆ·æ–°ä»¤ç‰Œ
    const keys = await this.redis.keys(`refresh_token:*:${tokenId}`);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
    
    await this.auditLog('auth.logout', { tokenId });
  }
  
  async revokeAllUserTokens(userId: string): Promise<void> {
    // è·å–ç”¨æˆ·æ‰€æœ‰åˆ·æ–°ä»¤ç‰Œ
    const keys = await this.redis.keys(`refresh_token:${userId}:*`);
    
    // å°†æ‰€æœ‰ä»¤ç‰ŒåŠ å…¥é»‘åå•å¹¶åˆ é™¤åˆ·æ–°ä»¤ç‰Œ
    for (const key of keys) {
      const tokenData = await this.redis.get(key);
      if (tokenData) {
        const { tokenId } = JSON.parse(tokenData);
        await this.redis.setex(`blacklist:${tokenId}`, 900, '1');
      }
    }
    
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
    
    await this.auditLog('auth.revoke_all', { userId, count: keys.length });
  }
}
```

#### 2. RBACæƒé™ç³»ç»Ÿ
```typescript
// src/security/rbac/RbacService.ts
@Injectable()
export class RbacService {
  private roleHierarchy = new Map<string, string[]>();
  private permissionCache = new Map<string, Set<string>>();
  
  constructor(
    @Inject('RoleRepository') private roleRepository: RoleRepository,
    @Inject('Logger') private logger: Logger,
    @Inject('CacheManager') private cache: CacheManager
  ) {
    this.initializeRoleHierarchy();
  }
  
  private async initializeRoleHierarchy(): Promise<void> {
    // å®šä¹‰è§’è‰²ç»§æ‰¿å…³ç³»
    this.roleHierarchy.set('super_admin', ['admin']);
    this.roleHierarchy.set('admin', ['manager']);
    this.roleHierarchy.set('manager', ['supervisor']);
    this.roleHierarchy.set('supervisor', ['operator']);
    this.roleHierarchy.set('operator', ['viewer']);
    this.roleHierarchy.set('viewer', []);
  }
  
  async checkPermission(
    user: User,
    resource: string,
    action: string,
    context?: any
  ): Promise<boolean> {
    // è¶…çº§ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
    if (user.roles.includes('super_admin')) {
      return true;
    }
    
    // è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™ï¼ˆåŒ…æ‹¬ç»§æ‰¿çš„ï¼‰
    const permissions = await this.getUserPermissions(user);
    
    // æ„å»ºæƒé™å­—ç¬¦ä¸²
    const requiredPermission = `${resource}:${action}`;
    
    // æ£€æŸ¥ç›´æ¥æƒé™
    if (permissions.has(requiredPermission) || permissions.has(`${resource}:*`)) {
      // å¦‚æœæœ‰ä¸Šä¸‹æ–‡ï¼Œè¿›è¡Œé¢å¤–çš„å±æ€§åŸºç¡€è®¿é—®æ§åˆ¶(ABAC)
      if (context) {
        return await this.checkAttributeBasedAccess(user, resource, action, context);
      }
      return true;
    }
    
    // æ£€æŸ¥é€šé…ç¬¦æƒé™
    if (permissions.has('*:*') || permissions.has(`*:${action}`)) {
      return true;
    }
    
    return false;
  }
  
  private async getUserPermissions(user: User): Promise<Set<string>> {
    const cacheKey = `permissions:${user.id}`;
    
    // ä»ç¼“å­˜è·å–
    const cached = await this.cache.get<Set<string>>(cacheKey);
    if (cached) {
      return cached;
    }
    
    const permissions = new Set<string>();
    
    // æ”¶é›†æ‰€æœ‰è§’è‰²ï¼ˆåŒ…æ‹¬ç»§æ‰¿çš„ï¼‰
    const allRoles = this.getAllRoles(user.roles);
    
    // è·å–æ¯ä¸ªè§’è‰²çš„æƒé™
    for (const roleName of allRoles) {
      const role = await this.roleRepository.findByName(roleName);
      if (role) {
        role.permissions.forEach(p => permissions.add(p));
      }
    }
    
    // æ·»åŠ ç”¨æˆ·ç›´æ¥åˆ†é…çš„æƒé™
    user.permissions?.forEach(p => permissions.add(p));
    
    // ç¼“å­˜æƒé™
    await this.cache.set(cacheKey, permissions, 300); // 5åˆ†é’Ÿç¼“å­˜
    
    return permissions;
  }
  
  private getAllRoles(userRoles: string[]): Set<string> {
    const allRoles = new Set<string>();
    
    const collectRoles = (roleName: string) => {
      allRoles.add(roleName);
      const inheritedRoles = this.roleHierarchy.get(roleName) || [];
      inheritedRoles.forEach(r => collectRoles(r));
    };
    
    userRoles.forEach(role => collectRoles(role));
    
    return allRoles;
  }
  
  private async checkAttributeBasedAccess(
    user: User,
    resource: string,
    action: string,
    context: any
  ): Promise<boolean> {
    // å®ç°åŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶
    const policies = await this.getPolicies(resource, action);
    
    for (const policy of policies) {
      if (!this.evaluatePolicy(policy, user, context)) {
        return false;
      }
    }
    
    return true;
  }
  
  private evaluatePolicy(policy: Policy, user: User, context: any): boolean {
    switch (policy.type) {
      case 'owner':
        // åªèƒ½è®¿é—®è‡ªå·±çš„èµ„æº
        return context.ownerId === user.id;
      
      case 'department':
        // åªèƒ½è®¿é—®åŒéƒ¨é—¨çš„èµ„æº
        return context.departmentId === user.departmentId;
      
      case 'time_based':
        // åŸºäºæ—¶é—´çš„è®¿é—®æ§åˆ¶
        const now = new Date();
        const hour = now.getHours();
        return hour >= policy.startHour && hour <= policy.endHour;
      
      case 'location':
        // åŸºäºä½ç½®çš„è®¿é—®æ§åˆ¶
        return this.isIpInRange(context.clientIp, policy.allowedIpRanges);
      
      case 'data_classification':
        // åŸºäºæ•°æ®åˆ†ç±»çš„è®¿é—®æ§åˆ¶
        return user.clearanceLevel >= context.dataClassification;
      
      default:
        return true;
    }
  }
  
  async createRole(roleData: CreateRoleDto): Promise<Role> {
    // éªŒè¯æƒé™æ ¼å¼
    this.validatePermissions(roleData.permissions);
    
    const role = await this.roleRepository.create(roleData);
    
    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.clearPermissionCache();
    
    await this.auditLog('rbac.role_created', {
      roleId: role.id,
      roleName: role.name
    });
    
    return role;
  }
  
  async assignRole(userId: string, roleName: string): Promise<void> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    const role = await this.roleRepository.findByName(roleName);
    if (!role) {
      throw new NotFoundError('Role not found');
    }
    
    // æ£€æŸ¥è§’è‰²å†²çª
    if (this.hasRoleConflict(user.roles, roleName)) {
      throw new ConflictError('Role conflict detected');
    }
    
    user.roles.push(roleName);
    await this.userRepository.update(user);
    
    // æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
    await this.cache.del(`permissions:${userId}`);
    
    await this.auditLog('rbac.role_assigned', {
      userId,
      roleName
    });
  }
  
  private validatePermissions(permissions: string[]): void {
    const pattern = /^[a-z_]+:[a-z_]+|\*$/;
    
    for (const permission of permissions) {
      if (!pattern.test(permission)) {
        throw new ValidationError(`Invalid permission format: ${permission}`);
      }
    }
  }
  
  private hasRoleConflict(currentRoles: string[], newRole: string): boolean {
    // æ£€æŸ¥äº’æ–¥è§’è‰²
    const mutuallyExclusive = {
      'admin': ['viewer'],
      'manager': ['operator'],
    };
    
    const exclusions = mutuallyExclusive[newRole] || [];
    return currentRoles.some(role => exclusions.includes(role));
  }
}
```

---

## Milestone 9.2: æ•°æ®å®‰å…¨ä¸å®¡è®¡ï¼ˆ1å¤©ï¼‰

### Day 2: æ•°æ®åŠ å¯†å’Œå®¡è®¡å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. æ•°æ®åŠ å¯†æœåŠ¡
```typescript
// src/security/crypto/CryptoService.ts
import crypto from 'crypto';
import { promisify } from 'util';

@Injectable()
export class CryptoService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyDerivationIterations = 100000;
  private masterKey: Buffer;
  private dataKeys = new Map<string, Buffer>();
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('KeyManagementService') private kms: KeyManagementService
  ) {
    this.initializeMasterKey();
  }
  
  private async initializeMasterKey(): Promise<void> {
    // ä»KMSæˆ–ç¯å¢ƒå˜é‡è·å–ä¸»å¯†é’¥
    const masterKeyBase64 = await this.kms.getMasterKey();
    this.masterKey = Buffer.from(masterKeyBase64, 'base64');
  }
  
  // å­—æ®µçº§åŠ å¯†
  async encryptField(data: string, context?: string): Promise<EncryptedData> {
    // ç”Ÿæˆæ•°æ®åŠ å¯†å¯†é’¥
    const dataKey = await this.getOrCreateDataKey(context || 'default');
    
    // ç”ŸæˆéšæœºIV
    const iv = crypto.randomBytes(16);
    
    // åˆ›å»ºåŠ å¯†å™¨
    const cipher = crypto.createCipheriv(this.algorithm, dataKey, iv);
    
    // åŠ å¯†æ•°æ®
    const encrypted = Buffer.concat([
      cipher.update(data, 'utf8'),
      cipher.final()
    ]);
    
    // è·å–è®¤è¯æ ‡ç­¾
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted: encrypted.toString('base64'),
      iv: iv.toString('base64'),
      authTag: authTag.toString('base64'),
      algorithm: this.algorithm,
      keyId: context || 'default'
    };
  }
  
  // å­—æ®µçº§è§£å¯†
  async decryptField(encryptedData: EncryptedData): Promise<string> {
    // è·å–æ•°æ®å¯†é’¥
    const dataKey = await this.getOrCreateDataKey(encryptedData.keyId);
    
    // è§£æåŠ å¯†æ•°æ®
    const encrypted = Buffer.from(encryptedData.encrypted, 'base64');
    const iv = Buffer.from(encryptedData.iv, 'base64');
    const authTag = Buffer.from(encryptedData.authTag, 'base64');
    
    // åˆ›å»ºè§£å¯†å™¨
    const decipher = crypto.createDecipheriv(this.algorithm, dataKey, iv);
    decipher.setAuthTag(authTag);
    
    // è§£å¯†æ•°æ®
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    
    return decrypted.toString('utf8');
  }
  
  // æ‰¹é‡åŠ å¯†
  async encryptBatch(items: any[], fields: string[]): Promise<any[]> {
    const encrypted = [];
    
    for (const item of items) {
      const encryptedItem = { ...item };
      
      for (const field of fields) {
        if (item[field]) {
          encryptedItem[field] = await this.encryptField(item[field], field);
        }
      }
      
      encrypted.push(encryptedItem);
    }
    
    return encrypted;
  }
  
  // é€æ˜åŠ å¯†è£…é¥°å™¨
  EncryptedField(fieldName?: string) {
    return (target: any, propertyKey: string) => {
      const field = fieldName || propertyKey;
      
      // ä¿å­˜åŸå§‹çš„getterå’Œsetter
      const getter = target.__lookupGetter__(propertyKey);
      const setter = target.__lookupSetter__(propertyKey);
      
      // å®šä¹‰æ–°çš„getterå’Œsetter
      Object.defineProperty(target, propertyKey, {
        get: async function() {
          const encrypted = this[`_encrypted_${field}`];
          if (encrypted) {
            return await this.cryptoService.decryptField(encrypted);
          }
          return getter?.call(this);
        },
        set: async function(value: string) {
          if (value) {
            this[`_encrypted_${field}`] = await this.cryptoService.encryptField(value, field);
          }
          setter?.call(this, value);
        }
      });
    };
  }
  
  // æ–‡ä»¶åŠ å¯†
  async encryptFile(filePath: string, outputPath: string): Promise<void> {
    const algorithm = 'aes-256-cbc';
    const key = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);
    
    // ä½¿ç”¨ä¸»å¯†é’¥åŠ å¯†æ–‡ä»¶å¯†é’¥
    const encryptedKey = await this.encryptWithMasterKey(key);
    
    const input = fs.createReadStream(filePath);
    const output = fs.createWriteStream(outputPath);
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    
    // å†™å…¥åŠ å¯†å…ƒæ•°æ®
    const metadata = {
      algorithm,
      encryptedKey: encryptedKey.toString('base64'),
      iv: iv.toString('base64')
    };
    
    output.write(JSON.stringify(metadata) + '\n');
    
    // åŠ å¯†æ–‡ä»¶å†…å®¹
    input.pipe(cipher).pipe(output);
    
    return new Promise((resolve, reject) => {
      output.on('finish', resolve);
      output.on('error', reject);
    });
  }
  
  // æ•°æ®è„±æ•
  maskSensitiveData(data: any, rules: MaskingRule[]): any {
    const masked = { ...data };
    
    for (const rule of rules) {
      if (masked[rule.field]) {
        masked[rule.field] = this.applyMasking(masked[rule.field], rule);
      }
    }
    
    return masked;
  }
  
  private applyMasking(value: string, rule: MaskingRule): string {
    switch (rule.type) {
      case 'email':
        // é‚®ç®±è„±æ•ï¼šä¿ç•™å‰3ä½å’Œ@åçš„åŸŸå
        return value.replace(/^(.{3}).*(@.*)$/, '$1****$2');
      
      case 'phone':
        // æ‰‹æœºå·è„±æ•ï¼šä¿ç•™å‰3ä½å’Œå4ä½
        return value.replace(/^(\d{3})\d{4}(\d{4})$/, '$1****$2');
      
      case 'idcard':
        // èº«ä»½è¯è„±æ•ï¼šä¿ç•™å‰6ä½å’Œå4ä½
        return value.replace(/^(.{6}).*(.{4})$/, '$1********$2');
      
      case 'name':
        // å§“åè„±æ•ï¼šä¿ç•™å§“æ°
        return value[0] + '*'.repeat(value.length - 1);
      
      case 'custom':
        // è‡ªå®šä¹‰è„±æ•è§„åˆ™
        return value.replace(rule.pattern!, rule.replacement!);
      
      default:
        return '***';
    }
  }
  
  private async getOrCreateDataKey(keyId: string): Promise<Buffer> {
    if (this.dataKeys.has(keyId)) {
      return this.dataKeys.get(keyId)!;
    }
    
    // ä½¿ç”¨ä¸»å¯†é’¥æ´¾ç”Ÿæ•°æ®å¯†é’¥
    const salt = crypto.createHash('sha256').update(keyId).digest();
    const dataKey = await promisify(crypto.pbkdf2)(
      this.masterKey,
      salt,
      this.keyDerivationIterations,
      32,
      'sha256'
    );
    
    this.dataKeys.set(keyId, dataKey);
    return dataKey;
  }
  
  private async encryptWithMasterKey(data: Buffer): Promise<Buffer> {
    const cipher = crypto.createCipheriv(
      'aes-256-gcm',
      this.masterKey,
      crypto.randomBytes(16)
    );
    
    return Buffer.concat([
      cipher.update(data),
      cipher.final(),
      cipher.getAuthTag()
    ]);
  }
}
```

#### 2. å®¡è®¡æ—¥å¿—æœåŠ¡
```typescript
// src/security/audit/AuditService.ts
@Injectable()
export class AuditService {
  private auditQueue: Queue;
  
  constructor(
    @Inject('AuditRepository') private repository: AuditRepository,
    @Inject('CryptoService') private crypto: CryptoService,
    @Inject('Logger') private logger: Logger,
    @Inject('EventBus') private eventBus: EventBus
  ) {
    this.auditQueue = new Queue('audit-logs');
    this.setupQueueProcessor();
  }
  
  async log(entry: AuditLogEntry): Promise<void> {
    // æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
    const enrichedEntry: AuditLog = {
      ...entry,
      id: generateId(),
      timestamp: new Date(),
      requestId: this.getRequestId(),
      sessionId: this.getSessionId(),
      clientIp: this.getClientIp(),
      userAgent: this.getUserAgent(),
      serverHostname: os.hostname()
    };
    
    // è®¡ç®—æ—¥å¿—å“ˆå¸Œï¼ˆç”¨äºé˜²ç¯¡æ”¹ï¼‰
    enrichedEntry.hash = this.calculateHash(enrichedEntry);
    
    // å¦‚æœåŒ…å«æ•æ„Ÿæ•°æ®ï¼Œè¿›è¡ŒåŠ å¯†
    if (entry.sensitive) {
      enrichedEntry.details = await this.crypto.encryptField(
        JSON.stringify(entry.details),
        'audit'
      );
    }
    
    // æ·»åŠ åˆ°é˜Ÿåˆ—å¼‚æ­¥å¤„ç†
    await this.auditQueue.add(enrichedEntry, {
      priority: this.getPriority(entry.severity),
      removeOnComplete: true
    });
    
    // å¦‚æœæ˜¯é«˜å±æ“ä½œï¼Œç«‹å³é€šçŸ¥
    if (entry.severity === 'critical') {
      this.eventBus.emit('audit.critical', enrichedEntry);
    }
  }
  
  private setupQueueProcessor(): void {
    this.auditQueue.process(async (job) => {
      const auditLog = job.data;
      
      try {
        // å­˜å‚¨åˆ°æ•°æ®åº“
        await this.repository.save(auditLog);
        
        // å‘é€åˆ°SIEMç³»ç»Ÿ
        if (this.config.get('audit.siem.enabled')) {
          await this.sendToSiem(auditLog);
        }
        
        // å®æ—¶åˆ†æå¼‚å¸¸è¡Œä¸º
        await this.analyzeForAnomalies(auditLog);
      } catch (error) {
        this.logger.error('Failed to process audit log', error);
        throw error; // é‡è¯•
      }
    });
  }
  
  async query(filters: AuditQueryFilters): Promise<AuditLog[]> {
    // æƒé™æ£€æŸ¥
    const user = this.getCurrentUser();
    if (!user.hasPermission('audit:read')) {
      throw new ForbiddenError('Insufficient permissions to read audit logs');
    }
    
    // æ„å»ºæŸ¥è¯¢
    const query = this.buildQuery(filters);
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const logs = await this.repository.find(query);
    
    // è§£å¯†æ•æ„Ÿæ•°æ®ï¼ˆå¦‚æœæœ‰æƒé™ï¼‰
    if (user.hasPermission('audit:read:sensitive')) {
      for (const log of logs) {
        if (log.sensitive && log.details) {
          log.details = JSON.parse(
            await this.crypto.decryptField(log.details)
          );
        }
      }
    }
    
    // è®°å½•å®¡è®¡æ—¥å¿—æŸ¥è¯¢æ“ä½œ
    await this.log({
      action: 'audit.query',
      resource: 'audit_logs',
      userId: user.id,
      details: { filters },
      severity: 'info'
    });
    
    return logs;
  }
  
  private async analyzeForAnomalies(log: AuditLog): Promise<void> {
    // æ£€æµ‹å¼‚å¸¸æ¨¡å¼
    const anomalies = [];
    
    // 1. éå·¥ä½œæ—¶é—´çš„æ•æ„Ÿæ“ä½œ
    if (this.isOutsideBusinessHours(log.timestamp) && 
        this.isSensitiveAction(log.action)) {
      anomalies.push({
        type: 'unusual_time',
        severity: 'medium'
      });
    }
    
    // 2. å¼‚å¸¸åœ°ç†ä½ç½®
    const userLocation = await this.getUserUsualLocation(log.userId);
    if (userLocation && !this.isNearLocation(log.clientIp, userLocation)) {
      anomalies.push({
        type: 'unusual_location',
        severity: 'high'
      });
    }
    
    // 3. æ‰¹é‡æ“ä½œæ£€æµ‹
    const recentActions = await this.getRecentActions(log.userId, 60); // æœ€è¿‘60ç§’
    if (recentActions.length > 100) {
      anomalies.push({
        type: 'bulk_operation',
        severity: 'medium'
      });
    }
    
    // 4. æƒé™æå‡æ£€æµ‹
    if (this.isPrivilegeEscalation(log.action)) {
      anomalies.push({
        type: 'privilege_escalation',
        severity: 'critical'
      });
    }
    
    // 5. æ•°æ®å¤–æ³„æ£€æµ‹
    if (this.isPotentialDataExfiltration(log)) {
      anomalies.push({
        type: 'data_exfiltration',
        severity: 'critical'
      });
    }
    
    // å¦‚æœæ£€æµ‹åˆ°å¼‚å¸¸ï¼Œå‘é€å‘Šè­¦
    if (anomalies.length > 0) {
      await this.handleAnomalies(log, anomalies);
    }
  }
  
  private async handleAnomalies(log: AuditLog, anomalies: any[]): Promise<void> {
    // è®°å½•å®‰å…¨äº‹ä»¶
    const securityEvent = {
      id: generateId(),
      timestamp: new Date(),
      auditLogId: log.id,
      userId: log.userId,
      anomalies,
      status: 'pending'
    };
    
    await this.repository.saveSecurityEvent(securityEvent);
    
    // æ ¹æ®ä¸¥é‡ç¨‹åº¦é‡‡å–è¡ŒåŠ¨
    const maxSeverity = Math.max(...anomalies.map(a => 
      a.severity === 'critical' ? 3 : a.severity === 'high' ? 2 : 1
    ));
    
    if (maxSeverity === 3) {
      // ç«‹å³é”å®šè´¦æˆ·
      await this.userService.lockAccount(log.userId, 'Security anomaly detected');
      
      // å‘é€ç´§æ€¥å‘Šè­¦
      await this.alerting.sendUrgentAlert({
        title: 'Critical Security Event',
        message: `User ${log.userId} account locked due to suspicious activity`,
        details: securityEvent
      });
    } else if (maxSeverity === 2) {
      // è¦æ±‚é‡æ–°è®¤è¯
      await this.authService.requireReauthentication(log.userId);
      
      // å‘é€å‘Šè­¦
      await this.alerting.sendAlert({
        severity: 'high',
        title: 'Security Anomaly Detected',
        details: securityEvent
      });
    }
  }
  
  private calculateHash(entry: any): string {
    const content = JSON.stringify({
      action: entry.action,
      resource: entry.resource,
      userId: entry.userId,
      timestamp: entry.timestamp,
      details: entry.details
    });
    
    return crypto
      .createHash('sha256')
      .update(content)
      .digest('hex');
  }
  
  private isSensitiveAction(action: string): boolean {
    const sensitiveActions = [
      'user.delete',
      'role.assign',
      'permission.grant',
      'data.export',
      'config.modify'
    ];
    
    return sensitiveActions.includes(action);
  }
  
  private isPrivilegeEscalation(action: string): boolean {
    return action.includes('role.assign') || 
           action.includes('permission.grant');
  }
  
  private isPotentialDataExfiltration(log: AuditLog): boolean {
    // æ£€æŸ¥æ˜¯å¦æ˜¯å¤§é‡æ•°æ®å¯¼å‡º
    if (log.action.includes('export') && log.details?.recordCount > 10000) {
      return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•æ„Ÿæ•°æ®è®¿é—®
    if (log.resource?.includes('sensitive') && log.action === 'read') {
      return true;
    }
    
    return false;
  }
  
  // ç”Ÿæˆåˆè§„æŠ¥å‘Š
  async generateComplianceReport(
    startDate: Date,
    endDate: Date,
    compliance: 'GDPR' | 'HIPAA' | 'SOC2'
  ): Promise<ComplianceReport> {
    const logs = await this.repository.findByDateRange(startDate, endDate);
    
    const report: ComplianceReport = {
      period: { start: startDate, end: endDate },
      compliance,
      summary: {
        totalEvents: logs.length,
        userAccess: 0,
        dataModifications: 0,
        securityIncidents: 0,
        systemChanges: 0
      },
      details: [],
      recommendations: []
    };
    
    // åˆ†ææ—¥å¿—
    for (const log of logs) {
      if (log.action.includes('login') || log.action.includes('logout')) {
        report.summary.userAccess++;
      }
      if (log.action.includes('create') || log.action.includes('update') || log.action.includes('delete')) {
        report.summary.dataModifications++;
      }
      if (log.severity === 'critical') {
        report.summary.securityIncidents++;
      }
      if (log.resource === 'system' || log.resource === 'config') {
        report.summary.systemChanges++;
      }
    }
    
    // ç”Ÿæˆå»ºè®®
    if (report.summary.securityIncidents > 0) {
      report.recommendations.push('Review and address security incidents');
    }
    
    return report;
  }
}
```

## ğŸ“Š Phase 9 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] JWTä»¤ç‰Œç­¾åéªŒè¯é€šè¿‡
- [ ] æƒé™æ£€æŸ¥å“åº”æ—¶é—´ < 10ms
- [ ] åŠ å¯†/è§£å¯†æ€§èƒ½ < 50ms
- [ ] å®¡è®¡æ—¥å¿—å®Œæ•´æ€§ 100%
- [ ] å®‰å…¨æ¼æ´æ‰«æé€šè¿‡

### åŠŸèƒ½éªŒè¯
- [ ] å¤šå› ç´ è®¤è¯å·¥ä½œæ­£å¸¸
- [ ] è§’è‰²æƒé™æ§åˆ¶å‡†ç¡®
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] å®¡è®¡æ—¥å¿—ä¸å¯ç¯¡æ”¹
- [ ] å¼‚å¸¸è¡Œä¸ºæ£€æµ‹åŠæ—¶

### å®‰å…¨æŒ‡æ ‡
- [ ] OWASP Top 10 é˜²æŠ¤
- [ ] å¯†ç å¼ºåº¦ç­–ç•¥æ‰§è¡Œ
- [ ] ä¼šè¯ç®¡ç†å®‰å…¨
- [ ] APIé™æµæ­£å¸¸
- [ ] å®‰å…¨å¤´é…ç½®å®Œæ•´

## ğŸš€ Phase 9 äº¤ä»˜ç‰©

1. **è®¤è¯æˆæƒ**
   - JWTè®¤è¯æœåŠ¡
   - OAuth2é›†æˆï¼ˆå¯é€‰ï¼‰
   - RBACæƒé™ç³»ç»Ÿ
   - ABACç­–ç•¥å¼•æ“

2. **æ•°æ®å®‰å…¨**
   - å­—æ®µçº§åŠ å¯†
   - æ–‡ä»¶åŠ å¯†
   - æ•°æ®è„±æ•
   - å¯†é’¥ç®¡ç†

3. **å®¡è®¡ç³»ç»Ÿ**
   - å®¡è®¡æ—¥å¿—æœåŠ¡
   - å¼‚å¸¸æ£€æµ‹
   - åˆè§„æŠ¥å‘Š
   - å®‰å…¨äº‹ä»¶å¤„ç†

4. **å®‰å…¨é…ç½®**
   - å®‰å…¨ä¸­é—´ä»¶
   - CORSé…ç½®
   - CSPç­–ç•¥
   - Rate Limiting

5. **æ–‡æ¡£**
   - SECURITY-GUIDE.md
   - RBAC-DESIGN.md
   - AUDIT-POLICY.md
   - INCIDENT-RESPONSE.md

è¿™å°±æ˜¯Phase 9çš„å®Œæ•´å®æ–½æ–¹æ¡ˆï¼Œæ¶µç›–äº†èº«ä»½è®¤è¯ã€æˆæƒç®¡ç†ã€æ•°æ®åŠ å¯†å’Œå®¡è®¡æ—¥å¿—ç­‰å…³é”®å®‰å…¨ç¯èŠ‚ï¼Œç¡®ä¿ç³»ç»Ÿçš„å®‰å…¨æ€§å’Œåˆè§„æ€§ã€‚