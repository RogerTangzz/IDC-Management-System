## Phase 2: Storeå±‚é‡æ„ - è¯¦ç»†å®æ–½æ–¹æ¡ˆï¼ˆ4å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **å¼€å‘è€…Aè´Ÿè´£**: Milestone 2.1 StoreèŒè´£åˆ†ç¦»
- **å¼€å‘è€…Bè´Ÿè´£**: Milestone 2.2 ç»Ÿä¸€çŠ¶æ€ç®¡ç†æ¨¡å¼
- **Day 4**: ååŒæµ‹è¯•ä¸é›†æˆ

---

## Milestone 2.1: StoreèŒè´£åˆ†ç¦»ï¼ˆ2å¤©ï¼‰

### Day 1 ä¸Šåˆï¼šåˆ†æç°æœ‰Storeé—®é¢˜ï¼ˆ4å°æ—¶ï¼‰

#### 1. ç°æœ‰Storeé—®é¢˜æ‰«æ
```javascript
// scripts/analyze-store.js
const fs = require('fs');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;

class StoreAnalyzer {
  constructor() {
    this.issues = {
      mixedConcerns: [],      // æ··åˆå…³æ³¨ç‚¹
      directApiCalls: [],     // ç›´æ¥APIè°ƒç”¨
      businessLogic: [],      // ä¸šåŠ¡é€»è¾‘
      crossModuleDeps: [],    // è·¨æ¨¡å—ä¾èµ–
      complexGetters: [],     // å¤æ‚è®¡ç®—å±æ€§
      largeState: []          // è¿‡å¤§çš„çŠ¶æ€
    };
  }
  
  analyzeFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf8');
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript']
    });
    
    traverse(ast, {
      // æ£€æµ‹ç›´æ¥APIè°ƒç”¨
      ImportDeclaration: (path) => {
        if (path.node.source.value.includes('/api/')) {
          this.issues.directApiCalls.push({
            file: filePath,
            line: path.node.loc.start.line,
            import: path.node.source.value
          });
        }
      },
      
      // æ£€æµ‹å¤æ‚é€»è¾‘
      FunctionDeclaration: (path) => {
        const lineCount = path.node.loc.end.line - path.node.loc.start.line;
        if (lineCount > 20) {
          this.issues.businessLogic.push({
            file: filePath,
            function: path.node.id?.name,
            lines: lineCount
          });
        }
      }
    });
  }
  
  generateReport() {
    console.log('=== Storeå±‚é—®é¢˜åˆ†ææŠ¥å‘Š ===\n');
    
    console.log(`ç›´æ¥APIè°ƒç”¨: ${this.issues.directApiCalls.length}å¤„`);
    console.log(`å¤æ‚ä¸šåŠ¡é€»è¾‘: ${this.issues.businessLogic.length}å¤„`);
    console.log(`è·¨æ¨¡å—ä¾èµ–: ${this.issues.crossModuleDeps.length}å¤„`);
    
    // ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
    fs.writeFileSync(
      'store-analysis-report.json',
      JSON.stringify(this.issues, null, 2)
    );
  }
}

// æ‰§è¡Œåˆ†æ
const analyzer = new StoreAnalyzer();
const storeFiles = glob.sync('src/store/modules/*.js');
storeFiles.forEach(file => analyzer.analyzeFile(file));
analyzer.generateReport();
```

#### 2. è¯†åˆ«StoreèŒè´£è¾¹ç•Œ
```typescript
// docs/store-responsibilities.md
/**
 * StoreèŒè´£çŸ©é˜µ
 * 
 * âœ… Storeåº”è¯¥è´Ÿè´£çš„:
 * - çŠ¶æ€å­˜å‚¨å’Œç®¡ç†
 * - çŠ¶æ€çš„åŒæ­¥æ›´æ–°(mutations)
 * - è°ƒç”¨æœåŠ¡å±‚è·å–æ•°æ®(actions)
 * - ç®€å•çš„æ´¾ç”ŸçŠ¶æ€(getters)
 * - çŠ¶æ€æŒä¹…åŒ–
 * 
 * âŒ Storeä¸åº”è¯¥è´Ÿè´£çš„:
 * - å¤æ‚çš„ä¸šåŠ¡é€»è¾‘è®¡ç®—
 * - ç›´æ¥è°ƒç”¨API
 * - æ•°æ®è½¬æ¢å’Œæ ¼å¼åŒ–
 * - æƒé™åˆ¤æ–­é€»è¾‘
 * - è·¯ç”±æ§åˆ¶
 */

// é—®é¢˜ç¤ºä¾‹ - permission.ts (1300è¡Œ)
const permissionStore = {
  state: {
    routes: [],
    addRoutes: [],
    permissions: []
  },
  
  actions: {
    // âŒ é—®é¢˜1: æ··åˆäº†è·¯ç”±ç”Ÿæˆã€æƒé™åˆ¤æ–­ã€èœå•æ„å»º
    generateRoutes({ commit }, roles) {
      // 200è¡Œçš„å¤æ‚é€»è¾‘...
      // åŒ…å«é€’å½’ã€è¿‡æ»¤ã€è½¬æ¢ã€æ’åºç­‰
    },
    
    // âŒ é—®é¢˜2: ç›´æ¥æ“ä½œè·¯ç”±
    addDynamicRoutes() {
      // ç›´æ¥è°ƒç”¨router.addRoute
    },
    
    // âŒ é—®é¢˜3: åŒ…å«ä¸šåŠ¡é€»è¾‘
    checkPermission(route, roles) {
      // å¤æ‚çš„æƒé™åˆ¤æ–­é€»è¾‘
    }
  }
}
```

### Day 1 ä¸‹åˆï¼šæ‹†åˆ†permission.tsï¼ˆ4å°æ—¶ï¼‰

#### 1. åˆ›å»ºç‹¬ç«‹çš„æœåŠ¡å±‚
```typescript
// src/services/PermissionService.ts
export class PermissionService {
  private permissionCache = new Map<string, boolean>();
  
  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
   */
  hasPermission(permission: string, userPermissions: string[]): boolean {
    const cacheKey = `${permission}:${userPermissions.join(',')}`;
    
    if (this.permissionCache.has(cacheKey)) {
      return this.permissionCache.get(cacheKey)!;
    }
    
    const hasPermi = userPermissions.includes(permission) || 
                     userPermissions.includes('*:*:*');
    
    this.permissionCache.set(cacheKey, hasPermi);
    return hasPermi;
  }
  
  /**
   * æ£€æŸ¥è§’è‰²
   */
  hasRole(role: string, userRoles: string[]): boolean {
    return userRoles.includes(role) || userRoles.includes('admin');
  }
  
  /**
   * è¿‡æ»¤æœ‰æƒé™çš„è·¯ç”±
   */
  filterRoutes(routes: RouteConfig[], permissions: string[]): RouteConfig[] {
    return routes.filter(route => {
      if (route.meta?.permissions) {
        return route.meta.permissions.some(p => 
          this.hasPermission(p, permissions)
        );
      }
      return true;
    }).map(route => {
      if (route.children) {
        return {
          ...route,
          children: this.filterRoutes(route.children, permissions)
        };
      }
      return route;
    });
  }
}

// src/services/RouteService.ts
export class RouteService {
  /**
   * ç”ŸæˆåŠ¨æ€è·¯ç”±
   */
  generateDynamicRoutes(
    asyncRoutes: RouteConfig[],
    permissions: string[]
  ): RouteConfig[] {
    const permissionService = container.get('PermissionService');
    
    // 1. è¿‡æ»¤æƒé™
    const accessibleRoutes = permissionService.filterRoutes(
      asyncRoutes,
      permissions
    );
    
    // 2. å¤„ç†è·¯ç”±å…ƒæ•°æ®
    const processedRoutes = this.processRouteMeta(accessibleRoutes);
    
    // 3. æ’åºè·¯ç”±
    const sortedRoutes = this.sortRoutes(processedRoutes);
    
    return sortedRoutes;
  }
  
  /**
   * å¤„ç†è·¯ç”±å…ƒæ•°æ®
   */
  private processRouteMeta(routes: RouteConfig[]): RouteConfig[] {
    return routes.map(route => ({
      ...route,
      meta: {
        ...route.meta,
        title: route.meta?.title || route.name,
        icon: route.meta?.icon || 'default-icon',
        hidden: route.meta?.hidden || false
      }
    }));
  }
  
  /**
   * è·¯ç”±æ’åº
   */
  private sortRoutes(routes: RouteConfig[]): RouteConfig[] {
    return routes.sort((a, b) => {
      const orderA = a.meta?.order || 999;
      const orderB = b.meta?.order || 999;
      return orderA - orderB;
    });
  }
}

// src/services/MenuService.ts
export class MenuService {
  /**
   * ä»è·¯ç”±ç”Ÿæˆèœå•
   */
  generateMenuFromRoutes(routes: RouteConfig[]): MenuItem[] {
    return routes
      .filter(route => !route.meta?.hidden)
      .map(route => this.routeToMenuItem(route));
  }
  
  private routeToMenuItem(route: RouteConfig): MenuItem {
    const menuItem: MenuItem = {
      path: route.path,
      name: route.name,
      title: route.meta?.title || route.name,
      icon: route.meta?.icon,
      component: route.component
    };
    
    if (route.children?.length) {
      menuItem.children = route.children
        .filter(child => !child.meta?.hidden)
        .map(child => this.routeToMenuItem(child));
    }
    
    return menuItem;
  }
}
```

#### 2. é‡æ„permission store
```typescript
// src/store/modules/permission.ts (é‡æ„åï¼Œçº¦200è¡Œ)
import { defineStore } from 'pinia';
import { RouteService, MenuService } from '@/services';

export const usePermissionStore = defineStore('permission', {
  state: () => ({
    routes: [] as RouteConfig[],
    addRoutes: [] as RouteConfig[],
    permissions: [] as string[],
    menus: [] as MenuItem[]
  }),
  
  getters: {
    // ç®€å•çš„æ´¾ç”ŸçŠ¶æ€
    hasRoutes: (state) => state.routes.length > 0,
    menuList: (state) => state.menus,
    permissionList: (state) => state.permissions
  },
  
  actions: {
    /**
     * è®¾ç½®æƒé™
     */
    setPermissions(permissions: string[]) {
      this.permissions = permissions;
    },
    
    /**
     * ç”Ÿæˆè·¯ç”±ï¼ˆå§”æ‰˜ç»™æœåŠ¡å±‚ï¼‰
     */
    async generateRoutes() {
      const routeService = container.get<RouteService>('RouteService');
      const menuService = container.get<MenuService>('MenuService');
      
      // 1. ç”Ÿæˆå¯è®¿é—®çš„è·¯ç”±
      const accessibleRoutes = routeService.generateDynamicRoutes(
        asyncRoutes,
        this.permissions
      );
      
      // 2. ç”Ÿæˆèœå•
      const menus = menuService.generateMenuFromRoutes(accessibleRoutes);
      
      // 3. æ›´æ–°çŠ¶æ€
      this.addRoutes = accessibleRoutes;
      this.routes = constantRoutes.concat(accessibleRoutes);
      this.menus = menus;
      
      return accessibleRoutes;
    },
    
    /**
     * æ¸…ç†æƒé™
     */
    resetPermission() {
      this.$reset();
    }
  }
});
```

### Day 2 ä¸Šåˆï¼šåˆ›å»ºä¸šåŠ¡StoreåŸºç±»ï¼ˆ4å°æ—¶ï¼‰

#### 1. å®šä¹‰StoreåŸºç±»
```typescript
// src/store/base/BaseStore.ts
import { defineStore } from 'pinia';

export interface BaseState {
  loading: boolean;
  error: Error | null;
  initialized: boolean;
}

export interface CrudState<T> extends BaseState {
  items: T[];
  currentItem: T | null;
  total: number;
  query: Record<string, any>;
}

/**
 * åˆ›å»ºCRUD Storeçš„å·¥å‚å‡½æ•°
 */
export function createCrudStore<T extends { id: number | string }>(
  name: string,
  service: any
) {
  return defineStore(`${name}`, {
    state: (): CrudState<T> => ({
      loading: false,
      error: null,
      initialized: false,
      items: [],
      currentItem: null,
      total: 0,
      query: {
        page: 1,
        pageSize: 20
      }
    }),
    
    getters: {
      // é€šç”¨getters
      isEmpty: (state) => state.items.length === 0,
      hasError: (state) => state.error !== null,
      isLoading: (state) => state.loading,
      
      // åˆ†é¡µç›¸å…³
      currentPage: (state) => state.query.page || 1,
      pageSize: (state) => state.query.pageSize || 20,
      totalPages: (state) => Math.ceil(state.total / (state.query.pageSize || 20)),
      
      // æŸ¥æ‰¾ç›¸å…³
      findById: (state) => (id: number | string) => 
        state.items.find(item => item.id === id),
      
      // è¿‡æ»¤ç›¸å…³
      filteredItems: (state) => (filter: (item: T) => boolean) =>
        state.items.filter(filter)
    },
    
    actions: {
      /**
       * åˆå§‹åŒ–
       */
      async initialize() {
        if (this.initialized) return;
        
        await this.fetchList();
        this.initialized = true;
      },
      
      /**
       * è·å–åˆ—è¡¨
       */
      async fetchList(query?: Record<string, any>) {
        this.loading = true;
        this.error = null;
        
        try {
          const mergedQuery = { ...this.query, ...query };
          const response = await service.list(mergedQuery);
          
          this.items = response.rows;
          this.total = response.total;
          this.query = mergedQuery;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * è·å–è¯¦æƒ…
       */
      async fetchById(id: number | string) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.get(id);
          this.currentItem = item;
          
          // æ›´æ–°åˆ—è¡¨ä¸­çš„é¡¹
          const index = this.items.findIndex(i => i.id === id);
          if (index !== -1) {
            this.items[index] = item;
          }
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * åˆ›å»º
       */
      async create(data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.create(data);
          
          // æ·»åŠ åˆ°åˆ—è¡¨
          this.items.unshift(item);
          this.total += 1;
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * æ›´æ–°
       */
      async update(id: number | string, data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.update(id, data);
          
          // æ›´æ–°åˆ—è¡¨
          const index = this.items.findIndex(i => i.id === id);
          if (index !== -1) {
            this.items[index] = item;
          }
          
          // æ›´æ–°å½“å‰é¡¹
          if (this.currentItem?.id === id) {
            this.currentItem = item;
          }
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * åˆ é™¤
       */
      async remove(id: number | string) {
        this.loading = true;
        this.error = null;
        
        try {
          await service.remove(id);
          
          // ä»åˆ—è¡¨ç§»é™¤
          this.items = this.items.filter(i => i.id !== id);
          this.total -= 1;
          
          // æ¸…ç†å½“å‰é¡¹
          if (this.currentItem?.id === id) {
            this.currentItem = null;
          }
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * æ‰¹é‡æ“ä½œ
       */
      async batchUpdate(ids: (number | string)[], data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          await service.batchUpdate(ids, data);
          
          // æ›´æ–°æœ¬åœ°çŠ¶æ€
          this.items = this.items.map(item => {
            if (ids.includes(item.id)) {
              return { ...item, ...data };
            }
            return item;
          });
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * é‡ç½®æŸ¥è¯¢
       */
      resetQuery() {
        this.query = {
          page: 1,
          pageSize: 20
        };
      },
      
      /**
       * æ¸…ç†Store
       */
      reset() {
        this.$reset();
      }
    }
  });
}
```

#### 2. åˆ›å»ºä¸šåŠ¡Store
```typescript
// src/store/modules/ticket.ts (ä½¿ç”¨åŸºç±»)
import { createCrudStore } from '@/store/base/BaseStore';
import { TicketService } from '@/services/TicketService';
import type { Ticket } from '@/types/api/ticket';

// åŸºç¡€CRUDåŠŸèƒ½
const baseTicketStore = createCrudStore<Ticket>('ticket', TicketService);

// æ‰©å±•ä¸šåŠ¡ç‰¹å®šåŠŸèƒ½
export const useTicketStore = defineStore('ticket', {
  ...baseTicketStore,
  
  state: () => ({
    ...baseTicketStore.state(),
    // ä¸šåŠ¡ç‰¹å®šçŠ¶æ€
    statistics: {
      todayNew: 0,
      todayCompleted: 0,
      nearDue: 0,
      overdue: 0
    },
    escalationQueue: [] as Ticket[]
  }),
  
  getters: {
    ...baseTicketStore.getters,
    // ä¸šåŠ¡ç‰¹å®šgetters
    pendingTickets: (state) => 
      state.items.filter(t => t.status === 'pending'),
    
    myTickets: (state) => (userId: string) =>
      state.items.filter(t => t.assigneeId === userId),
    
    overdueTickets: (state) =>
      state.items.filter(t => {
        if (!t.deadline) return false;
        return new Date(t.deadline) < new Date();
      }),
    
    ticketsByPriority: (state) => {
      const grouped = {} as Record<string, Ticket[]>;
      state.items.forEach(ticket => {
        if (!grouped[ticket.priority]) {
          grouped[ticket.priority] = [];
        }
        grouped[ticket.priority].push(ticket);
      });
      return grouped;
    }
  },
  
  actions: {
    ...baseTicketStore.actions,
    
    /**
     * æ‰¹é‡åˆ†é…å·¥å•
     */
    async batchAssign(ticketIds: string[], assigneeId: string) {
      this.loading = true;
      
      try {
        await TicketService.batchAssign(ticketIds, assigneeId);
        
        // æ›´æ–°æœ¬åœ°çŠ¶æ€
        this.items = this.items.map(ticket => {
          if (ticketIds.includes(ticket.id)) {
            return {
              ...ticket,
              assigneeId,
              status: 'assigned'
            };
          }
          return ticket;
        });
        
        // å‘å¸ƒäº‹ä»¶
        eventBus.emit('tickets.assigned', { ticketIds, assigneeId });
      } catch (error) {
        this.error = error as Error;
        throw error;
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * è·å–ç»Ÿè®¡æ•°æ®
     */
    async fetchStatistics() {
      try {
        const stats = await TicketService.getStatistics();
        this.statistics = stats;
      } catch (error) {
        console.error('Failed to fetch statistics:', error);
      }
    },
    
    /**
     * å·¥å•å‡çº§
     */
    async escalateTicket(ticketId: string) {
      const ticket = this.findById(ticketId);
      if (!ticket) return;
      
      const newPriority = this.getNextPriority(ticket.priority);
      await this.update(ticketId, { priority: newPriority });
      
      // è®°å½•å‡çº§
      this.escalationQueue.push({
        ...ticket,
        priority: newPriority
      });
    },
    
    /**
     * è·å–ä¸‹ä¸€ä¼˜å…ˆçº§
     */
    private getNextPriority(current: string): string {
      const priorities = ['low', 'medium', 'high', 'urgent'];
      const currentIndex = priorities.indexOf(current);
      
      if (currentIndex === -1 || currentIndex === priorities.length - 1) {
        return current;
      }
      
      return priorities[currentIndex + 1];
    }
  }
});
```

### Day 2 ä¸‹åˆï¼šæ‹†åˆ†å…¶ä»–å¤æ‚Storeï¼ˆ4å°æ—¶ï¼‰

#### 1. æ‹†åˆ†user store
```typescript
// src/services/AuthService.ts
export class AuthService {
  private tokenKey = 'Admin-Token';
  
  /**
   * ç™»å½•
   */
  async login(credentials: LoginCredentials): Promise<LoginResult> {
    const response = await api.login(credentials);
    
    if (response.token) {
      this.setToken(response.token);
    }
    
    return response;
  }
  
  /**
   * è·å–ç”¨æˆ·ä¿¡æ¯
   */
  async getUserInfo(): Promise<UserInfo> {
    const token = this.getToken();
    if (!token) {
      throw new Error('No token found');
    }
    
    return await api.getUserInfo();
  }
  
  /**
   * Tokenç®¡ç†
   */
  getToken(): string | null {
    return localStorage.getItem(this.tokenKey);
  }
  
  setToken(token: string): void {
    localStorage.setItem(this.tokenKey, token);
  }
  
  removeToken(): void {
    localStorage.removeItem(this.tokenKey);
  }
  
  /**
   * åˆ·æ–°Token
   */
  async refreshToken(): Promise<string> {
    const response = await api.refreshToken();
    this.setToken(response.token);
    return response.token;
  }
}

// src/store/modules/user.ts (ç®€åŒ–å)
export const useUserStore = defineStore('user', {
  state: () => ({
    token: '',
    userInfo: null as UserInfo | null,
    roles: [] as string[],
    permissions: [] as string[]
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token,
    userId: (state) => state.userInfo?.userId,
    userName: (state) => state.userInfo?.userName,
    avatar: (state) => state.userInfo?.avatar
  },
  
  actions: {
    /**
     * ç™»å½•
     */
    async login(credentials: LoginCredentials) {
      const authService = container.get<AuthService>('AuthService');
      
      const result = await authService.login(credentials);
      this.token = result.token;
      
      // è·å–ç”¨æˆ·ä¿¡æ¯
      await this.getUserInfo();
    },
    
    /**
     * è·å–ç”¨æˆ·ä¿¡æ¯
     */
    async getUserInfo() {
      const authService = container.get<AuthService>('AuthService');
      
      const userInfo = await authService.getUserInfo();
      
      this.userInfo = userInfo;
      this.roles = userInfo.roles;
      this.permissions = userInfo.permissions;
    },
    
    /**
     * ç™»å‡º
     */
    async logout() {
      const authService = container.get<AuthService>('AuthService');
      
      // æ¸…ç†token
      authService.removeToken();
      
      // é‡ç½®çŠ¶æ€
      this.$reset();
      
      // æ¸…ç†å…¶ä»–Store
      const permissionStore = usePermissionStore();
      permissionStore.reset();
    },
    
    /**
     * é‡ç½®Token
     */
    resetToken() {
      const authService = container.get<AuthService>('AuthService');
      authService.removeToken();
      this.token = '';
    }
  }
});
```

---

## Milestone 2.2: ç»Ÿä¸€çŠ¶æ€ç®¡ç†æ¨¡å¼ï¼ˆ2å¤©ï¼‰

### Day 3ï¼šå®ç°ç»Ÿä¸€çš„Action/Mutationæ¨¡å¼ï¼ˆ8å°æ—¶ï¼‰

#### 1. å®šä¹‰çŠ¶æ€ç®¡ç†è§„èŒƒ
```typescript
// src/store/types/index.ts
export interface ActionContext<S = any> {
  state: S;
  commit: (type: string, payload?: any) => void;
  dispatch: (type: string, payload?: any) => Promise<any>;
  getters: any;
}

export interface StoreModule<S = any> {
  namespaced?: boolean;
  state: S | (() => S);
  getters?: Record<string, (state: S) => any>;
  mutations?: Record<string, (state: S, payload?: any) => void>;
  actions?: Record<string, (context: ActionContext<S>, payload?: any) => Promise<any>>;
}

// ç»Ÿä¸€çš„Actionå“åº”æ ¼å¼
export interface ActionResponse<T = any> {
  success: boolean;
  data?: T;
  error?: Error;
  message?: string;
}

// ç»Ÿä¸€çš„Mutationç±»å‹
export enum MutationType {
  SET_LOADING = 'SET_LOADING',
  SET_ERROR = 'SET_ERROR',
  SET_DATA = 'SET_DATA',
  UPDATE_ITEM = 'UPDATE_ITEM',
  REMOVE_ITEM = 'REMOVE_ITEM',
  RESET = 'RESET'
}
```

#### 2. åˆ›å»ºçŠ¶æ€ç®¡ç†å·¥å…·
```typescript
// src/store/utils/StateManager.ts
export class StateManager {
  /**
   * åˆ›å»ºæ ‡å‡†mutations
   */
  static createMutations<S>(): Record<string, (state: S, payload?: any) => void> {
    return {
      [MutationType.SET_LOADING]: (state: any, loading: boolean) => {
        state.loading = loading;
      },
      
      [MutationType.SET_ERROR]: (state: any, error: Error | null) => {
        state.error = error;
      },
      
      [MutationType.SET_DATA]: (state: any, data: any) => {
        if (Array.isArray(data)) {
          state.items = data;
        } else if (data.rows && data.total !== undefined) {
          state.items = data.rows;
          state.total = data.total;
        } else {
          state.currentItem = data;
        }
      },
      
      [MutationType.UPDATE_ITEM]: (state: any, { id, updates }: any) => {
        const index = state.items?.findIndex((i: any) => i.id === id);
        if (index !== -1) {
          state.items[index] = { ...state.items[index], ...updates };
        }
      },
      
      [MutationType.REMOVE_ITEM]: (state: any, id: any) => {
        state.items = state.items?.filter((i: any) => i.id !== id);
      },
      
      [MutationType.RESET]: (state: any) => {
        Object.keys(state).forEach(key => {
          state[key] = this.getDefaultValue(state[key]);
        });
      }
    };
  }
  
  /**
   * åˆ›å»ºå¼‚æ­¥ActionåŒ…è£…å™¨
   */
  static createAsyncAction<T>(
    action: () => Promise<T>,
    options?: {
      onSuccess?: (data: T) => void;
      onError?: (error: Error) => void;
      showLoading?: boolean;
      showError?: boolean;
    }
  ) {
    return async function(this: any) {
      if (options?.showLoading !== false) {
        this.commit(MutationType.SET_LOADING, true);
      }
      
      try {
        const data = await action();
        
        if (options?.onSuccess) {
          options.onSuccess(data);
        } else {
          this.commit(MutationType.SET_DATA, data);
        }
        
        return {
          success: true,
          data
        };
      } catch (error) {
        const err = error as Error;
        
        this.commit(MutationType.SET_ERROR, err);
        
        if (options?.onError) {
          options.onError(err);
        }
        
        if (options?.showError !== false) {
          ElMessage.error(err.message || 'æ“ä½œå¤±è´¥');
        }
        
        return {
          success: false,
          error: err
        };
      } finally {
        if (options?.showLoading !== false) {
          this.commit(MutationType.SET_LOADING, false);
        }
      }
    };
  }
  
  /**
   * è·å–é»˜è®¤å€¼
   */
  private static getDefaultValue(value: any): any {
    if (Array.isArray(value)) return [];
    if (value === null) return null;
    if (typeof value === 'object') return {};
    if (typeof value === 'number') return 0;
    if (typeof value === 'boolean') return false;
    if (typeof value === 'string') return '';
    return undefined;
  }
}
```

#### 3. çŠ¶æ€å˜æ›´æ—¥å¿—
```typescript
// src/store/plugins/StateLogger.ts
export class StateLogger {
  private history: StateChange[] = [];
  private maxHistory = 100;
  
  install(store: Store) {
    store.$subscribe((mutation, state) => {
      this.logChange(mutation, state);
    });
    
    // å¼€å‘æ¨¡å¼ä¸‹æš´éœ²åˆ°å…¨å±€
    if (import.meta.env.DEV) {
      window.__stateHistory = this.history;
      window.__printStateHistory = () => this.print();
    }
  }
  
  private logChange(mutation: any, state: any) {
    const change: StateChange = {
      timestamp: Date.now(),
      type: mutation.type,
      payload: mutation.payload,
      storeId: mutation.storeId,
      snapshot: this.createSnapshot(state)
    };
    
    this.history.push(change);
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    // å¼€å‘æ¨¡å¼ä¸‹è¾“å‡ºåˆ°æ§åˆ¶å°
    if (import.meta.env.DEV) {
      console.log(
        `%c[State Change] ${mutation.storeId}/${mutation.type}`,
        'color: #9E9E9E; font-weight: bold;',
        mutation.payload
      );
    }
  }
  
  private createSnapshot(state: any): any {
    // åˆ›å»ºçŠ¶æ€å¿«ç…§ï¼ˆé¿å…å¼•ç”¨é—®é¢˜ï¼‰
    return JSON.parse(JSON.stringify(state));
  }
  
  print() {
    console.group('State History');
    this.history.forEach(change => {
      console.log(
        `[${new Date(change.timestamp).toLocaleTimeString()}] ${change.storeId}/${change.type}`,
        change.payload
      );
    });
    console.groupEnd();
  }
  
  getHistory(): StateChange[] {
    return [...this.history];
  }
  
  clear() {
    this.history = [];
  }
  
  // æ—¶é—´æ—…è¡ŒåŠŸèƒ½
  replayTo(index: number, store: Store) {
    if (index < 0 || index >= this.history.length) {
      throw new Error('Invalid history index');
    }
    
    // é‡ç½®åˆ°åˆå§‹çŠ¶æ€
    store.$reset();
    
    // é‡æ”¾åˆ°æŒ‡å®šä½ç½®
    for (let i = 0; i <= index; i++) {
      const change = this.history[i];
      store[change.storeId].$patch(change.snapshot);
    }
  }
}

interface StateChange {
  timestamp: number;
  type: string;
  payload: any;
  storeId: string;
  snapshot: any;
}
```

### Day 4ï¼šçŠ¶æ€æŒä¹…åŒ–ç­–ç•¥ï¼ˆ8å°æ—¶ï¼‰

#### 1. å®ç°æŒä¹…åŒ–æ’ä»¶
```typescript
// src/store/plugins/Persistence.ts
export interface PersistenceOptions {
  key?: string;
  storage?: Storage;
  paths?: string[];
  filter?: (mutation: any) => boolean;
  beforeRestore?: (state: any) => any;
  afterRestore?: (state: any) => void;
}

export class PersistencePlugin {
  private options: PersistenceOptions;
  private storage: Storage;
  
  constructor(options: PersistenceOptions = {}) {
    this.options = options;
    this.storage = options.storage || localStorage;
  }
  
  install(store: Store) {
    const key = this.options.key || `${store.$id}-state`;
    
    // æ¢å¤çŠ¶æ€
    this.restoreState(store, key);
    
    // ç›‘å¬å˜åŒ–
    store.$subscribe((mutation, state) => {
      if (this.shouldPersist(mutation)) {
        this.saveState(key, state);
      }
    });
  }
  
  private restoreState(store: Store, key: string) {
    try {
      const savedState = this.storage.getItem(key);
      
      if (savedState) {
        let state = JSON.parse(savedState);
        
        // åº”ç”¨æ¢å¤å‰é’©å­
        if (this.options.beforeRestore) {
          state = this.options.beforeRestore(state);
        }
        
        // åªæ¢å¤æŒ‡å®šè·¯å¾„
        if (this.options.paths) {
          const filtered = {};
          this.options.paths.forEach(path => {
            set(filtered, path, get(state, path));
          });
          state = filtered;
        }
        
        // æ¢å¤çŠ¶æ€
        store.$patch(state);
        
        // åº”ç”¨æ¢å¤åé’©å­
        if (this.options.afterRestore) {
          this.options.afterRestore(state);
        }
      }
    } catch (error) {
      console.error('Failed to restore state:', error);
    }
  }
  
  private saveState(key: string, state: any) {
    try {
      let toSave = state;
      
      // åªä¿å­˜æŒ‡å®šè·¯å¾„
      if (this.options.paths) {
        toSave = {};
        this.options.paths.forEach(path => {
          set(toSave, path, get(state, path));
        });
      }
      
      this.storage.setItem(key, JSON.stringify(toSave));
    } catch (error) {
      console.error('Failed to save state:', error);
    }
  }
  
  private shouldPersist(mutation: any): boolean {
    // ä½¿ç”¨è‡ªå®šä¹‰è¿‡æ»¤å™¨
    if (this.options.filter) {
      return this.options.filter(mutation);
    }
    
    // é»˜è®¤è¿‡æ»¤æ‰loadingçŠ¶æ€å˜æ›´
    return mutation.type !== MutationType.SET_LOADING;
  }
}

// é…ç½®æŒä¹…åŒ–
export function configurePersistence() {
  const pinia = createPinia();
  
  // ç”¨æˆ·çŠ¶æ€æŒä¹…åŒ–
  pinia.use(({ store }) => {
    if (store.$id === 'user') {
      new PersistencePlugin({
        paths: ['token', 'userInfo'],
        storage: sessionStorage
      }).install(store);
    }
  });
  
  // è®¾ç½®æŒä¹…åŒ–
  pinia.use(({ store }) => {
    if (store.$id === 'settings') {
      new PersistencePlugin({
        storage: localStorage
      }).install(store);
    }
  });
  
  // å¼€å‘æ¨¡å¼ä¸‹æ·»åŠ æ—¥å¿—
  if (import.meta.env.DEV) {
    pinia.use(({ store }) => {
      new StateLogger().install(store);
    });
  }
  
  return pinia;
}
```

#### 2. å®ç°çŠ¶æ€åŒæ­¥
```typescript
// src/store/plugins/StateSync.ts
export class StateSyncPlugin {
  private channel: BroadcastChannel;
  private syncStores: Set<string>;
  
  constructor(options: { stores: string[] }) {
    this.channel = new BroadcastChannel('state-sync');
    this.syncStores = new Set(options.stores);
  }
  
  install(store: Store) {
    if (!this.syncStores.has(store.$id)) {
      return;
    }
    
    // ç›‘å¬æœ¬åœ°å˜åŒ–
    store.$subscribe((mutation, state) => {
      this.broadcast({
        storeId: store.$id,
        mutation,
        state
      });
    });
    
    // ç›‘å¬å…¶ä»–æ ‡ç­¾é¡µå˜åŒ–
    this.channel.onmessage = (event) => {
      if (event.data.storeId === store.$id) {
        store.$patch(event.data.state);
      }
    };
  }
  
  private broadcast(data: any) {
    this.channel.postMessage(data);
  }
  
  destroy() {
    this.channel.close();
  }
}
```

## ğŸ“Š Phase 2 é›†æˆæµ‹è¯•ï¼ˆDay 4ï¼‰

### é›†æˆæµ‹è¯•å¥—ä»¶
```javascript
// src/__tests__/integration/phase2.test.js
describe('Phase 2: Storeå±‚é‡æ„é›†æˆæµ‹è¯•', () => {
  describe('StoreèŒè´£åˆ†ç¦»', () => {
    it('permission storeä¸åº”åŒ…å«è·¯ç”±æ“ä½œ', () => {
      const store = usePermissionStore();
      
      // ä¸åº”æœ‰routerç›¸å…³æ–¹æ³•
      expect(store.addRoute).toBeUndefined();
      expect(store.router).toBeUndefined();
    });
    
    it('æœåŠ¡å±‚åº”è¯¥å¤„ç†ä¸šåŠ¡é€»è¾‘', () => {
      const permissionService = container.get('PermissionService');
      
      expect(permissionService.hasPermission).toBeDefined();
      expect(permissionService.filterRoutes).toBeDefined();
    });
  });
  
  describe('ç»Ÿä¸€çŠ¶æ€ç®¡ç†', () => {
    it('æ‰€æœ‰Storeåº”è¯¥æœ‰ç»Ÿä¸€çš„loading/errorçŠ¶æ€', () => {
      const stores = [
        useTicketStore(),
        useInspectionStore(),
        useMaintenanceStore()
      ];
      
      stores.forEach(store => {
        expect(store.$state).toHaveProperty('loading');
        expect(store.$state).toHaveProperty('error');
      });
    });
    
    it('mutationsåº”è¯¥éµå¾ªç»Ÿä¸€å‘½åè§„èŒƒ', () => {
      const store = useTicketStore();
      
      // è§¦å‘æ ‡å‡†mutation
      store.$patch({ loading: true });
      expect(store.loading).toBe(true);
      
      store.$patch({ error: new Error('test') });
      expect(store.error).toBeInstanceOf(Error);
    });
  });
  
  describe('çŠ¶æ€æŒä¹…åŒ–', () => {
    it('ç”¨æˆ·tokenåº”è¯¥æŒä¹…åŒ–åˆ°sessionStorage', () => {
      const store = useUserStore();
      
      store.token = 'test-token';
      
      // éªŒè¯æŒä¹…åŒ–
      const saved = sessionStorage.getItem('user-state');
      expect(saved).toContain('test-token');
    });
    
    it('è®¾ç½®åº”è¯¥æŒä¹…åŒ–åˆ°localStorage', () => {
      const store = useSettingsStore();
      
      store.theme = 'dark';
      
      const saved = localStorage.getItem('settings-state');
      expect(saved).toContain('dark');
    });
  });
  
  describe('çŠ¶æ€åŒæ­¥', () => {
    it('å¤šæ ‡ç­¾é¡µçŠ¶æ€åº”è¯¥åŒæ­¥', (done) => {
      const store1 = useUserStore();
      const channel = new BroadcastChannel('state-sync');
      
      channel.onmessage = (event) => {
        expect(event.data.storeId).toBe('user');
        expect(event.data.state.userInfo.name).toBe('Test User');
        done();
      };
      
      store1.userInfo = { name: 'Test User' };
    });
  });
});
```

## ğŸ“‹ Phase 2 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] permission.ts ä»£ç è¡Œæ•° < 300è¡Œ
- [ ] æ‰€æœ‰Storeæµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] æ— ç›´æ¥APIè°ƒç”¨
- [ ] åœˆå¤æ‚åº¦ < 10
- [ ] çŠ¶æ€æŒä¹…åŒ–æ­£å¸¸å·¥ä½œ

### åŠŸèƒ½éªŒè¯
- [ ] StoreèŒè´£æ¸…æ™°åˆ†ç¦»
- [ ] ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†æ¨¡å¼
- [ ] çŠ¶æ€å˜æ›´å¯è¿½è¸ª
- [ ] æŒä¹…åŒ–ç­–ç•¥ç”Ÿæ•ˆ
- [ ] å¤šæ ‡ç­¾é¡µåŒæ­¥æ­£å¸¸

### æ€§èƒ½æŒ‡æ ‡
- [ ] Storeæ“ä½œå“åº”æ—¶é—´ < 50ms
- [ ] çŠ¶æ€æŒä¹…åŒ– < 10ms
- [ ] å†…å­˜å ç”¨å‡å°‘ > 20%

## ğŸš€ Phase 2 äº¤ä»˜ç‰©

1. **é‡æ„åçš„Store**
   - permission.ts (200è¡Œ)
   - user.ts (150è¡Œ)
   - ticket.ts (ä½¿ç”¨åŸºç±»)
   - inspection.ts (ä½¿ç”¨åŸºç±»)
   - maintenance.ts (ä½¿ç”¨åŸºç±»)

2. **æœåŠ¡å±‚**
   - PermissionService.ts
   - RouteService.ts
   - MenuService.ts
   - AuthService.ts

3. **å·¥å…·å’Œæ’ä»¶**
   - BaseStore.ts
   - StateManager.ts
   - StateLogger.ts
   - PersistencePlugin.ts
   - StateSyncPlugin.ts

4. **æµ‹è¯•æ–‡ä»¶**
   - å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰Store
   - é›†æˆæµ‹è¯•éªŒè¯èŒè´£åˆ†ç¦»
   - æ€§èƒ½æµ‹è¯•åŸºå‡†

5. **æ–‡æ¡£**
   - STORE-REFACTORING.md
   - STATE-MANAGEMENT.md
   - PERSISTENCE-GUIDE.md

