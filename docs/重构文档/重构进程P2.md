## Phase 2: Store层重构 - 详细实施方案（4天）

### 📅 时间安排
- **开发者A负责**: Milestone 2.1 Store职责分离
- **开发者B负责**: Milestone 2.2 统一状态管理模式
- **Day 4**: 协同测试与集成

---

## Milestone 2.1: Store职责分离（2天）

### Day 1 上午：分析现有Store问题（4小时）

#### 1. 现有Store问题扫描
```javascript
// scripts/analyze-store.js
const fs = require('fs');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;

class StoreAnalyzer {
  constructor() {
    this.issues = {
      mixedConcerns: [],      // 混合关注点
      directApiCalls: [],     // 直接API调用
      businessLogic: [],      // 业务逻辑
      crossModuleDeps: [],    // 跨模块依赖
      complexGetters: [],     // 复杂计算属性
      largeState: []          // 过大的状态
    };
  }
  
  analyzeFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf8');
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript']
    });
    
    traverse(ast, {
      // 检测直接API调用
      ImportDeclaration: (path) => {
        if (path.node.source.value.includes('/api/')) {
          this.issues.directApiCalls.push({
            file: filePath,
            line: path.node.loc.start.line,
            import: path.node.source.value
          });
        }
      },
      
      // 检测复杂逻辑
      FunctionDeclaration: (path) => {
        const lineCount = path.node.loc.end.line - path.node.loc.start.line;
        if (lineCount > 20) {
          this.issues.businessLogic.push({
            file: filePath,
            function: path.node.id?.name,
            lines: lineCount
          });
        }
      }
    });
  }
  
  generateReport() {
    console.log('=== Store层问题分析报告 ===\n');
    
    console.log(`直接API调用: ${this.issues.directApiCalls.length}处`);
    console.log(`复杂业务逻辑: ${this.issues.businessLogic.length}处`);
    console.log(`跨模块依赖: ${this.issues.crossModuleDeps.length}处`);
    
    // 生成详细报告
    fs.writeFileSync(
      'store-analysis-report.json',
      JSON.stringify(this.issues, null, 2)
    );
  }
}

// 执行分析
const analyzer = new StoreAnalyzer();
const storeFiles = glob.sync('src/store/modules/*.js');
storeFiles.forEach(file => analyzer.analyzeFile(file));
analyzer.generateReport();
```

#### 2. 识别Store职责边界
```typescript
// docs/store-responsibilities.md
/**
 * Store职责矩阵
 * 
 * ✅ Store应该负责的:
 * - 状态存储和管理
 * - 状态的同步更新(mutations)
 * - 调用服务层获取数据(actions)
 * - 简单的派生状态(getters)
 * - 状态持久化
 * 
 * ❌ Store不应该负责的:
 * - 复杂的业务逻辑计算
 * - 直接调用API
 * - 数据转换和格式化
 * - 权限判断逻辑
 * - 路由控制
 */

// 问题示例 - permission.ts (1300行)
const permissionStore = {
  state: {
    routes: [],
    addRoutes: [],
    permissions: []
  },
  
  actions: {
    // ❌ 问题1: 混合了路由生成、权限判断、菜单构建
    generateRoutes({ commit }, roles) {
      // 200行的复杂逻辑...
      // 包含递归、过滤、转换、排序等
    },
    
    // ❌ 问题2: 直接操作路由
    addDynamicRoutes() {
      // 直接调用router.addRoute
    },
    
    // ❌ 问题3: 包含业务逻辑
    checkPermission(route, roles) {
      // 复杂的权限判断逻辑
    }
  }
}
```

### Day 1 下午：拆分permission.ts（4小时）

#### 1. 创建独立的服务层
```typescript
// src/services/PermissionService.ts
export class PermissionService {
  private permissionCache = new Map<string, boolean>();
  
  /**
   * 检查用户是否有权限
   */
  hasPermission(permission: string, userPermissions: string[]): boolean {
    const cacheKey = `${permission}:${userPermissions.join(',')}`;
    
    if (this.permissionCache.has(cacheKey)) {
      return this.permissionCache.get(cacheKey)!;
    }
    
    const hasPermi = userPermissions.includes(permission) || 
                     userPermissions.includes('*:*:*');
    
    this.permissionCache.set(cacheKey, hasPermi);
    return hasPermi;
  }
  
  /**
   * 检查角色
   */
  hasRole(role: string, userRoles: string[]): boolean {
    return userRoles.includes(role) || userRoles.includes('admin');
  }
  
  /**
   * 过滤有权限的路由
   */
  filterRoutes(routes: RouteConfig[], permissions: string[]): RouteConfig[] {
    return routes.filter(route => {
      if (route.meta?.permissions) {
        return route.meta.permissions.some(p => 
          this.hasPermission(p, permissions)
        );
      }
      return true;
    }).map(route => {
      if (route.children) {
        return {
          ...route,
          children: this.filterRoutes(route.children, permissions)
        };
      }
      return route;
    });
  }
}

// src/services/RouteService.ts
export class RouteService {
  /**
   * 生成动态路由
   */
  generateDynamicRoutes(
    asyncRoutes: RouteConfig[],
    permissions: string[]
  ): RouteConfig[] {
    const permissionService = container.get('PermissionService');
    
    // 1. 过滤权限
    const accessibleRoutes = permissionService.filterRoutes(
      asyncRoutes,
      permissions
    );
    
    // 2. 处理路由元数据
    const processedRoutes = this.processRouteMeta(accessibleRoutes);
    
    // 3. 排序路由
    const sortedRoutes = this.sortRoutes(processedRoutes);
    
    return sortedRoutes;
  }
  
  /**
   * 处理路由元数据
   */
  private processRouteMeta(routes: RouteConfig[]): RouteConfig[] {
    return routes.map(route => ({
      ...route,
      meta: {
        ...route.meta,
        title: route.meta?.title || route.name,
        icon: route.meta?.icon || 'default-icon',
        hidden: route.meta?.hidden || false
      }
    }));
  }
  
  /**
   * 路由排序
   */
  private sortRoutes(routes: RouteConfig[]): RouteConfig[] {
    return routes.sort((a, b) => {
      const orderA = a.meta?.order || 999;
      const orderB = b.meta?.order || 999;
      return orderA - orderB;
    });
  }
}

// src/services/MenuService.ts
export class MenuService {
  /**
   * 从路由生成菜单
   */
  generateMenuFromRoutes(routes: RouteConfig[]): MenuItem[] {
    return routes
      .filter(route => !route.meta?.hidden)
      .map(route => this.routeToMenuItem(route));
  }
  
  private routeToMenuItem(route: RouteConfig): MenuItem {
    const menuItem: MenuItem = {
      path: route.path,
      name: route.name,
      title: route.meta?.title || route.name,
      icon: route.meta?.icon,
      component: route.component
    };
    
    if (route.children?.length) {
      menuItem.children = route.children
        .filter(child => !child.meta?.hidden)
        .map(child => this.routeToMenuItem(child));
    }
    
    return menuItem;
  }
}
```

#### 2. 重构permission store
```typescript
// src/store/modules/permission.ts (重构后，约200行)
import { defineStore } from 'pinia';
import { RouteService, MenuService } from '@/services';

export const usePermissionStore = defineStore('permission', {
  state: () => ({
    routes: [] as RouteConfig[],
    addRoutes: [] as RouteConfig[],
    permissions: [] as string[],
    menus: [] as MenuItem[]
  }),
  
  getters: {
    // 简单的派生状态
    hasRoutes: (state) => state.routes.length > 0,
    menuList: (state) => state.menus,
    permissionList: (state) => state.permissions
  },
  
  actions: {
    /**
     * 设置权限
     */
    setPermissions(permissions: string[]) {
      this.permissions = permissions;
    },
    
    /**
     * 生成路由（委托给服务层）
     */
    async generateRoutes() {
      const routeService = container.get<RouteService>('RouteService');
      const menuService = container.get<MenuService>('MenuService');
      
      // 1. 生成可访问的路由
      const accessibleRoutes = routeService.generateDynamicRoutes(
        asyncRoutes,
        this.permissions
      );
      
      // 2. 生成菜单
      const menus = menuService.generateMenuFromRoutes(accessibleRoutes);
      
      // 3. 更新状态
      this.addRoutes = accessibleRoutes;
      this.routes = constantRoutes.concat(accessibleRoutes);
      this.menus = menus;
      
      return accessibleRoutes;
    },
    
    /**
     * 清理权限
     */
    resetPermission() {
      this.$reset();
    }
  }
});
```

### Day 2 上午：创建业务Store基类（4小时）

#### 1. 定义Store基类
```typescript
// src/store/base/BaseStore.ts
import { defineStore } from 'pinia';

export interface BaseState {
  loading: boolean;
  error: Error | null;
  initialized: boolean;
}

export interface CrudState<T> extends BaseState {
  items: T[];
  currentItem: T | null;
  total: number;
  query: Record<string, any>;
}

/**
 * 创建CRUD Store的工厂函数
 */
export function createCrudStore<T extends { id: number | string }>(
  name: string,
  service: any
) {
  return defineStore(`${name}`, {
    state: (): CrudState<T> => ({
      loading: false,
      error: null,
      initialized: false,
      items: [],
      currentItem: null,
      total: 0,
      query: {
        page: 1,
        pageSize: 20
      }
    }),
    
    getters: {
      // 通用getters
      isEmpty: (state) => state.items.length === 0,
      hasError: (state) => state.error !== null,
      isLoading: (state) => state.loading,
      
      // 分页相关
      currentPage: (state) => state.query.page || 1,
      pageSize: (state) => state.query.pageSize || 20,
      totalPages: (state) => Math.ceil(state.total / (state.query.pageSize || 20)),
      
      // 查找相关
      findById: (state) => (id: number | string) => 
        state.items.find(item => item.id === id),
      
      // 过滤相关
      filteredItems: (state) => (filter: (item: T) => boolean) =>
        state.items.filter(filter)
    },
    
    actions: {
      /**
       * 初始化
       */
      async initialize() {
        if (this.initialized) return;
        
        await this.fetchList();
        this.initialized = true;
      },
      
      /**
       * 获取列表
       */
      async fetchList(query?: Record<string, any>) {
        this.loading = true;
        this.error = null;
        
        try {
          const mergedQuery = { ...this.query, ...query };
          const response = await service.list(mergedQuery);
          
          this.items = response.rows;
          this.total = response.total;
          this.query = mergedQuery;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 获取详情
       */
      async fetchById(id: number | string) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.get(id);
          this.currentItem = item;
          
          // 更新列表中的项
          const index = this.items.findIndex(i => i.id === id);
          if (index !== -1) {
            this.items[index] = item;
          }
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 创建
       */
      async create(data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.create(data);
          
          // 添加到列表
          this.items.unshift(item);
          this.total += 1;
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 更新
       */
      async update(id: number | string, data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          const item = await service.update(id, data);
          
          // 更新列表
          const index = this.items.findIndex(i => i.id === id);
          if (index !== -1) {
            this.items[index] = item;
          }
          
          // 更新当前项
          if (this.currentItem?.id === id) {
            this.currentItem = item;
          }
          
          return item;
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 删除
       */
      async remove(id: number | string) {
        this.loading = true;
        this.error = null;
        
        try {
          await service.remove(id);
          
          // 从列表移除
          this.items = this.items.filter(i => i.id !== id);
          this.total -= 1;
          
          // 清理当前项
          if (this.currentItem?.id === id) {
            this.currentItem = null;
          }
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 批量操作
       */
      async batchUpdate(ids: (number | string)[], data: Partial<T>) {
        this.loading = true;
        this.error = null;
        
        try {
          await service.batchUpdate(ids, data);
          
          // 更新本地状态
          this.items = this.items.map(item => {
            if (ids.includes(item.id)) {
              return { ...item, ...data };
            }
            return item;
          });
        } catch (error) {
          this.error = error as Error;
          throw error;
        } finally {
          this.loading = false;
        }
      },
      
      /**
       * 重置查询
       */
      resetQuery() {
        this.query = {
          page: 1,
          pageSize: 20
        };
      },
      
      /**
       * 清理Store
       */
      reset() {
        this.$reset();
      }
    }
  });
}
```

#### 2. 创建业务Store
```typescript
// src/store/modules/ticket.ts (使用基类)
import { createCrudStore } from '@/store/base/BaseStore';
import { TicketService } from '@/services/TicketService';
import type { Ticket } from '@/types/api/ticket';

// 基础CRUD功能
const baseTicketStore = createCrudStore<Ticket>('ticket', TicketService);

// 扩展业务特定功能
export const useTicketStore = defineStore('ticket', {
  ...baseTicketStore,
  
  state: () => ({
    ...baseTicketStore.state(),
    // 业务特定状态
    statistics: {
      todayNew: 0,
      todayCompleted: 0,
      nearDue: 0,
      overdue: 0
    },
    escalationQueue: [] as Ticket[]
  }),
  
  getters: {
    ...baseTicketStore.getters,
    // 业务特定getters
    pendingTickets: (state) => 
      state.items.filter(t => t.status === 'pending'),
    
    myTickets: (state) => (userId: string) =>
      state.items.filter(t => t.assigneeId === userId),
    
    overdueTickets: (state) =>
      state.items.filter(t => {
        if (!t.deadline) return false;
        return new Date(t.deadline) < new Date();
      }),
    
    ticketsByPriority: (state) => {
      const grouped = {} as Record<string, Ticket[]>;
      state.items.forEach(ticket => {
        if (!grouped[ticket.priority]) {
          grouped[ticket.priority] = [];
        }
        grouped[ticket.priority].push(ticket);
      });
      return grouped;
    }
  },
  
  actions: {
    ...baseTicketStore.actions,
    
    /**
     * 批量分配工单
     */
    async batchAssign(ticketIds: string[], assigneeId: string) {
      this.loading = true;
      
      try {
        await TicketService.batchAssign(ticketIds, assigneeId);
        
        // 更新本地状态
        this.items = this.items.map(ticket => {
          if (ticketIds.includes(ticket.id)) {
            return {
              ...ticket,
              assigneeId,
              status: 'assigned'
            };
          }
          return ticket;
        });
        
        // 发布事件
        eventBus.emit('tickets.assigned', { ticketIds, assigneeId });
      } catch (error) {
        this.error = error as Error;
        throw error;
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 获取统计数据
     */
    async fetchStatistics() {
      try {
        const stats = await TicketService.getStatistics();
        this.statistics = stats;
      } catch (error) {
        console.error('Failed to fetch statistics:', error);
      }
    },
    
    /**
     * 工单升级
     */
    async escalateTicket(ticketId: string) {
      const ticket = this.findById(ticketId);
      if (!ticket) return;
      
      const newPriority = this.getNextPriority(ticket.priority);
      await this.update(ticketId, { priority: newPriority });
      
      // 记录升级
      this.escalationQueue.push({
        ...ticket,
        priority: newPriority
      });
    },
    
    /**
     * 获取下一优先级
     */
    private getNextPriority(current: string): string {
      const priorities = ['low', 'medium', 'high', 'urgent'];
      const currentIndex = priorities.indexOf(current);
      
      if (currentIndex === -1 || currentIndex === priorities.length - 1) {
        return current;
      }
      
      return priorities[currentIndex + 1];
    }
  }
});
```

### Day 2 下午：拆分其他复杂Store（4小时）

#### 1. 拆分user store
```typescript
// src/services/AuthService.ts
export class AuthService {
  private tokenKey = 'Admin-Token';
  
  /**
   * 登录
   */
  async login(credentials: LoginCredentials): Promise<LoginResult> {
    const response = await api.login(credentials);
    
    if (response.token) {
      this.setToken(response.token);
    }
    
    return response;
  }
  
  /**
   * 获取用户信息
   */
  async getUserInfo(): Promise<UserInfo> {
    const token = this.getToken();
    if (!token) {
      throw new Error('No token found');
    }
    
    return await api.getUserInfo();
  }
  
  /**
   * Token管理
   */
  getToken(): string | null {
    return localStorage.getItem(this.tokenKey);
  }
  
  setToken(token: string): void {
    localStorage.setItem(this.tokenKey, token);
  }
  
  removeToken(): void {
    localStorage.removeItem(this.tokenKey);
  }
  
  /**
   * 刷新Token
   */
  async refreshToken(): Promise<string> {
    const response = await api.refreshToken();
    this.setToken(response.token);
    return response.token;
  }
}

// src/store/modules/user.ts (简化后)
export const useUserStore = defineStore('user', {
  state: () => ({
    token: '',
    userInfo: null as UserInfo | null,
    roles: [] as string[],
    permissions: [] as string[]
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token,
    userId: (state) => state.userInfo?.userId,
    userName: (state) => state.userInfo?.userName,
    avatar: (state) => state.userInfo?.avatar
  },
  
  actions: {
    /**
     * 登录
     */
    async login(credentials: LoginCredentials) {
      const authService = container.get<AuthService>('AuthService');
      
      const result = await authService.login(credentials);
      this.token = result.token;
      
      // 获取用户信息
      await this.getUserInfo();
    },
    
    /**
     * 获取用户信息
     */
    async getUserInfo() {
      const authService = container.get<AuthService>('AuthService');
      
      const userInfo = await authService.getUserInfo();
      
      this.userInfo = userInfo;
      this.roles = userInfo.roles;
      this.permissions = userInfo.permissions;
    },
    
    /**
     * 登出
     */
    async logout() {
      const authService = container.get<AuthService>('AuthService');
      
      // 清理token
      authService.removeToken();
      
      // 重置状态
      this.$reset();
      
      // 清理其他Store
      const permissionStore = usePermissionStore();
      permissionStore.reset();
    },
    
    /**
     * 重置Token
     */
    resetToken() {
      const authService = container.get<AuthService>('AuthService');
      authService.removeToken();
      this.token = '';
    }
  }
});
```

---

## Milestone 2.2: 统一状态管理模式（2天）

### Day 3：实现统一的Action/Mutation模式（8小时）

#### 1. 定义状态管理规范
```typescript
// src/store/types/index.ts
export interface ActionContext<S = any> {
  state: S;
  commit: (type: string, payload?: any) => void;
  dispatch: (type: string, payload?: any) => Promise<any>;
  getters: any;
}

export interface StoreModule<S = any> {
  namespaced?: boolean;
  state: S | (() => S);
  getters?: Record<string, (state: S) => any>;
  mutations?: Record<string, (state: S, payload?: any) => void>;
  actions?: Record<string, (context: ActionContext<S>, payload?: any) => Promise<any>>;
}

// 统一的Action响应格式
export interface ActionResponse<T = any> {
  success: boolean;
  data?: T;
  error?: Error;
  message?: string;
}

// 统一的Mutation类型
export enum MutationType {
  SET_LOADING = 'SET_LOADING',
  SET_ERROR = 'SET_ERROR',
  SET_DATA = 'SET_DATA',
  UPDATE_ITEM = 'UPDATE_ITEM',
  REMOVE_ITEM = 'REMOVE_ITEM',
  RESET = 'RESET'
}
```

#### 2. 创建状态管理工具
```typescript
// src/store/utils/StateManager.ts
export class StateManager {
  /**
   * 创建标准mutations
   */
  static createMutations<S>(): Record<string, (state: S, payload?: any) => void> {
    return {
      [MutationType.SET_LOADING]: (state: any, loading: boolean) => {
        state.loading = loading;
      },
      
      [MutationType.SET_ERROR]: (state: any, error: Error | null) => {
        state.error = error;
      },
      
      [MutationType.SET_DATA]: (state: any, data: any) => {
        if (Array.isArray(data)) {
          state.items = data;
        } else if (data.rows && data.total !== undefined) {
          state.items = data.rows;
          state.total = data.total;
        } else {
          state.currentItem = data;
        }
      },
      
      [MutationType.UPDATE_ITEM]: (state: any, { id, updates }: any) => {
        const index = state.items?.findIndex((i: any) => i.id === id);
        if (index !== -1) {
          state.items[index] = { ...state.items[index], ...updates };
        }
      },
      
      [MutationType.REMOVE_ITEM]: (state: any, id: any) => {
        state.items = state.items?.filter((i: any) => i.id !== id);
      },
      
      [MutationType.RESET]: (state: any) => {
        Object.keys(state).forEach(key => {
          state[key] = this.getDefaultValue(state[key]);
        });
      }
    };
  }
  
  /**
   * 创建异步Action包装器
   */
  static createAsyncAction<T>(
    action: () => Promise<T>,
    options?: {
      onSuccess?: (data: T) => void;
      onError?: (error: Error) => void;
      showLoading?: boolean;
      showError?: boolean;
    }
  ) {
    return async function(this: any) {
      if (options?.showLoading !== false) {
        this.commit(MutationType.SET_LOADING, true);
      }
      
      try {
        const data = await action();
        
        if (options?.onSuccess) {
          options.onSuccess(data);
        } else {
          this.commit(MutationType.SET_DATA, data);
        }
        
        return {
          success: true,
          data
        };
      } catch (error) {
        const err = error as Error;
        
        this.commit(MutationType.SET_ERROR, err);
        
        if (options?.onError) {
          options.onError(err);
        }
        
        if (options?.showError !== false) {
          ElMessage.error(err.message || '操作失败');
        }
        
        return {
          success: false,
          error: err
        };
      } finally {
        if (options?.showLoading !== false) {
          this.commit(MutationType.SET_LOADING, false);
        }
      }
    };
  }
  
  /**
   * 获取默认值
   */
  private static getDefaultValue(value: any): any {
    if (Array.isArray(value)) return [];
    if (value === null) return null;
    if (typeof value === 'object') return {};
    if (typeof value === 'number') return 0;
    if (typeof value === 'boolean') return false;
    if (typeof value === 'string') return '';
    return undefined;
  }
}
```

#### 3. 状态变更日志
```typescript
// src/store/plugins/StateLogger.ts
export class StateLogger {
  private history: StateChange[] = [];
  private maxHistory = 100;
  
  install(store: Store) {
    store.$subscribe((mutation, state) => {
      this.logChange(mutation, state);
    });
    
    // 开发模式下暴露到全局
    if (import.meta.env.DEV) {
      window.__stateHistory = this.history;
      window.__printStateHistory = () => this.print();
    }
  }
  
  private logChange(mutation: any, state: any) {
    const change: StateChange = {
      timestamp: Date.now(),
      type: mutation.type,
      payload: mutation.payload,
      storeId: mutation.storeId,
      snapshot: this.createSnapshot(state)
    };
    
    this.history.push(change);
    
    // 限制历史记录数量
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    // 开发模式下输出到控制台
    if (import.meta.env.DEV) {
      console.log(
        `%c[State Change] ${mutation.storeId}/${mutation.type}`,
        'color: #9E9E9E; font-weight: bold;',
        mutation.payload
      );
    }
  }
  
  private createSnapshot(state: any): any {
    // 创建状态快照（避免引用问题）
    return JSON.parse(JSON.stringify(state));
  }
  
  print() {
    console.group('State History');
    this.history.forEach(change => {
      console.log(
        `[${new Date(change.timestamp).toLocaleTimeString()}] ${change.storeId}/${change.type}`,
        change.payload
      );
    });
    console.groupEnd();
  }
  
  getHistory(): StateChange[] {
    return [...this.history];
  }
  
  clear() {
    this.history = [];
  }
  
  // 时间旅行功能
  replayTo(index: number, store: Store) {
    if (index < 0 || index >= this.history.length) {
      throw new Error('Invalid history index');
    }
    
    // 重置到初始状态
    store.$reset();
    
    // 重放到指定位置
    for (let i = 0; i <= index; i++) {
      const change = this.history[i];
      store[change.storeId].$patch(change.snapshot);
    }
  }
}

interface StateChange {
  timestamp: number;
  type: string;
  payload: any;
  storeId: string;
  snapshot: any;
}
```

### Day 4：状态持久化策略（8小时）

#### 1. 实现持久化插件
```typescript
// src/store/plugins/Persistence.ts
export interface PersistenceOptions {
  key?: string;
  storage?: Storage;
  paths?: string[];
  filter?: (mutation: any) => boolean;
  beforeRestore?: (state: any) => any;
  afterRestore?: (state: any) => void;
}

export class PersistencePlugin {
  private options: PersistenceOptions;
  private storage: Storage;
  
  constructor(options: PersistenceOptions = {}) {
    this.options = options;
    this.storage = options.storage || localStorage;
  }
  
  install(store: Store) {
    const key = this.options.key || `${store.$id}-state`;
    
    // 恢复状态
    this.restoreState(store, key);
    
    // 监听变化
    store.$subscribe((mutation, state) => {
      if (this.shouldPersist(mutation)) {
        this.saveState(key, state);
      }
    });
  }
  
  private restoreState(store: Store, key: string) {
    try {
      const savedState = this.storage.getItem(key);
      
      if (savedState) {
        let state = JSON.parse(savedState);
        
        // 应用恢复前钩子
        if (this.options.beforeRestore) {
          state = this.options.beforeRestore(state);
        }
        
        // 只恢复指定路径
        if (this.options.paths) {
          const filtered = {};
          this.options.paths.forEach(path => {
            set(filtered, path, get(state, path));
          });
          state = filtered;
        }
        
        // 恢复状态
        store.$patch(state);
        
        // 应用恢复后钩子
        if (this.options.afterRestore) {
          this.options.afterRestore(state);
        }
      }
    } catch (error) {
      console.error('Failed to restore state:', error);
    }
  }
  
  private saveState(key: string, state: any) {
    try {
      let toSave = state;
      
      // 只保存指定路径
      if (this.options.paths) {
        toSave = {};
        this.options.paths.forEach(path => {
          set(toSave, path, get(state, path));
        });
      }
      
      this.storage.setItem(key, JSON.stringify(toSave));
    } catch (error) {
      console.error('Failed to save state:', error);
    }
  }
  
  private shouldPersist(mutation: any): boolean {
    // 使用自定义过滤器
    if (this.options.filter) {
      return this.options.filter(mutation);
    }
    
    // 默认过滤掉loading状态变更
    return mutation.type !== MutationType.SET_LOADING;
  }
}

// 配置持久化
export function configurePersistence() {
  const pinia = createPinia();
  
  // 用户状态持久化
  pinia.use(({ store }) => {
    if (store.$id === 'user') {
      new PersistencePlugin({
        paths: ['token', 'userInfo'],
        storage: sessionStorage
      }).install(store);
    }
  });
  
  // 设置持久化
  pinia.use(({ store }) => {
    if (store.$id === 'settings') {
      new PersistencePlugin({
        storage: localStorage
      }).install(store);
    }
  });
  
  // 开发模式下添加日志
  if (import.meta.env.DEV) {
    pinia.use(({ store }) => {
      new StateLogger().install(store);
    });
  }
  
  return pinia;
}
```

#### 2. 实现状态同步
```typescript
// src/store/plugins/StateSync.ts
export class StateSyncPlugin {
  private channel: BroadcastChannel;
  private syncStores: Set<string>;
  
  constructor(options: { stores: string[] }) {
    this.channel = new BroadcastChannel('state-sync');
    this.syncStores = new Set(options.stores);
  }
  
  install(store: Store) {
    if (!this.syncStores.has(store.$id)) {
      return;
    }
    
    // 监听本地变化
    store.$subscribe((mutation, state) => {
      this.broadcast({
        storeId: store.$id,
        mutation,
        state
      });
    });
    
    // 监听其他标签页变化
    this.channel.onmessage = (event) => {
      if (event.data.storeId === store.$id) {
        store.$patch(event.data.state);
      }
    };
  }
  
  private broadcast(data: any) {
    this.channel.postMessage(data);
  }
  
  destroy() {
    this.channel.close();
  }
}
```

## 📊 Phase 2 集成测试（Day 4）

### 集成测试套件
```javascript
// src/__tests__/integration/phase2.test.js
describe('Phase 2: Store层重构集成测试', () => {
  describe('Store职责分离', () => {
    it('permission store不应包含路由操作', () => {
      const store = usePermissionStore();
      
      // 不应有router相关方法
      expect(store.addRoute).toBeUndefined();
      expect(store.router).toBeUndefined();
    });
    
    it('服务层应该处理业务逻辑', () => {
      const permissionService = container.get('PermissionService');
      
      expect(permissionService.hasPermission).toBeDefined();
      expect(permissionService.filterRoutes).toBeDefined();
    });
  });
  
  describe('统一状态管理', () => {
    it('所有Store应该有统一的loading/error状态', () => {
      const stores = [
        useTicketStore(),
        useInspectionStore(),
        useMaintenanceStore()
      ];
      
      stores.forEach(store => {
        expect(store.$state).toHaveProperty('loading');
        expect(store.$state).toHaveProperty('error');
      });
    });
    
    it('mutations应该遵循统一命名规范', () => {
      const store = useTicketStore();
      
      // 触发标准mutation
      store.$patch({ loading: true });
      expect(store.loading).toBe(true);
      
      store.$patch({ error: new Error('test') });
      expect(store.error).toBeInstanceOf(Error);
    });
  });
  
  describe('状态持久化', () => {
    it('用户token应该持久化到sessionStorage', () => {
      const store = useUserStore();
      
      store.token = 'test-token';
      
      // 验证持久化
      const saved = sessionStorage.getItem('user-state');
      expect(saved).toContain('test-token');
    });
    
    it('设置应该持久化到localStorage', () => {
      const store = useSettingsStore();
      
      store.theme = 'dark';
      
      const saved = localStorage.getItem('settings-state');
      expect(saved).toContain('dark');
    });
  });
  
  describe('状态同步', () => {
    it('多标签页状态应该同步', (done) => {
      const store1 = useUserStore();
      const channel = new BroadcastChannel('state-sync');
      
      channel.onmessage = (event) => {
        expect(event.data.storeId).toBe('user');
        expect(event.data.state.userInfo.name).toBe('Test User');
        done();
      };
      
      store1.userInfo = { name: 'Test User' };
    });
  });
});
```

## 📋 Phase 2 完成标准检查清单

### 技术指标
- [ ] permission.ts 代码行数 < 300行
- [ ] 所有Store测试覆盖率 > 85%
- [ ] 无直接API调用
- [ ] 圈复杂度 < 10
- [ ] 状态持久化正常工作

### 功能验证
- [ ] Store职责清晰分离
- [ ] 统一的状态管理模式
- [ ] 状态变更可追踪
- [ ] 持久化策略生效
- [ ] 多标签页同步正常

### 性能指标
- [ ] Store操作响应时间 < 50ms
- [ ] 状态持久化 < 10ms
- [ ] 内存占用减少 > 20%

## 🚀 Phase 2 交付物

1. **重构后的Store**
   - permission.ts (200行)
   - user.ts (150行)
   - ticket.ts (使用基类)
   - inspection.ts (使用基类)
   - maintenance.ts (使用基类)

2. **服务层**
   - PermissionService.ts
   - RouteService.ts
   - MenuService.ts
   - AuthService.ts

3. **工具和插件**
   - BaseStore.ts
   - StateManager.ts
   - StateLogger.ts
   - PersistencePlugin.ts
   - StateSyncPlugin.ts

4. **测试文件**
   - 单元测试覆盖所有Store
   - 集成测试验证职责分离
   - 性能测试基准

5. **文档**
   - STORE-REFACTORING.md
   - STATE-MANAGEMENT.md
   - PERSISTENCE-GUIDE.md

