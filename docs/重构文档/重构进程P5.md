## Phase 5: 核心业务模块重构 - 维保（5天）

### 📅 时间安排
- **Day 1-2**: Milestone 5.1 维保领域建模
- **Day 3-4**: Milestone 5.2 审批流程重构
- **Day 5**: Milestone 5.3 提醒机制独立

---

## Milestone 5.1: 维保领域建模（2天）

### Day 1: 维保计划实体设计（8小时）

#### 1. 维保计划聚合根
```typescript
// src/domain/maintenance/entities/MaintenancePlan.ts
export class MaintenancePlan extends AggregateRoot {
  private _id: string
  private _planNo: string
  private _title: string
  private _floor: Floor
  private _equipmentIds: string[]
  private _responsibleId: string
  private _plannedStartDate: Date
  private _plannedEndDate: Date
  private _approvalStatus: ApprovalStatus
  private _executionStatus: ExecutionStatus
  private _approvalHistory: ApprovalRecord[]
  private _executionHistory: ExecutionRecord[]
  private _attachments: Attachment[]
  private _reminders: Reminder[]
  private _version: number
  
  constructor(props: MaintenancePlanProps) {
    super()
    this.validate(props)
    this._id = props.id || generateId()
    this._planNo = props.planNo || this.generatePlanNo()
    this._title = props.title
    this._floor = props.floor
    this._equipmentIds = props.equipmentIds || []
    this._responsibleId = props.responsibleId
    this._plannedStartDate = props.plannedStartDate
    this._plannedEndDate = props.plannedEndDate
    this._approvalStatus = ApprovalStatus.DRAFT
    this._executionStatus = ExecutionStatus.IDLE
    this._approvalHistory = []
    this._executionHistory = []
    this._attachments = []
    this._reminders = []
    this._version = 1
    
    // 发布领域事件
    this.addDomainEvent(new MaintenancePlanCreated({
      planId: this._id,
      title: this._title,
      responsibleId: this._responsibleId,
      plannedStartDate: this._plannedStartDate
    }))
  }
  
  // 提交审批
  submitForApproval(submitterId: string): void {
    if (this._approvalStatus !== ApprovalStatus.DRAFT) {
      throw new DomainError('只能提交草稿状态的计划')
    }
    
    this._approvalStatus = ApprovalStatus.PENDING
    
    const record = new ApprovalRecord({
      action: ApprovalAction.SUBMIT,
      operatorId: submitterId,
      timestamp: new Date(),
      comment: '提交审批'
    })
    
    this._approvalHistory.push(record)
    
    this.addDomainEvent(new MaintenancePlanSubmitted({
      planId: this._id,
      submitterId,
      timestamp: new Date()
    }))
  }
  
  // 审批通过
  approve(approverId: string, comment?: string): void {
    if (this._approvalStatus !== ApprovalStatus.PENDING) {
      throw new DomainError('只能审批待审批的计划')
    }
    
    this._approvalStatus = ApprovalStatus.APPROVED
    
    const record = new ApprovalRecord({
      action: ApprovalAction.APPROVE,
      operatorId: approverId,
      timestamp: new Date(),
      comment: comment || '审批通过'
    })
    
    this._approvalHistory.push(record)
    
    // 自动创建提醒
    this.createReminders()
    
    this.addDomainEvent(new MaintenancePlanApproved({
      planId: this._id,
      approverId,
      timestamp: new Date()
    }))
  }
  
  // 审批拒绝
  reject(rejectorId: string, reason: string): void {
    if (this._approvalStatus !== ApprovalStatus.PENDING) {
      throw new DomainError('只能拒绝待审批的计划')
    }
    
    if (!reason || reason.trim().length === 0) {
      throw new ValidationError('拒绝原因不能为空')
    }
    
    this._approvalStatus = ApprovalStatus.REJECTED
    
    const record = new ApprovalRecord({
      action: ApprovalAction.REJECT,
      operatorId: rejectorId,
      timestamp: new Date(),
      comment: reason
    })
    
    this._approvalHistory.push(record)
    
    this.addDomainEvent(new MaintenancePlanRejected({
      planId: this._id,
      rejectorId,
      reason,
      timestamp: new Date()
    }))
  }
  
  // 开始执行
  startExecution(executorId: string): void {
    if (this._approvalStatus !== ApprovalStatus.APPROVED) {
      throw new DomainError('只能执行已批准的计划')
    }
    
    if (this._executionStatus !== ExecutionStatus.IDLE) {
      throw new DomainError('计划已在执行中或已完成')
    }
    
    // 检查是否到了计划开始时间
    const now = new Date()
    if (now < this._plannedStartDate) {
      throw new DomainError('尚未到计划开始时间')
    }
    
    this._executionStatus = ExecutionStatus.EXECUTING
    
    const record = new ExecutionRecord({
      action: ExecutionAction.START,
      operatorId: executorId,
      timestamp: now
    })
    
    this._executionHistory.push(record)
    
    // 取消未发送的提醒
    this.cancelPendingReminders()
    
    this.addDomainEvent(new MaintenanceExecutionStarted({
      planId: this._id,
      executorId,
      startTime: now
    }))
  }
  
  // 完成执行
  completeExecution(
    executorId: string,
    result: string,
    attachments?: Attachment[]
  ): void {
    if (this._executionStatus !== ExecutionStatus.EXECUTING) {
      throw new DomainError('只能完成执行中的计划')
    }
    
    if (!result || result.trim().length === 0) {
      throw new ValidationError('执行结果不能为空')
    }
    
    this._executionStatus = ExecutionStatus.COMPLETED
    
    const record = new ExecutionRecord({
      action: ExecutionAction.COMPLETE,
      operatorId: executorId,
      timestamp: new Date(),
      result,
      attachments
    })
    
    this._executionHistory.push(record)
    
    if (attachments) {
      this._attachments.push(...attachments)
    }
    
    this.addDomainEvent(new MaintenanceExecutionCompleted({
      planId: this._id,
      executorId,
      result,
      completionTime: new Date()
    }))
  }
  
  // 创建提醒
  private createReminders(): void {
    const reminderPoints = this.calculateReminderPoints()
    
    for (const point of reminderPoints) {
      const reminder = new Reminder({
        planId: this._id,
        recipientId: this._responsibleId,
        scheduledTime: point.time,
        type: point.type,
        message: this.generateReminderMessage(point)
      })
      
      this._reminders.push(reminder)
      
      this.addDomainEvent(new MaintenanceReminderCreated({
        planId: this._id,
        reminder
      }))
    }
  }
  
  // 计算提醒时间点
  private calculateReminderPoints(): ReminderPoint[] {
    const points: ReminderPoint[] = []
    const startDate = this._plannedStartDate
    
    // 提前24小时
    points.push({
      time: new Date(startDate.getTime() - 24 * 60 * 60 * 1000),
      type: ReminderType.DAY_BEFORE
    })
    
    // 提前12小时
    points.push({
      time: new Date(startDate.getTime() - 12 * 60 * 60 * 1000),
      type: ReminderType.HALF_DAY_BEFORE
    })
    
    // 提前1小时
    points.push({
      time: new Date(startDate.getTime() - 60 * 60 * 1000),
      type: ReminderType.HOUR_BEFORE
    })
    
    return points.filter(p => p.time > new Date()) // 只保留未来的提醒
  }
  
  // 取消待发送的提醒
  private cancelPendingReminders(): void {
    this._reminders
      .filter(r => r.isPending())
      .forEach(r => {
        r.cancel()
        this.addDomainEvent(new MaintenanceReminderCancelled({
          planId: this._id,
          reminderId: r.id
        }))
      })
  }
  
  // 生成提醒消息
  private generateReminderMessage(point: ReminderPoint): string {
    const templates = {
      [ReminderType.DAY_BEFORE]: `维保计划「${this._title}」将于明天 ${format(this._plannedStartDate, 'HH:mm')} 开始执行`,
      [ReminderType.HALF_DAY_BEFORE]: `维保计划「${this._title}」将于12小时后开始执行`,
      [ReminderType.HOUR_BEFORE]: `维保计划「${this._title}」即将在1小时后开始，请做好准备`
    }
    
    return templates[point.type] || `维保计划「${this._title}」提醒`
  }
  
  // 验证
  private validate(props: MaintenancePlanProps): void {
    if (!props.title || props.title.length < 3) {
      throw new ValidationError('计划标题至少3个字符')
    }
    
    if (!props.responsibleId) {
      throw new ValidationError('必须指定负责人')
    }
    
    if (props.plannedEndDate <= props.plannedStartDate) {
      throw new ValidationError('计划结束时间必须晚于开始时间')
    }
    
    if (props.plannedStartDate < new Date()) {
      throw new ValidationError('计划开始时间不能早于当前时间')
    }
  }
  
  // 生成计划编号
  private generatePlanNo(): string {
    const date = format(new Date(), 'yyyyMM')
    const random = Math.random().toString(36).substr(2, 4).toUpperCase()
    return `MP-${date}-${random}`
  }
  
  // 获取可执行的操作
  getAvailableActions(userId: string): string[] {
    const actions: string[] = []
    
    if (this._approvalStatus === ApprovalStatus.DRAFT) {
      if (userId === this._responsibleId) {
        actions.push('submit')
      }
    }
    
    if (this._approvalStatus === ApprovalStatus.PENDING) {
      // 这里应该检查用户是否有审批权限
      actions.push('approve', 'reject')
    }
    
    if (this._approvalStatus === ApprovalStatus.APPROVED && 
        this._executionStatus === ExecutionStatus.IDLE) {
      if (userId === this._responsibleId) {
        actions.push('start')
      }
    }
    
    if (this._executionStatus === ExecutionStatus.EXECUTING) {
      if (userId === this._responsibleId) {
        actions.push('complete')
      }
    }
    
    return actions
  }
}
```

### Day 2: 审批和提醒值对象（8小时）

#### 1. 审批记录值对象
```typescript
// src/domain/maintenance/value-objects/ApprovalRecord.ts
export class ApprovalRecord {
  readonly id: string
  readonly action: ApprovalAction
  readonly operatorId: string
  readonly operatorName?: string
  readonly timestamp: Date
  readonly comment?: string
  readonly nextAssigneeId?: string
  readonly attachments?: string[]
  
  constructor(props: ApprovalRecordProps) {
    this.id = generateId()
    this.action = props.action
    this.operatorId = props.operatorId
    this.operatorName = props.operatorName
    this.timestamp = props.timestamp || new Date()
    this.comment = props.comment
    this.nextAssigneeId = props.nextAssigneeId
    this.attachments = props.attachments
  }
  
  isApproval(): boolean {
    return this.action === ApprovalAction.APPROVE
  }
  
  isRejection(): boolean {
    return this.action === ApprovalAction.REJECT
  }
  
  toJSON(): object {
    return {
      id: this.id,
      action: this.action,
      operatorId: this.operatorId,
      operatorName: this.operatorName,
      time: this.timestamp.toISOString(),
      comment: this.comment,
      nextAssigneeId: this.nextAssigneeId,
      attachments: this.attachments
    }
  }
}

// src/domain/maintenance/value-objects/Reminder.ts
export class Reminder {
  readonly id: string
  private _planId: string
  private _recipientId: string
  private _scheduledTime: Date
  private _type: ReminderType
  private _message: string
  private _status: ReminderStatus
  private _sentAt?: Date
  private _failureReason?: string
  private _retryCount: number = 0
  
  constructor(props: ReminderProps) {
    this.id = generateId()
    this._planId = props.planId
    this._recipientId = props.recipientId
    this._scheduledTime = props.scheduledTime
    this._type = props.type
    this._message = props.message
    this._status = ReminderStatus.PENDING
  }
  
  send(): void {
    if (this._status !== ReminderStatus.PENDING) {
      throw new DomainError('只能发送待发送的提醒')
    }
    
    this._status = ReminderStatus.SENT
    this._sentAt = new Date()
  }
  
  markFailed(reason: string): void {
    this._status = ReminderStatus.FAILED
    this._failureReason = reason
    this._retryCount++
  }
  
  cancel(): void {
    if (this._status === ReminderStatus.SENT) {
      throw new DomainError('已发送的提醒不能取消')
    }
    
    this._status = ReminderStatus.CANCELLED
  }
  
  canRetry(): boolean {
    return this._status === ReminderStatus.FAILED && 
           this._retryCount < 3
  }
  
  isPending(): boolean {
    return this._status === ReminderStatus.PENDING
  }
  
  isDue(): boolean {
    return this._status === ReminderStatus.PENDING && 
           new Date() >= this._scheduledTime
  }
  
  get recipientId(): string {
    return this._recipientId
  }
  
  get message(): string {
    return this._message
  }
  
  get type(): ReminderType {
    return this._type
  }
}
```

---

## Milestone 5.2: 审批流程重构（2天）

### Day 3: 审批流程引擎（8小时）

#### 1. 审批流程定义
```typescript
// src/domain/maintenance/services/ApprovalWorkflow.ts
export interface WorkflowStep {
  id: string
  name: string
  type: StepType
  approvers: ApproverConfig
  conditions?: Condition[]
  timeLimit?: number // 小时
  escalation?: EscalationConfig
}

export interface ApproverConfig {
  type: 'user' | 'role' | 'department' | 'dynamic'
  value: string | string[] | ((context: any) => string[])
}

export interface Condition {
  field: string
  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'in' | 'contains'
  value: any
}

export interface EscalationConfig {
  afterHours: number
  action: 'notify' | 'auto-approve' | 'escalate'
  target?: string
}

@Injectable()
export class ApprovalWorkflowEngine {
  private workflows = new Map<string, WorkflowStep[]>()
  
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.loadWorkflows()
  }
  
  private loadWorkflows(): void {
    // 维保计划审批流程
    this.workflows.set('maintenance-plan', [
      {
        id: 'step1',
        name: '部门主管审批',
        type: StepType.APPROVAL,
        approvers: {
          type: 'role',
          value: 'department_manager'
        },
        timeLimit: 24,
        escalation: {
          afterHours: 24,
          action: 'notify'
        }
      },
      {
        id: 'step2',
        name: '运维经理审批',
        type: StepType.APPROVAL,
        approvers: {
          type: 'role',
          value: 'operations_manager'
        },
        conditions: [
          {
            field: 'amount',
            operator: 'gt',
            value: 10000
          }
        ],
        timeLimit: 48
      },
      {
        id: 'step3',
        name: '总经理审批',
        type: StepType.APPROVAL,
        approvers: {
          type: 'dynamic',
          value: (context) => {
            // 根据楼层动态确定审批人
            const floorManagerMap = {
              [Floor.FLOOR_1]: 'manager_floor1',
              [Floor.FLOOR_2]: 'manager_floor2',
              [Floor.FLOOR_3]: 'manager_floor3',
              [Floor.FLOOR_4]: 'manager_floor4'
            }
            return [floorManagerMap[context.floor]]
          }
        },
        conditions: [
          {
            field: 'amount',
            operator: 'gt',
            value: 50000
          }
        ]
      }
    ])
  }
  
  async startWorkflow(
    workflowType: string,
    context: any
  ): Promise<WorkflowInstance> {
    const steps = this.workflows.get(workflowType)
    if (!steps) {
      throw new Error(`Workflow ${workflowType} not found`)
    }
    
    const instance = new WorkflowInstance({
      id: generateId(),
      workflowType,
      context,
      steps: this.filterApplicableSteps(steps, context),
      currentStepIndex: 0,
      status: WorkflowStatus.RUNNING,
      startedAt: new Date()
    })
    
    // 初始化第一步
    await this.initializeStep(instance, instance.getCurrentStep())
    
    // 发布工作流启动事件
    this.eventBus.emit('workflow.started', {
      instanceId: instance.id,
      workflowType,
      context
    })
    
    return instance
  }
  
  async processApproval(
    instanceId: string,
    approverId: string,
    decision: 'approve' | 'reject',
    comment?: string
  ): Promise<void> {
    const instance = await this.getWorkflowInstance(instanceId)
    
    if (!instance) {
      throw new NotFoundError(`Workflow instance ${instanceId} not found`)
    }
    
    const currentStep = instance.getCurrentStep()
    
    // 验证审批人权限
    if (!await this.validateApprover(currentStep, approverId)) {
      throw new AuthorizationError('您没有审批权限')
    }
    
    // 记录审批
    instance.recordApproval({
      stepId: currentStep.id,
      approverId,
      decision,
      comment,
      timestamp: new Date()
    })
    
    if (decision === 'approve') {
      // 移动到下一步
      if (instance.hasNextStep()) {
        instance.moveToNextStep()
        await this.initializeStep(instance, instance.getCurrentStep())
      } else {
        // 流程结束
        instance.complete()
        await this.handleWorkflowComplete(instance)
      }
    } else {
      // 拒绝，流程结束
      instance.reject(comment || '审批拒绝')
      await this.handleWorkflowRejected(instance)
    }
    
    // 保存实例
    await this.saveWorkflowInstance(instance)
  }
  
  private filterApplicableSteps(
    steps: WorkflowStep[],
    context: any
  ): WorkflowStep[] {
    return steps.filter(step => {
      if (!step.conditions || step.conditions.length === 0) {
        return true
      }
      
      return step.conditions.every(condition => 
        this.evaluateCondition(condition, context)
      )
    })
  }
  
  private evaluateCondition(condition: Condition, context: any): boolean {
    const value = this.getValueByPath(context, condition.field)
    
    switch (condition.operator) {
      case 'eq':
        return value === condition.value
      case 'ne':
        return value !== condition.value
      case 'gt':
        return value > condition.value
      case 'lt':
        return value < condition.value
      case 'in':
        return Array.isArray(condition.value) && 
               condition.value.includes(value)
      case 'contains':
        return String(value).includes(condition.value)
      default:
        return false
    }
  }
  
  private getValueByPath(obj: any, path: string): any {
    return path.split('.').reduce((acc, part) => acc?.[part], obj)
  }
  
  private async initializeStep(
    instance: WorkflowInstance,
    step: WorkflowStep
  ): Promise<void> {
    // 确定审批人
    const approvers = await this.resolveApprovers(step.approvers, instance.context)
    
    instance.setStepApprovers(step.id, approvers)
    
    // 发送通知
    for (const approverId of approvers) {
      this.eventBus.emit('approval.required', {
        instanceId: instance.id,
        stepId: step.id,
        approverId,
        context: instance.context
      })
    }
    
    // 设置超时处理
    if (step.timeLimit) {
      this.scheduleTimeout(instance.id, step.id, step.timeLimit)
    }
  }
  
  private async resolveApprovers(
    config: ApproverConfig,
    context: any
  ): Promise<string[]> {
    switch (config.type) {
      case 'user':
        return Array.isArray(config.value) ? config.value : [config.value]
      
      case 'role':
        return await this.getUsersByRole(config.value as string)
      
      case 'department':
        return await this.getUsersByDepartment(config.value as string)
      
      case 'dynamic':
        const resolver = config.value as Function
        return resolver(context)
      
      default:
        return []
    }
  }
  
  private scheduleTimeout(
    instanceId: string,
    stepId: string,
    hours: number
  ): void {
    setTimeout(async () => {
      await this.handleStepTimeout(instanceId, stepId)
    }, hours * 60 * 60 * 1000)
  }
  
  private async handleStepTimeout(
    instanceId: string,
    stepId: string
  ): Promise<void> {
    const instance = await this.getWorkflowInstance(instanceId)
    if (!instance) return
    
    const step = instance.getStep(stepId)
    if (!step || !step.escalation) return
    
    switch (step.escalation.action) {
      case 'notify':
        this.eventBus.emit('approval.timeout', {
          instanceId,
          stepId,
          approvers: instance.getStepApprovers(stepId)
        })
        break
      
      case 'auto-approve':
        await this.processApproval(
          instanceId,
          'system',
          'approve',
          '超时自动通过'
        )
        break
      
      case 'escalate':
        if (step.escalation.target) {
          await this.escalateToManager(instanceId, stepId, step.escalation.target)
        }
        break
    }
  }
  
  private async handleWorkflowComplete(instance: WorkflowInstance): Promise<void> {
    this.eventBus.emit('workflow.completed', {
      instanceId: instance.id,
      workflowType: instance.workflowType,
      context: instance.context,
      completedAt: new Date()
    })
    
    this.logger.info('Workflow completed', {
      instanceId: instance.id,
      duration: Date.now() - instance.startedAt.getTime()
    })
  }
  
  private async handleWorkflowRejected(instance: WorkflowInstance): Promise<void> {
    this.eventBus.emit('workflow.rejected', {
      instanceId: instance.id,
      workflowType: instance.workflowType,
      context: instance.context,
      reason: instance.rejectionReason
    })
  }
  
  // 辅助方法（实际应该从repository获取）
  private async getUsersByRole(role: string): Promise<string[]> {
    // 模拟实现
    return [`user_${role}_1`, `user_${role}_2`]
  }
  
  private async getUsersByDepartment(dept: string): Promise<string[]> {
    // 模拟实现
    return [`user_${dept}_1`]
  }
  
  private async getWorkflowInstance(id: string): Promise<WorkflowInstance | null> {
    // 从存储获取
    return null
  }
  
  private async saveWorkflowInstance(instance: WorkflowInstance): Promise<void> {
    // 保存到存储
  }
  
  private async escalateToManager(
    instanceId: string,
    stepId: string,
    managerId: string
  ): Promise<void> {
    // 升级处理
  }
}
```

### Day 4: 审批流程与维保集成（8小时）

#### 1. 维保审批服务
```typescript
// src/domain/maintenance/services/MaintenanceApprovalService.ts
@Injectable()
export class MaintenanceApprovalService {
  constructor(
    @Inject('MaintenanceRepository') private repository: MaintenanceRepository,
    @Inject('ApprovalWorkflowEngine') private workflowEngine: ApprovalWorkflowEngine,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.setupEventHandlers()
  }
  
  private setupEventHandlers(): void {
    // 监听维保计划提交事件
    this.eventBus.on(
      'maintenance.plan.submitted',
      this.handlePlanSubmitted.bind(this)
    )
    
    // 监听工作流完成事件
    this.eventBus.on(
      'workflow.completed',
      this.handleWorkflowCompleted.bind(this)
    )
    
    // 监听工作流拒绝事件
    this.eventBus.on(
      'workflow.rejected',
      this.handleWorkflowRejected.bind(this)
    )
  }
  
  private async handlePlanSubmitted(event: MaintenancePlanSubmitted): Promise<void> {
    const plan = await this.repository.findById(event.planId)
    if (!plan) return
    
    try {
      // 启动审批流程
      const workflowInstance = await this.workflowEngine.startWorkflow(
        'maintenance-plan',
        {
          planId: plan.id,
          title: plan.title,
          floor: plan.floor,
          amount: plan.estimatedCost,
          responsibleId: plan.responsibleId,
          plannedStartDate: plan.plannedStartDate
        }
      )
      
      // 关联工作流实例
      plan.setWorkflowInstanceId(workflowInstance.id)
      await this.repository.update(plan)
      
      this.logger.info('Approval workflow started for maintenance plan', {
        planId: plan.id,
        workflowId: workflowInstance.id
      })
    } catch (error) {
      this.logger.error('Failed to start approval workflow', {
        planId: plan.id,
        error
      })
      
      // 回滚状态
      plan.resetToDraft()
      await this.repository.update(plan)
    }
  }
  
  private async handleWorkflowCompleted(event: any): Promise<void> {
    if (event.workflowType !== 'maintenance-plan') return
    
    const planId = event.context.planId
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    // 自动批准计划
    plan.approve('system', '审批流程通过')
    await this.repository.update(plan)
    
    // 发布计划批准事件
    this.eventBus.emit('maintenance.plan.approved', {
      planId,
      approvedAt: new Date()
    })
    
    this.logger.info('Maintenance plan approved through workflow', {
      planId
    })
  }
  
  private async handleWorkflowRejected(event: any): Promise<void> {
    if (event.workflowType !== 'maintenance-plan') return
    
    const planId = event.context.planId
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    // 拒绝计划
    plan.reject('system', event.reason)
    await this.repository.update(plan)
    
    // 发布计划拒绝事件
    this.eventBus.emit('maintenance.plan.rejected', {
      planId,
      reason: event.reason,
      rejectedAt: new Date()
    })
    
    this.logger.info('Maintenance plan rejected through workflow', {
      planId,
      reason: event.reason
    })
  }
  
  async approveStep(
    planId: string,
    approverId: string,
    comment?: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const workflowId = plan.workflowInstanceId
    if (!workflowId) {
      throw new DomainError('No workflow associated with this plan')
    }
    
    await this.workflowEngine.processApproval(
      workflowId,
      approverId,
      'approve',
      comment
    )
  }
  
  async rejectStep(
    planId: string,
    rejectorId: string,
    reason: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const workflowId = plan.workflowInstanceId
    if (!workflowId) {
      throw new DomainError('No workflow associated with this plan')
    }
    
    await this.workflowEngine.processApproval(
      workflowId,
      rejectorId,
      'reject',
      reason
    )
  }
}
```

---

## Milestone 5.3: 提醒机制独立（1天）

### Day 5: 提醒服务实现（8小时）

#### 1. 提醒调度服务
```typescript
// src/services/maintenance/MaintenanceReminderService.ts
@Injectable()
export class MaintenanceReminderService {
  private scheduler: ReminderScheduler
  private activeReminders = new Map<string, ScheduledJob>()
  
  constructor(
    @Inject('MaintenanceRepository') private repository: MaintenanceRepository,
    @Inject('NotificationService') private notificationService: NotificationService,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.scheduler = new ReminderScheduler()
    this.setupEventHandlers()
    this.loadPendingReminders()
  }
  
  private setupEventHandlers(): void {
    // 监听提醒创建事件
    this.eventBus.on(
      'maintenance.reminder.created',
      this.handleReminderCreated.bind(this)
    )
    
    // 监听提醒取消事件
    this.eventBus.on(
      'maintenance.reminder.cancelled',
      this.handleReminderCancelled.bind(this)
    )
    
    // 监听计划变更事件
    this.eventBus.on(
      'maintenance.plan.rescheduled',
      this.handlePlanRescheduled.bind(this)
    )
  }
  
  private async loadPendingReminders(): Promise<void> {
    try {
      const reminders = await this.repository.findPendingReminders()
      
      for (const reminder of reminders) {
        this.scheduleReminder(reminder)
      }
      
      this.logger.info(`Loaded ${reminders.length} pending reminders`)
    } catch (error) {
      this.logger.error('Failed to load pending reminders', error)
    }
  }
  
  private async handleReminderCreated(event: any): Promise<void> {
    const { reminder } = event
    this.scheduleReminder(reminder)
  }
  
  private async handleReminderCancelled(event: any): Promise<void> {
    const { reminderId } = event
    this.cancelReminder(reminderId)
  }
  
  private async handlePlanRescheduled(event: any): Promise<void> {
    const { planId, newStartDate, oldStartDate } = event
    
    // 重新计算所有相关提醒的时间
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    const timeDiff = newStartDate.getTime() - oldStartDate.getTime()
    
    for (const reminder of plan.reminders) {
      if (reminder.isPending()) {
        // 取消旧的调度
        this.cancelReminder(reminder.id)
        
        // 更新提醒时间
        reminder.reschedule(new Date(reminder.scheduledTime.getTime() + timeDiff))
        
        // 重新调度
        this.scheduleReminder(reminder)
      }
    }
    
    await this.repository.update(plan)
  }
  
  private scheduleReminder(reminder: Reminder): void {
    if (!reminder.isPending()) return
    
    const job = this.scheduler.schedule(
      reminder.scheduledTime,
      async () => {
        await this.sendReminder(reminder)
      }
    )
    
    this.activeReminders.set(reminder.id, job)
    
    this.logger.info('Reminder scheduled', {
      reminderId: reminder.id,
      scheduledTime: reminder.scheduledTime
    })
  }
  
  private cancelReminder(reminderId: string): void {
    const job = this.activeReminders.get(reminderId)
    
    if (job) {
      job.cancel()
      this.activeReminders.delete(reminderId)
      
      this.logger.info('Reminder cancelled', { reminderId })
    }
  }
  
  private async sendReminder(reminder: Reminder): Promise<void> {
    try {
      // 发送通知
      await this.notificationService.send({
        recipientId: reminder.recipientId,
        type: 'maintenance_reminder',
        title: '维保计划提醒',
        message: reminder.message,
        priority: this.mapReminderPriority(reminder.type),
        data: {
          planId: reminder.planId,
          reminderType: reminder.type
        }
      })
      
      // 标记为已发送
      reminder.send()
      await this.repository.updateReminder(reminder)
      
      // 发布事件
      this.eventBus.emit('maintenance.reminder.sent', {
        reminderId: reminder.id,
        recipientId: reminder.recipientId,
        sentAt: new Date()
      })
      
      this.logger.info('Reminder sent successfully', {
        reminderId: reminder.id,
        recipientId: reminder.recipientId
      })
      
      // 从活动提醒中移除
      this.activeReminders.delete(reminder.id)
    } catch (error) {
      this.logger.error('Failed to send reminder', {
        reminderId: reminder.id,
        error
      })
      
      // 标记失败并尝试重试
      reminder.markFailed(error.message)
      
      if (reminder.canRetry()) {
        // 5分钟后重试
        setTimeout(() => {
          this.sendReminder(reminder)
        }, 5 * 60 * 1000)
      } else {
        // 发布失败事件
        this.eventBus.emit('maintenance.reminder.failed', {
          reminderId: reminder.id,
          reason: error.message
        })
      }
      
      await this.repository.updateReminder(reminder)
    }
  }
  
  private mapReminderPriority(type: ReminderType): NotificationPriority {
    const map = {
      [ReminderType.HOUR_BEFORE]: NotificationPriority.HIGH,
      [ReminderType.HALF_DAY_BEFORE]: NotificationPriority.MEDIUM,
      [ReminderType.DAY_BEFORE]: NotificationPriority.LOW
    }
    
    return map[type] || NotificationPriority.MEDIUM
  }
  
  // 公共方法
  async createCustomReminder(
    planId: string,
    recipientId: string,
    scheduledTime: Date,
    message: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const reminder = new Reminder({
      planId,
      recipientId,
      scheduledTime,
      type: ReminderType.CUSTOM,
      message
    })
    
    plan.addCustomReminder(reminder)
    await this.repository.update(plan)
    
    this.scheduleReminder(reminder)
  }
  
  async getUpcomingReminders(hours: number = 24): Promise<Reminder[]> {
    const cutoff = new Date()
    cutoff.setHours(cutoff.getHours() + hours)
    
    return await this.repository.findRemindersBeforeTime(cutoff)
  }
  
  async getReminderStatistics(): Promise<ReminderStatistics> {
    const [pending, sent, failed] = await Promise.all([
      this.repository.countRemindersByStatus(ReminderStatus.PENDING),
      this.repository.countRemindersByStatus(ReminderStatus.SENT),
      this.repository.countRemindersByStatus(ReminderStatus.FAILED)
    ])
    
    return {
      pending,
      sent,
      failed,
      scheduled: this.activeReminders.size
    }
  }
}

// 提醒调度器
class ReminderScheduler {
  private jobs = new Map<string, NodeJS.Timeout>()
  
  schedule(time: Date, callback: Function): ScheduledJob {
    const id = generateId()
    const delay = time.getTime() - Date.now()
    
    if (delay <= 0) {
      // 立即执行
      setImmediate(() => callback())
      return { id, cancel: () => {} }
    }
    
    const timeout = setTimeout(() => {
      callback()
      this.jobs.delete(id)
    }, delay)
    
    this.jobs.set(id, timeout)
    
    return {
      id,
      cancel: () => {
        clearTimeout(timeout)
        this.jobs.delete(id)
      }
    }
  }
  
  cancelAll(): void {
    this.jobs.forEach(timeout => clearTimeout(timeout))
    this.jobs.clear()
  }
}

interface ScheduledJob {
  id: string
  cancel: () => void
}
```

## 📊 Phase 5 完成标准检查清单

### 技术指标
- [ ] 维保领域模型完整
- [ ] 审批流程引擎可配置
- [ ] 提醒机制独立运行
- [ ] 测试覆盖率 > 85%
- [ ] 事件驱动通信正常

### 功能验证  
- [ ] 审批流程自动流转
- [ ] 条件审批正确判断
- [ ] 提醒按时发送
- [ ] 超时自动处理
- [ ] 工作流状态同步

### 性能指标
- [ ] 审批处理 < 200ms
- [ ] 提醒调度 < 50ms
- [ ] 工作流查询 < 100ms

## 🚀 Phase 5 交付物

1. **领域模型**
   - MaintenancePlan聚合根
   - ApprovalRecord值对象
   - Reminder值对象
   - 执行记录模型

2. **审批引擎**
   - ApprovalWorkflowEngine
   - WorkflowInstance
   - 条件评估器
   - 超时处理器

3. **提醒服务**
   - MaintenanceReminderService
   - ReminderScheduler
   - 通知集成
   - 重试机制

4. **测试文件**
   - 审批流程测试
   - 提醒调度测试
   - 集成测试

5. **文档**
   - MAINTENANCE-DOMAIN.md
   - APPROVAL-WORKFLOW.md
   - REMINDER-SERVICE.md

这就是Phase 5的完整实施方案，核心是建立维保领域模型、实现可配置的审批流程引擎、独立提醒服务，形成完整的维保业务闭环。