## Phase 5: æ ¸å¿ƒä¸šåŠ¡æ¨¡å—é‡æ„ - ç»´ä¿ï¼ˆ5å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1-2**: Milestone 5.1 ç»´ä¿é¢†åŸŸå»ºæ¨¡
- **Day 3-4**: Milestone 5.2 å®¡æ‰¹æµç¨‹é‡æ„
- **Day 5**: Milestone 5.3 æé†’æœºåˆ¶ç‹¬ç«‹

---

## Milestone 5.1: ç»´ä¿é¢†åŸŸå»ºæ¨¡ï¼ˆ2å¤©ï¼‰

### Day 1: ç»´ä¿è®¡åˆ’å®ä½“è®¾è®¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. ç»´ä¿è®¡åˆ’èšåˆæ ¹
```typescript
// src/domain/maintenance/entities/MaintenancePlan.ts
export class MaintenancePlan extends AggregateRoot {
  private _id: string
  private _planNo: string
  private _title: string
  private _floor: Floor
  private _equipmentIds: string[]
  private _responsibleId: string
  private _plannedStartDate: Date
  private _plannedEndDate: Date
  private _approvalStatus: ApprovalStatus
  private _executionStatus: ExecutionStatus
  private _approvalHistory: ApprovalRecord[]
  private _executionHistory: ExecutionRecord[]
  private _attachments: Attachment[]
  private _reminders: Reminder[]
  private _version: number
  
  constructor(props: MaintenancePlanProps) {
    super()
    this.validate(props)
    this._id = props.id || generateId()
    this._planNo = props.planNo || this.generatePlanNo()
    this._title = props.title
    this._floor = props.floor
    this._equipmentIds = props.equipmentIds || []
    this._responsibleId = props.responsibleId
    this._plannedStartDate = props.plannedStartDate
    this._plannedEndDate = props.plannedEndDate
    this._approvalStatus = ApprovalStatus.DRAFT
    this._executionStatus = ExecutionStatus.IDLE
    this._approvalHistory = []
    this._executionHistory = []
    this._attachments = []
    this._reminders = []
    this._version = 1
    
    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(new MaintenancePlanCreated({
      planId: this._id,
      title: this._title,
      responsibleId: this._responsibleId,
      plannedStartDate: this._plannedStartDate
    }))
  }
  
  // æäº¤å®¡æ‰¹
  submitForApproval(submitterId: string): void {
    if (this._approvalStatus !== ApprovalStatus.DRAFT) {
      throw new DomainError('åªèƒ½æäº¤è‰ç¨¿çŠ¶æ€çš„è®¡åˆ’')
    }
    
    this._approvalStatus = ApprovalStatus.PENDING
    
    const record = new ApprovalRecord({
      action: ApprovalAction.SUBMIT,
      operatorId: submitterId,
      timestamp: new Date(),
      comment: 'æäº¤å®¡æ‰¹'
    })
    
    this._approvalHistory.push(record)
    
    this.addDomainEvent(new MaintenancePlanSubmitted({
      planId: this._id,
      submitterId,
      timestamp: new Date()
    }))
  }
  
  // å®¡æ‰¹é€šè¿‡
  approve(approverId: string, comment?: string): void {
    if (this._approvalStatus !== ApprovalStatus.PENDING) {
      throw new DomainError('åªèƒ½å®¡æ‰¹å¾…å®¡æ‰¹çš„è®¡åˆ’')
    }
    
    this._approvalStatus = ApprovalStatus.APPROVED
    
    const record = new ApprovalRecord({
      action: ApprovalAction.APPROVE,
      operatorId: approverId,
      timestamp: new Date(),
      comment: comment || 'å®¡æ‰¹é€šè¿‡'
    })
    
    this._approvalHistory.push(record)
    
    // è‡ªåŠ¨åˆ›å»ºæé†’
    this.createReminders()
    
    this.addDomainEvent(new MaintenancePlanApproved({
      planId: this._id,
      approverId,
      timestamp: new Date()
    }))
  }
  
  // å®¡æ‰¹æ‹’ç»
  reject(rejectorId: string, reason: string): void {
    if (this._approvalStatus !== ApprovalStatus.PENDING) {
      throw new DomainError('åªèƒ½æ‹’ç»å¾…å®¡æ‰¹çš„è®¡åˆ’')
    }
    
    if (!reason || reason.trim().length === 0) {
      throw new ValidationError('æ‹’ç»åŸå› ä¸èƒ½ä¸ºç©º')
    }
    
    this._approvalStatus = ApprovalStatus.REJECTED
    
    const record = new ApprovalRecord({
      action: ApprovalAction.REJECT,
      operatorId: rejectorId,
      timestamp: new Date(),
      comment: reason
    })
    
    this._approvalHistory.push(record)
    
    this.addDomainEvent(new MaintenancePlanRejected({
      planId: this._id,
      rejectorId,
      reason,
      timestamp: new Date()
    }))
  }
  
  // å¼€å§‹æ‰§è¡Œ
  startExecution(executorId: string): void {
    if (this._approvalStatus !== ApprovalStatus.APPROVED) {
      throw new DomainError('åªèƒ½æ‰§è¡Œå·²æ‰¹å‡†çš„è®¡åˆ’')
    }
    
    if (this._executionStatus !== ExecutionStatus.IDLE) {
      throw new DomainError('è®¡åˆ’å·²åœ¨æ‰§è¡Œä¸­æˆ–å·²å®Œæˆ')
    }
    
    // æ£€æŸ¥æ˜¯å¦åˆ°äº†è®¡åˆ’å¼€å§‹æ—¶é—´
    const now = new Date()
    if (now < this._plannedStartDate) {
      throw new DomainError('å°šæœªåˆ°è®¡åˆ’å¼€å§‹æ—¶é—´')
    }
    
    this._executionStatus = ExecutionStatus.EXECUTING
    
    const record = new ExecutionRecord({
      action: ExecutionAction.START,
      operatorId: executorId,
      timestamp: now
    })
    
    this._executionHistory.push(record)
    
    // å–æ¶ˆæœªå‘é€çš„æé†’
    this.cancelPendingReminders()
    
    this.addDomainEvent(new MaintenanceExecutionStarted({
      planId: this._id,
      executorId,
      startTime: now
    }))
  }
  
  // å®Œæˆæ‰§è¡Œ
  completeExecution(
    executorId: string,
    result: string,
    attachments?: Attachment[]
  ): void {
    if (this._executionStatus !== ExecutionStatus.EXECUTING) {
      throw new DomainError('åªèƒ½å®Œæˆæ‰§è¡Œä¸­çš„è®¡åˆ’')
    }
    
    if (!result || result.trim().length === 0) {
      throw new ValidationError('æ‰§è¡Œç»“æœä¸èƒ½ä¸ºç©º')
    }
    
    this._executionStatus = ExecutionStatus.COMPLETED
    
    const record = new ExecutionRecord({
      action: ExecutionAction.COMPLETE,
      operatorId: executorId,
      timestamp: new Date(),
      result,
      attachments
    })
    
    this._executionHistory.push(record)
    
    if (attachments) {
      this._attachments.push(...attachments)
    }
    
    this.addDomainEvent(new MaintenanceExecutionCompleted({
      planId: this._id,
      executorId,
      result,
      completionTime: new Date()
    }))
  }
  
  // åˆ›å»ºæé†’
  private createReminders(): void {
    const reminderPoints = this.calculateReminderPoints()
    
    for (const point of reminderPoints) {
      const reminder = new Reminder({
        planId: this._id,
        recipientId: this._responsibleId,
        scheduledTime: point.time,
        type: point.type,
        message: this.generateReminderMessage(point)
      })
      
      this._reminders.push(reminder)
      
      this.addDomainEvent(new MaintenanceReminderCreated({
        planId: this._id,
        reminder
      }))
    }
  }
  
  // è®¡ç®—æé†’æ—¶é—´ç‚¹
  private calculateReminderPoints(): ReminderPoint[] {
    const points: ReminderPoint[] = []
    const startDate = this._plannedStartDate
    
    // æå‰24å°æ—¶
    points.push({
      time: new Date(startDate.getTime() - 24 * 60 * 60 * 1000),
      type: ReminderType.DAY_BEFORE
    })
    
    // æå‰12å°æ—¶
    points.push({
      time: new Date(startDate.getTime() - 12 * 60 * 60 * 1000),
      type: ReminderType.HALF_DAY_BEFORE
    })
    
    // æå‰1å°æ—¶
    points.push({
      time: new Date(startDate.getTime() - 60 * 60 * 1000),
      type: ReminderType.HOUR_BEFORE
    })
    
    return points.filter(p => p.time > new Date()) // åªä¿ç•™æœªæ¥çš„æé†’
  }
  
  // å–æ¶ˆå¾…å‘é€çš„æé†’
  private cancelPendingReminders(): void {
    this._reminders
      .filter(r => r.isPending())
      .forEach(r => {
        r.cancel()
        this.addDomainEvent(new MaintenanceReminderCancelled({
          planId: this._id,
          reminderId: r.id
        }))
      })
  }
  
  // ç”Ÿæˆæé†’æ¶ˆæ¯
  private generateReminderMessage(point: ReminderPoint): string {
    const templates = {
      [ReminderType.DAY_BEFORE]: `ç»´ä¿è®¡åˆ’ã€Œ${this._title}ã€å°†äºæ˜å¤© ${format(this._plannedStartDate, 'HH:mm')} å¼€å§‹æ‰§è¡Œ`,
      [ReminderType.HALF_DAY_BEFORE]: `ç»´ä¿è®¡åˆ’ã€Œ${this._title}ã€å°†äº12å°æ—¶åå¼€å§‹æ‰§è¡Œ`,
      [ReminderType.HOUR_BEFORE]: `ç»´ä¿è®¡åˆ’ã€Œ${this._title}ã€å³å°†åœ¨1å°æ—¶åå¼€å§‹ï¼Œè¯·åšå¥½å‡†å¤‡`
    }
    
    return templates[point.type] || `ç»´ä¿è®¡åˆ’ã€Œ${this._title}ã€æé†’`
  }
  
  // éªŒè¯
  private validate(props: MaintenancePlanProps): void {
    if (!props.title || props.title.length < 3) {
      throw new ValidationError('è®¡åˆ’æ ‡é¢˜è‡³å°‘3ä¸ªå­—ç¬¦')
    }
    
    if (!props.responsibleId) {
      throw new ValidationError('å¿…é¡»æŒ‡å®šè´Ÿè´£äºº')
    }
    
    if (props.plannedEndDate <= props.plannedStartDate) {
      throw new ValidationError('è®¡åˆ’ç»“æŸæ—¶é—´å¿…é¡»æ™šäºå¼€å§‹æ—¶é—´')
    }
    
    if (props.plannedStartDate < new Date()) {
      throw new ValidationError('è®¡åˆ’å¼€å§‹æ—¶é—´ä¸èƒ½æ—©äºå½“å‰æ—¶é—´')
    }
  }
  
  // ç”Ÿæˆè®¡åˆ’ç¼–å·
  private generatePlanNo(): string {
    const date = format(new Date(), 'yyyyMM')
    const random = Math.random().toString(36).substr(2, 4).toUpperCase()
    return `MP-${date}-${random}`
  }
  
  // è·å–å¯æ‰§è¡Œçš„æ“ä½œ
  getAvailableActions(userId: string): string[] {
    const actions: string[] = []
    
    if (this._approvalStatus === ApprovalStatus.DRAFT) {
      if (userId === this._responsibleId) {
        actions.push('submit')
      }
    }
    
    if (this._approvalStatus === ApprovalStatus.PENDING) {
      // è¿™é‡Œåº”è¯¥æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰å®¡æ‰¹æƒé™
      actions.push('approve', 'reject')
    }
    
    if (this._approvalStatus === ApprovalStatus.APPROVED && 
        this._executionStatus === ExecutionStatus.IDLE) {
      if (userId === this._responsibleId) {
        actions.push('start')
      }
    }
    
    if (this._executionStatus === ExecutionStatus.EXECUTING) {
      if (userId === this._responsibleId) {
        actions.push('complete')
      }
    }
    
    return actions
  }
}
```

### Day 2: å®¡æ‰¹å’Œæé†’å€¼å¯¹è±¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. å®¡æ‰¹è®°å½•å€¼å¯¹è±¡
```typescript
// src/domain/maintenance/value-objects/ApprovalRecord.ts
export class ApprovalRecord {
  readonly id: string
  readonly action: ApprovalAction
  readonly operatorId: string
  readonly operatorName?: string
  readonly timestamp: Date
  readonly comment?: string
  readonly nextAssigneeId?: string
  readonly attachments?: string[]
  
  constructor(props: ApprovalRecordProps) {
    this.id = generateId()
    this.action = props.action
    this.operatorId = props.operatorId
    this.operatorName = props.operatorName
    this.timestamp = props.timestamp || new Date()
    this.comment = props.comment
    this.nextAssigneeId = props.nextAssigneeId
    this.attachments = props.attachments
  }
  
  isApproval(): boolean {
    return this.action === ApprovalAction.APPROVE
  }
  
  isRejection(): boolean {
    return this.action === ApprovalAction.REJECT
  }
  
  toJSON(): object {
    return {
      id: this.id,
      action: this.action,
      operatorId: this.operatorId,
      operatorName: this.operatorName,
      time: this.timestamp.toISOString(),
      comment: this.comment,
      nextAssigneeId: this.nextAssigneeId,
      attachments: this.attachments
    }
  }
}

// src/domain/maintenance/value-objects/Reminder.ts
export class Reminder {
  readonly id: string
  private _planId: string
  private _recipientId: string
  private _scheduledTime: Date
  private _type: ReminderType
  private _message: string
  private _status: ReminderStatus
  private _sentAt?: Date
  private _failureReason?: string
  private _retryCount: number = 0
  
  constructor(props: ReminderProps) {
    this.id = generateId()
    this._planId = props.planId
    this._recipientId = props.recipientId
    this._scheduledTime = props.scheduledTime
    this._type = props.type
    this._message = props.message
    this._status = ReminderStatus.PENDING
  }
  
  send(): void {
    if (this._status !== ReminderStatus.PENDING) {
      throw new DomainError('åªèƒ½å‘é€å¾…å‘é€çš„æé†’')
    }
    
    this._status = ReminderStatus.SENT
    this._sentAt = new Date()
  }
  
  markFailed(reason: string): void {
    this._status = ReminderStatus.FAILED
    this._failureReason = reason
    this._retryCount++
  }
  
  cancel(): void {
    if (this._status === ReminderStatus.SENT) {
      throw new DomainError('å·²å‘é€çš„æé†’ä¸èƒ½å–æ¶ˆ')
    }
    
    this._status = ReminderStatus.CANCELLED
  }
  
  canRetry(): boolean {
    return this._status === ReminderStatus.FAILED && 
           this._retryCount < 3
  }
  
  isPending(): boolean {
    return this._status === ReminderStatus.PENDING
  }
  
  isDue(): boolean {
    return this._status === ReminderStatus.PENDING && 
           new Date() >= this._scheduledTime
  }
  
  get recipientId(): string {
    return this._recipientId
  }
  
  get message(): string {
    return this._message
  }
  
  get type(): ReminderType {
    return this._type
  }
}
```

---

## Milestone 5.2: å®¡æ‰¹æµç¨‹é‡æ„ï¼ˆ2å¤©ï¼‰

### Day 3: å®¡æ‰¹æµç¨‹å¼•æ“ï¼ˆ8å°æ—¶ï¼‰

#### 1. å®¡æ‰¹æµç¨‹å®šä¹‰
```typescript
// src/domain/maintenance/services/ApprovalWorkflow.ts
export interface WorkflowStep {
  id: string
  name: string
  type: StepType
  approvers: ApproverConfig
  conditions?: Condition[]
  timeLimit?: number // å°æ—¶
  escalation?: EscalationConfig
}

export interface ApproverConfig {
  type: 'user' | 'role' | 'department' | 'dynamic'
  value: string | string[] | ((context: any) => string[])
}

export interface Condition {
  field: string
  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'in' | 'contains'
  value: any
}

export interface EscalationConfig {
  afterHours: number
  action: 'notify' | 'auto-approve' | 'escalate'
  target?: string
}

@Injectable()
export class ApprovalWorkflowEngine {
  private workflows = new Map<string, WorkflowStep[]>()
  
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.loadWorkflows()
  }
  
  private loadWorkflows(): void {
    // ç»´ä¿è®¡åˆ’å®¡æ‰¹æµç¨‹
    this.workflows.set('maintenance-plan', [
      {
        id: 'step1',
        name: 'éƒ¨é—¨ä¸»ç®¡å®¡æ‰¹',
        type: StepType.APPROVAL,
        approvers: {
          type: 'role',
          value: 'department_manager'
        },
        timeLimit: 24,
        escalation: {
          afterHours: 24,
          action: 'notify'
        }
      },
      {
        id: 'step2',
        name: 'è¿ç»´ç»ç†å®¡æ‰¹',
        type: StepType.APPROVAL,
        approvers: {
          type: 'role',
          value: 'operations_manager'
        },
        conditions: [
          {
            field: 'amount',
            operator: 'gt',
            value: 10000
          }
        ],
        timeLimit: 48
      },
      {
        id: 'step3',
        name: 'æ€»ç»ç†å®¡æ‰¹',
        type: StepType.APPROVAL,
        approvers: {
          type: 'dynamic',
          value: (context) => {
            // æ ¹æ®æ¥¼å±‚åŠ¨æ€ç¡®å®šå®¡æ‰¹äºº
            const floorManagerMap = {
              [Floor.FLOOR_1]: 'manager_floor1',
              [Floor.FLOOR_2]: 'manager_floor2',
              [Floor.FLOOR_3]: 'manager_floor3',
              [Floor.FLOOR_4]: 'manager_floor4'
            }
            return [floorManagerMap[context.floor]]
          }
        },
        conditions: [
          {
            field: 'amount',
            operator: 'gt',
            value: 50000
          }
        ]
      }
    ])
  }
  
  async startWorkflow(
    workflowType: string,
    context: any
  ): Promise<WorkflowInstance> {
    const steps = this.workflows.get(workflowType)
    if (!steps) {
      throw new Error(`Workflow ${workflowType} not found`)
    }
    
    const instance = new WorkflowInstance({
      id: generateId(),
      workflowType,
      context,
      steps: this.filterApplicableSteps(steps, context),
      currentStepIndex: 0,
      status: WorkflowStatus.RUNNING,
      startedAt: new Date()
    })
    
    // åˆå§‹åŒ–ç¬¬ä¸€æ­¥
    await this.initializeStep(instance, instance.getCurrentStep())
    
    // å‘å¸ƒå·¥ä½œæµå¯åŠ¨äº‹ä»¶
    this.eventBus.emit('workflow.started', {
      instanceId: instance.id,
      workflowType,
      context
    })
    
    return instance
  }
  
  async processApproval(
    instanceId: string,
    approverId: string,
    decision: 'approve' | 'reject',
    comment?: string
  ): Promise<void> {
    const instance = await this.getWorkflowInstance(instanceId)
    
    if (!instance) {
      throw new NotFoundError(`Workflow instance ${instanceId} not found`)
    }
    
    const currentStep = instance.getCurrentStep()
    
    // éªŒè¯å®¡æ‰¹äººæƒé™
    if (!await this.validateApprover(currentStep, approverId)) {
      throw new AuthorizationError('æ‚¨æ²¡æœ‰å®¡æ‰¹æƒé™')
    }
    
    // è®°å½•å®¡æ‰¹
    instance.recordApproval({
      stepId: currentStep.id,
      approverId,
      decision,
      comment,
      timestamp: new Date()
    })
    
    if (decision === 'approve') {
      // ç§»åŠ¨åˆ°ä¸‹ä¸€æ­¥
      if (instance.hasNextStep()) {
        instance.moveToNextStep()
        await this.initializeStep(instance, instance.getCurrentStep())
      } else {
        // æµç¨‹ç»“æŸ
        instance.complete()
        await this.handleWorkflowComplete(instance)
      }
    } else {
      // æ‹’ç»ï¼Œæµç¨‹ç»“æŸ
      instance.reject(comment || 'å®¡æ‰¹æ‹’ç»')
      await this.handleWorkflowRejected(instance)
    }
    
    // ä¿å­˜å®ä¾‹
    await this.saveWorkflowInstance(instance)
  }
  
  private filterApplicableSteps(
    steps: WorkflowStep[],
    context: any
  ): WorkflowStep[] {
    return steps.filter(step => {
      if (!step.conditions || step.conditions.length === 0) {
        return true
      }
      
      return step.conditions.every(condition => 
        this.evaluateCondition(condition, context)
      )
    })
  }
  
  private evaluateCondition(condition: Condition, context: any): boolean {
    const value = this.getValueByPath(context, condition.field)
    
    switch (condition.operator) {
      case 'eq':
        return value === condition.value
      case 'ne':
        return value !== condition.value
      case 'gt':
        return value > condition.value
      case 'lt':
        return value < condition.value
      case 'in':
        return Array.isArray(condition.value) && 
               condition.value.includes(value)
      case 'contains':
        return String(value).includes(condition.value)
      default:
        return false
    }
  }
  
  private getValueByPath(obj: any, path: string): any {
    return path.split('.').reduce((acc, part) => acc?.[part], obj)
  }
  
  private async initializeStep(
    instance: WorkflowInstance,
    step: WorkflowStep
  ): Promise<void> {
    // ç¡®å®šå®¡æ‰¹äºº
    const approvers = await this.resolveApprovers(step.approvers, instance.context)
    
    instance.setStepApprovers(step.id, approvers)
    
    // å‘é€é€šçŸ¥
    for (const approverId of approvers) {
      this.eventBus.emit('approval.required', {
        instanceId: instance.id,
        stepId: step.id,
        approverId,
        context: instance.context
      })
    }
    
    // è®¾ç½®è¶…æ—¶å¤„ç†
    if (step.timeLimit) {
      this.scheduleTimeout(instance.id, step.id, step.timeLimit)
    }
  }
  
  private async resolveApprovers(
    config: ApproverConfig,
    context: any
  ): Promise<string[]> {
    switch (config.type) {
      case 'user':
        return Array.isArray(config.value) ? config.value : [config.value]
      
      case 'role':
        return await this.getUsersByRole(config.value as string)
      
      case 'department':
        return await this.getUsersByDepartment(config.value as string)
      
      case 'dynamic':
        const resolver = config.value as Function
        return resolver(context)
      
      default:
        return []
    }
  }
  
  private scheduleTimeout(
    instanceId: string,
    stepId: string,
    hours: number
  ): void {
    setTimeout(async () => {
      await this.handleStepTimeout(instanceId, stepId)
    }, hours * 60 * 60 * 1000)
  }
  
  private async handleStepTimeout(
    instanceId: string,
    stepId: string
  ): Promise<void> {
    const instance = await this.getWorkflowInstance(instanceId)
    if (!instance) return
    
    const step = instance.getStep(stepId)
    if (!step || !step.escalation) return
    
    switch (step.escalation.action) {
      case 'notify':
        this.eventBus.emit('approval.timeout', {
          instanceId,
          stepId,
          approvers: instance.getStepApprovers(stepId)
        })
        break
      
      case 'auto-approve':
        await this.processApproval(
          instanceId,
          'system',
          'approve',
          'è¶…æ—¶è‡ªåŠ¨é€šè¿‡'
        )
        break
      
      case 'escalate':
        if (step.escalation.target) {
          await this.escalateToManager(instanceId, stepId, step.escalation.target)
        }
        break
    }
  }
  
  private async handleWorkflowComplete(instance: WorkflowInstance): Promise<void> {
    this.eventBus.emit('workflow.completed', {
      instanceId: instance.id,
      workflowType: instance.workflowType,
      context: instance.context,
      completedAt: new Date()
    })
    
    this.logger.info('Workflow completed', {
      instanceId: instance.id,
      duration: Date.now() - instance.startedAt.getTime()
    })
  }
  
  private async handleWorkflowRejected(instance: WorkflowInstance): Promise<void> {
    this.eventBus.emit('workflow.rejected', {
      instanceId: instance.id,
      workflowType: instance.workflowType,
      context: instance.context,
      reason: instance.rejectionReason
    })
  }
  
  // è¾…åŠ©æ–¹æ³•ï¼ˆå®é™…åº”è¯¥ä»repositoryè·å–ï¼‰
  private async getUsersByRole(role: string): Promise<string[]> {
    // æ¨¡æ‹Ÿå®ç°
    return [`user_${role}_1`, `user_${role}_2`]
  }
  
  private async getUsersByDepartment(dept: string): Promise<string[]> {
    // æ¨¡æ‹Ÿå®ç°
    return [`user_${dept}_1`]
  }
  
  private async getWorkflowInstance(id: string): Promise<WorkflowInstance | null> {
    // ä»å­˜å‚¨è·å–
    return null
  }
  
  private async saveWorkflowInstance(instance: WorkflowInstance): Promise<void> {
    // ä¿å­˜åˆ°å­˜å‚¨
  }
  
  private async escalateToManager(
    instanceId: string,
    stepId: string,
    managerId: string
  ): Promise<void> {
    // å‡çº§å¤„ç†
  }
}
```

### Day 4: å®¡æ‰¹æµç¨‹ä¸ç»´ä¿é›†æˆï¼ˆ8å°æ—¶ï¼‰

#### 1. ç»´ä¿å®¡æ‰¹æœåŠ¡
```typescript
// src/domain/maintenance/services/MaintenanceApprovalService.ts
@Injectable()
export class MaintenanceApprovalService {
  constructor(
    @Inject('MaintenanceRepository') private repository: MaintenanceRepository,
    @Inject('ApprovalWorkflowEngine') private workflowEngine: ApprovalWorkflowEngine,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.setupEventHandlers()
  }
  
  private setupEventHandlers(): void {
    // ç›‘å¬ç»´ä¿è®¡åˆ’æäº¤äº‹ä»¶
    this.eventBus.on(
      'maintenance.plan.submitted',
      this.handlePlanSubmitted.bind(this)
    )
    
    // ç›‘å¬å·¥ä½œæµå®Œæˆäº‹ä»¶
    this.eventBus.on(
      'workflow.completed',
      this.handleWorkflowCompleted.bind(this)
    )
    
    // ç›‘å¬å·¥ä½œæµæ‹’ç»äº‹ä»¶
    this.eventBus.on(
      'workflow.rejected',
      this.handleWorkflowRejected.bind(this)
    )
  }
  
  private async handlePlanSubmitted(event: MaintenancePlanSubmitted): Promise<void> {
    const plan = await this.repository.findById(event.planId)
    if (!plan) return
    
    try {
      // å¯åŠ¨å®¡æ‰¹æµç¨‹
      const workflowInstance = await this.workflowEngine.startWorkflow(
        'maintenance-plan',
        {
          planId: plan.id,
          title: plan.title,
          floor: plan.floor,
          amount: plan.estimatedCost,
          responsibleId: plan.responsibleId,
          plannedStartDate: plan.plannedStartDate
        }
      )
      
      // å…³è”å·¥ä½œæµå®ä¾‹
      plan.setWorkflowInstanceId(workflowInstance.id)
      await this.repository.update(plan)
      
      this.logger.info('Approval workflow started for maintenance plan', {
        planId: plan.id,
        workflowId: workflowInstance.id
      })
    } catch (error) {
      this.logger.error('Failed to start approval workflow', {
        planId: plan.id,
        error
      })
      
      // å›æ»šçŠ¶æ€
      plan.resetToDraft()
      await this.repository.update(plan)
    }
  }
  
  private async handleWorkflowCompleted(event: any): Promise<void> {
    if (event.workflowType !== 'maintenance-plan') return
    
    const planId = event.context.planId
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    // è‡ªåŠ¨æ‰¹å‡†è®¡åˆ’
    plan.approve('system', 'å®¡æ‰¹æµç¨‹é€šè¿‡')
    await this.repository.update(plan)
    
    // å‘å¸ƒè®¡åˆ’æ‰¹å‡†äº‹ä»¶
    this.eventBus.emit('maintenance.plan.approved', {
      planId,
      approvedAt: new Date()
    })
    
    this.logger.info('Maintenance plan approved through workflow', {
      planId
    })
  }
  
  private async handleWorkflowRejected(event: any): Promise<void> {
    if (event.workflowType !== 'maintenance-plan') return
    
    const planId = event.context.planId
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    // æ‹’ç»è®¡åˆ’
    plan.reject('system', event.reason)
    await this.repository.update(plan)
    
    // å‘å¸ƒè®¡åˆ’æ‹’ç»äº‹ä»¶
    this.eventBus.emit('maintenance.plan.rejected', {
      planId,
      reason: event.reason,
      rejectedAt: new Date()
    })
    
    this.logger.info('Maintenance plan rejected through workflow', {
      planId,
      reason: event.reason
    })
  }
  
  async approveStep(
    planId: string,
    approverId: string,
    comment?: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const workflowId = plan.workflowInstanceId
    if (!workflowId) {
      throw new DomainError('No workflow associated with this plan')
    }
    
    await this.workflowEngine.processApproval(
      workflowId,
      approverId,
      'approve',
      comment
    )
  }
  
  async rejectStep(
    planId: string,
    rejectorId: string,
    reason: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const workflowId = plan.workflowInstanceId
    if (!workflowId) {
      throw new DomainError('No workflow associated with this plan')
    }
    
    await this.workflowEngine.processApproval(
      workflowId,
      rejectorId,
      'reject',
      reason
    )
  }
}
```

---

## Milestone 5.3: æé†’æœºåˆ¶ç‹¬ç«‹ï¼ˆ1å¤©ï¼‰

### Day 5: æé†’æœåŠ¡å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. æé†’è°ƒåº¦æœåŠ¡
```typescript
// src/services/maintenance/MaintenanceReminderService.ts
@Injectable()
export class MaintenanceReminderService {
  private scheduler: ReminderScheduler
  private activeReminders = new Map<string, ScheduledJob>()
  
  constructor(
    @Inject('MaintenanceRepository') private repository: MaintenanceRepository,
    @Inject('NotificationService') private notificationService: NotificationService,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.scheduler = new ReminderScheduler()
    this.setupEventHandlers()
    this.loadPendingReminders()
  }
  
  private setupEventHandlers(): void {
    // ç›‘å¬æé†’åˆ›å»ºäº‹ä»¶
    this.eventBus.on(
      'maintenance.reminder.created',
      this.handleReminderCreated.bind(this)
    )
    
    // ç›‘å¬æé†’å–æ¶ˆäº‹ä»¶
    this.eventBus.on(
      'maintenance.reminder.cancelled',
      this.handleReminderCancelled.bind(this)
    )
    
    // ç›‘å¬è®¡åˆ’å˜æ›´äº‹ä»¶
    this.eventBus.on(
      'maintenance.plan.rescheduled',
      this.handlePlanRescheduled.bind(this)
    )
  }
  
  private async loadPendingReminders(): Promise<void> {
    try {
      const reminders = await this.repository.findPendingReminders()
      
      for (const reminder of reminders) {
        this.scheduleReminder(reminder)
      }
      
      this.logger.info(`Loaded ${reminders.length} pending reminders`)
    } catch (error) {
      this.logger.error('Failed to load pending reminders', error)
    }
  }
  
  private async handleReminderCreated(event: any): Promise<void> {
    const { reminder } = event
    this.scheduleReminder(reminder)
  }
  
  private async handleReminderCancelled(event: any): Promise<void> {
    const { reminderId } = event
    this.cancelReminder(reminderId)
  }
  
  private async handlePlanRescheduled(event: any): Promise<void> {
    const { planId, newStartDate, oldStartDate } = event
    
    // é‡æ–°è®¡ç®—æ‰€æœ‰ç›¸å…³æé†’çš„æ—¶é—´
    const plan = await this.repository.findById(planId)
    if (!plan) return
    
    const timeDiff = newStartDate.getTime() - oldStartDate.getTime()
    
    for (const reminder of plan.reminders) {
      if (reminder.isPending()) {
        // å–æ¶ˆæ—§çš„è°ƒåº¦
        this.cancelReminder(reminder.id)
        
        // æ›´æ–°æé†’æ—¶é—´
        reminder.reschedule(new Date(reminder.scheduledTime.getTime() + timeDiff))
        
        // é‡æ–°è°ƒåº¦
        this.scheduleReminder(reminder)
      }
    }
    
    await this.repository.update(plan)
  }
  
  private scheduleReminder(reminder: Reminder): void {
    if (!reminder.isPending()) return
    
    const job = this.scheduler.schedule(
      reminder.scheduledTime,
      async () => {
        await this.sendReminder(reminder)
      }
    )
    
    this.activeReminders.set(reminder.id, job)
    
    this.logger.info('Reminder scheduled', {
      reminderId: reminder.id,
      scheduledTime: reminder.scheduledTime
    })
  }
  
  private cancelReminder(reminderId: string): void {
    const job = this.activeReminders.get(reminderId)
    
    if (job) {
      job.cancel()
      this.activeReminders.delete(reminderId)
      
      this.logger.info('Reminder cancelled', { reminderId })
    }
  }
  
  private async sendReminder(reminder: Reminder): Promise<void> {
    try {
      // å‘é€é€šçŸ¥
      await this.notificationService.send({
        recipientId: reminder.recipientId,
        type: 'maintenance_reminder',
        title: 'ç»´ä¿è®¡åˆ’æé†’',
        message: reminder.message,
        priority: this.mapReminderPriority(reminder.type),
        data: {
          planId: reminder.planId,
          reminderType: reminder.type
        }
      })
      
      // æ ‡è®°ä¸ºå·²å‘é€
      reminder.send()
      await this.repository.updateReminder(reminder)
      
      // å‘å¸ƒäº‹ä»¶
      this.eventBus.emit('maintenance.reminder.sent', {
        reminderId: reminder.id,
        recipientId: reminder.recipientId,
        sentAt: new Date()
      })
      
      this.logger.info('Reminder sent successfully', {
        reminderId: reminder.id,
        recipientId: reminder.recipientId
      })
      
      // ä»æ´»åŠ¨æé†’ä¸­ç§»é™¤
      this.activeReminders.delete(reminder.id)
    } catch (error) {
      this.logger.error('Failed to send reminder', {
        reminderId: reminder.id,
        error
      })
      
      // æ ‡è®°å¤±è´¥å¹¶å°è¯•é‡è¯•
      reminder.markFailed(error.message)
      
      if (reminder.canRetry()) {
        // 5åˆ†é’Ÿåé‡è¯•
        setTimeout(() => {
          this.sendReminder(reminder)
        }, 5 * 60 * 1000)
      } else {
        // å‘å¸ƒå¤±è´¥äº‹ä»¶
        this.eventBus.emit('maintenance.reminder.failed', {
          reminderId: reminder.id,
          reason: error.message
        })
      }
      
      await this.repository.updateReminder(reminder)
    }
  }
  
  private mapReminderPriority(type: ReminderType): NotificationPriority {
    const map = {
      [ReminderType.HOUR_BEFORE]: NotificationPriority.HIGH,
      [ReminderType.HALF_DAY_BEFORE]: NotificationPriority.MEDIUM,
      [ReminderType.DAY_BEFORE]: NotificationPriority.LOW
    }
    
    return map[type] || NotificationPriority.MEDIUM
  }
  
  // å…¬å…±æ–¹æ³•
  async createCustomReminder(
    planId: string,
    recipientId: string,
    scheduledTime: Date,
    message: string
  ): Promise<void> {
    const plan = await this.repository.findById(planId)
    if (!plan) {
      throw new NotFoundError(`Plan ${planId} not found`)
    }
    
    const reminder = new Reminder({
      planId,
      recipientId,
      scheduledTime,
      type: ReminderType.CUSTOM,
      message
    })
    
    plan.addCustomReminder(reminder)
    await this.repository.update(plan)
    
    this.scheduleReminder(reminder)
  }
  
  async getUpcomingReminders(hours: number = 24): Promise<Reminder[]> {
    const cutoff = new Date()
    cutoff.setHours(cutoff.getHours() + hours)
    
    return await this.repository.findRemindersBeforeTime(cutoff)
  }
  
  async getReminderStatistics(): Promise<ReminderStatistics> {
    const [pending, sent, failed] = await Promise.all([
      this.repository.countRemindersByStatus(ReminderStatus.PENDING),
      this.repository.countRemindersByStatus(ReminderStatus.SENT),
      this.repository.countRemindersByStatus(ReminderStatus.FAILED)
    ])
    
    return {
      pending,
      sent,
      failed,
      scheduled: this.activeReminders.size
    }
  }
}

// æé†’è°ƒåº¦å™¨
class ReminderScheduler {
  private jobs = new Map<string, NodeJS.Timeout>()
  
  schedule(time: Date, callback: Function): ScheduledJob {
    const id = generateId()
    const delay = time.getTime() - Date.now()
    
    if (delay <= 0) {
      // ç«‹å³æ‰§è¡Œ
      setImmediate(() => callback())
      return { id, cancel: () => {} }
    }
    
    const timeout = setTimeout(() => {
      callback()
      this.jobs.delete(id)
    }, delay)
    
    this.jobs.set(id, timeout)
    
    return {
      id,
      cancel: () => {
        clearTimeout(timeout)
        this.jobs.delete(id)
      }
    }
  }
  
  cancelAll(): void {
    this.jobs.forEach(timeout => clearTimeout(timeout))
    this.jobs.clear()
  }
}

interface ScheduledJob {
  id: string
  cancel: () => void
}
```

## ğŸ“Š Phase 5 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] ç»´ä¿é¢†åŸŸæ¨¡å‹å®Œæ•´
- [ ] å®¡æ‰¹æµç¨‹å¼•æ“å¯é…ç½®
- [ ] æé†’æœºåˆ¶ç‹¬ç«‹è¿è¡Œ
- [ ] æµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] äº‹ä»¶é©±åŠ¨é€šä¿¡æ­£å¸¸

### åŠŸèƒ½éªŒè¯  
- [ ] å®¡æ‰¹æµç¨‹è‡ªåŠ¨æµè½¬
- [ ] æ¡ä»¶å®¡æ‰¹æ­£ç¡®åˆ¤æ–­
- [ ] æé†’æŒ‰æ—¶å‘é€
- [ ] è¶…æ—¶è‡ªåŠ¨å¤„ç†
- [ ] å·¥ä½œæµçŠ¶æ€åŒæ­¥

### æ€§èƒ½æŒ‡æ ‡
- [ ] å®¡æ‰¹å¤„ç† < 200ms
- [ ] æé†’è°ƒåº¦ < 50ms
- [ ] å·¥ä½œæµæŸ¥è¯¢ < 100ms

## ğŸš€ Phase 5 äº¤ä»˜ç‰©

1. **é¢†åŸŸæ¨¡å‹**
   - MaintenancePlanèšåˆæ ¹
   - ApprovalRecordå€¼å¯¹è±¡
   - Reminderå€¼å¯¹è±¡
   - æ‰§è¡Œè®°å½•æ¨¡å‹

2. **å®¡æ‰¹å¼•æ“**
   - ApprovalWorkflowEngine
   - WorkflowInstance
   - æ¡ä»¶è¯„ä¼°å™¨
   - è¶…æ—¶å¤„ç†å™¨

3. **æé†’æœåŠ¡**
   - MaintenanceReminderService
   - ReminderScheduler
   - é€šçŸ¥é›†æˆ
   - é‡è¯•æœºåˆ¶

4. **æµ‹è¯•æ–‡ä»¶**
   - å®¡æ‰¹æµç¨‹æµ‹è¯•
   - æé†’è°ƒåº¦æµ‹è¯•
   - é›†æˆæµ‹è¯•

5. **æ–‡æ¡£**
   - MAINTENANCE-DOMAIN.md
   - APPROVAL-WORKFLOW.md
   - REMINDER-SERVICE.md

è¿™å°±æ˜¯Phase 5çš„å®Œæ•´å®æ–½æ–¹æ¡ˆï¼Œæ ¸å¿ƒæ˜¯å»ºç«‹ç»´ä¿é¢†åŸŸæ¨¡å‹ã€å®ç°å¯é…ç½®çš„å®¡æ‰¹æµç¨‹å¼•æ“ã€ç‹¬ç«‹æé†’æœåŠ¡ï¼Œå½¢æˆå®Œæ•´çš„ç»´ä¿ä¸šåŠ¡é—­ç¯ã€‚