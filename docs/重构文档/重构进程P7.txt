## Phase 7: ä¼˜åŒ–ä¸ç›‘æ§ï¼ˆ3å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1**: Milestone 7.1 æ€§èƒ½ä¼˜åŒ–
- **Day 2**: Milestone 7.2 ç›‘æ§ä½“ç³»æ­å»º
- **Day 3**: Milestone 7.3 æ—¥å¿—å’Œè¿½è¸ªç³»ç»Ÿ

---

## Milestone 7.1: æ€§èƒ½ä¼˜åŒ–ï¼ˆ1å¤©ï¼‰

### Day 1: æ€§èƒ½ä¼˜åŒ–å®æ–½ï¼ˆ8å°æ—¶ï¼‰

#### 1. æŸ¥è¯¢ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥
```typescript
// src/infrastructure/cache/CacheManager.ts
@Injectable()
export class CacheManager {
  private caches = new Map<string, Cache>()
  private strategies = new Map<string, CacheStrategy>()
  
  constructor(
    @Inject('Logger') private logger: Logger,
    @Inject('MetricsCollector') private metrics: MetricsCollector
  ) {
    this.initializeCaches()
  }
  
  private initializeCaches(): void {
    // L1ç¼“å­˜ï¼šå†…å­˜ç¼“å­˜
    this.registerCache('memory', new MemoryCache({
      maxSize: 1000,
      ttl: 60000, // 1åˆ†é’Ÿ
      evictionPolicy: 'LRU'
    }))
    
    // L2ç¼“å­˜ï¼šRedisç¼“å­˜
    this.registerCache('redis', new RedisCache({
      host: 'localhost',
      port: 6379,
      ttl: 3600000, // 1å°æ—¶
      keyPrefix: 'app:'
    }))
    
    // æ³¨å†Œç¼“å­˜ç­–ç•¥
    this.registerStrategy('ticket', new MultiLayerStrategy(['memory', 'redis']))
    this.registerStrategy('inspection', new WriteThoughStrategy('redis'))
    this.registerStrategy('maintenance', new WriteBehindStrategy('redis', 5000))
  }
  
  async get<T>(key: string, namespace: string = 'default'): Promise<T | null> {
    const startTime = Date.now()
    const strategy = this.strategies.get(namespace) || new DefaultStrategy()
    
    try {
      const result = await strategy.get(key, this.caches)
      
      // è®°å½•æŒ‡æ ‡
      this.metrics.recordCacheHit(namespace, result !== null)
      this.metrics.recordCacheLatency(namespace, Date.now() - startTime)
      
      return result
    } catch (error) {
      this.logger.error('Cache get error', { key, namespace, error })
      return null
    }
  }
  
  async set(key: string, value: any, namespace: string = 'default'): Promise<void> {
    const strategy = this.strategies.get(namespace) || new DefaultStrategy()
    
    try {
      await strategy.set(key, value, this.caches)
    } catch (error) {
      this.logger.error('Cache set error', { key, namespace, error })
    }
  }
  
  async invalidate(pattern: string, namespace: string = 'default'): Promise<void> {
    const strategy = this.strategies.get(namespace) || new DefaultStrategy()
    await strategy.invalidate(pattern, this.caches)
    
    this.logger.info('Cache invalidated', { pattern, namespace })
  }
  
  private registerCache(name: string, cache: Cache): void {
    this.caches.set(name, cache)
  }
  
  private registerStrategy(namespace: string, strategy: CacheStrategy): void {
    this.strategies.set(namespace, strategy)
  }
}

// å¤šå±‚ç¼“å­˜ç­–ç•¥
class MultiLayerStrategy implements CacheStrategy {
  constructor(private layers: string[]) {}
  
  async get(key: string, caches: Map<string, Cache>): Promise<any> {
    for (let i = 0; i < this.layers.length; i++) {
      const cache = caches.get(this.layers[i])
      if (!cache) continue
      
      const value = await cache.get(key)
      if (value !== null) {
        // å›å¡«ä¸Šå±‚ç¼“å­˜
        for (let j = 0; j < i; j++) {
          const upperCache = caches.get(this.layers[j])
          if (upperCache) {
            await upperCache.set(key, value)
          }
        }
        return value
      }
    }
    return null
  }
  
  async set(key: string, value: any, caches: Map<string, Cache>): Promise<void> {
    // å†™å…¥æ‰€æœ‰å±‚
    await Promise.all(
      this.layers.map(layer => {
        const cache = caches.get(layer)
        return cache?.set(key, value)
      })
    )
  }
  
  async invalidate(pattern: string, caches: Map<string, Cache>): Promise<void> {
    await Promise.all(
      this.layers.map(layer => {
        const cache = caches.get(layer)
        return cache?.invalidate(pattern)
      })
    )
  }
}
```

#### 2. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```typescript
// src/infrastructure/database/QueryOptimizer.ts
@Injectable()
export class QueryOptimizer {
  private queryCache = new Map<string, PreparedQuery>()
  private statistics = new Map<string, QueryStatistics>()
  
  constructor(
    @Inject('DatabaseConnection') private db: DatabaseConnection,
    @Inject('Logger') private logger: Logger
  ) {}
  
  async executeOptimized<T>(
    query: Query,
    options?: QueryOptions
  ): Promise<T[]> {
    const queryKey = this.getQueryKey(query)
    const stats = this.getStatistics(queryKey)
    
    // åˆ†ææŸ¥è¯¢è®¡åˆ’
    const plan = await this.analyzeQueryPlan(query)
    
    // ä¼˜åŒ–æŸ¥è¯¢
    const optimizedQuery = this.optimizeQuery(query, plan, stats)
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const startTime = Date.now()
    const result = await this.executeQuery(optimizedQuery, options)
    const duration = Date.now() - startTime
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    this.updateStatistics(queryKey, duration, result.length)
    
    // å¦‚æœæŸ¥è¯¢æ…¢ï¼Œè®°å½•å¹¶åˆ†æ
    if (duration > 1000) {
      this.handleSlowQuery(query, duration, plan)
    }
    
    return result
  }
  
  private async analyzeQueryPlan(query: Query): Promise<QueryPlan> {
    const explainResult = await this.db.execute(`EXPLAIN ${query.sql}`)
    
    return {
      type: explainResult[0].type,
      possibleKeys: explainResult[0].possible_keys,
      key: explainResult[0].key,
      rows: explainResult[0].rows,
      extra: explainResult[0].extra
    }
  }
  
  private optimizeQuery(
    query: Query,
    plan: QueryPlan,
    stats: QueryStatistics
  ): Query {
    let optimized = { ...query }
    
    // 1. æ·»åŠ ç´¢å¼•æç¤º
    if (plan.possibleKeys && !plan.key) {
      optimized = this.addIndexHint(optimized, plan.possibleKeys[0])
    }
    
    // 2. ä¼˜åŒ–JOINé¡ºåº
    if (query.joins && query.joins.length > 1) {
      optimized.joins = this.optimizeJoinOrder(query.joins, stats)
    }
    
    // 3. æ·»åŠ æŸ¥è¯¢ç¼“å­˜
    if (stats.avgDuration < 100 && stats.hitCount > 100) {
      optimized.cache = true
      optimized.cacheTTL = 60000
    }
    
    // 4. åˆ†é¡µä¼˜åŒ–
    if (query.limit && query.offset > 1000) {
      optimized = this.optimizePagination(optimized)
    }
    
    return optimized
  }
  
  private optimizeJoinOrder(joins: Join[], stats: QueryStatistics): Join[] {
    // åŸºäºç»Ÿè®¡ä¿¡æ¯é‡æ’JOINé¡ºåº
    return joins.sort((a, b) => {
      const aSelectivity = this.estimateSelectivity(a, stats)
      const bSelectivity = this.estimateSelectivity(b, stats)
      return aSelectivity - bSelectivity
    })
  }
  
  private optimizePagination(query: Query): Query {
    // ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µæ›¿ä»£OFFSET
    if (query.lastId) {
      return {
        ...query,
        where: [
          ...query.where,
          { field: 'id', operator: '>', value: query.lastId }
        ],
        offset: 0
      }
    }
    
    return query
  }
  
  private async handleSlowQuery(
    query: Query,
    duration: number,
    plan: QueryPlan
  ): Promise<void> {
    this.logger.warn('Slow query detected', {
      query: query.sql,
      duration,
      plan
    })
    
    // ç”Ÿæˆä¼˜åŒ–å»ºè®®
    const suggestions = this.generateOptimizationSuggestions(query, plan)
    
    // è®°å½•åˆ°æ…¢æŸ¥è¯¢æ—¥å¿—
    await this.db.logSlowQuery({
      query: query.sql,
      duration,
      plan,
      suggestions,
      timestamp: new Date()
    })
  }
  
  private generateOptimizationSuggestions(
    query: Query,
    plan: QueryPlan
  ): string[] {
    const suggestions: string[] = []
    
    if (!plan.key && plan.possibleKeys) {
      suggestions.push(`Consider adding index on: ${plan.possibleKeys.join(', ')}`)
    }
    
    if (plan.type === 'ALL') {
      suggestions.push('Full table scan detected, add WHERE clause or index')
    }
    
    if (plan.extra?.includes('Using filesort')) {
      suggestions.push('Consider adding index for ORDER BY clause')
    }
    
    if (plan.extra?.includes('Using temporary')) {
      suggestions.push('Temporary table used, optimize GROUP BY or DISTINCT')
    }
    
    return suggestions
  }
  
  private estimateSelectivity(join: Join, stats: QueryStatistics): number {
    // ä¼°ç®—é€‰æ‹©æ€§ï¼ˆè¿”å›è¡Œæ•°/æ€»è¡Œæ•°ï¼‰
    const tableStats = stats.tableStatistics?.[join.table]
    if (!tableStats) return 1
    
    return tableStats.avgRowsReturned / tableStats.totalRows
  }
  
  private getStatistics(queryKey: string): QueryStatistics {
    if (!this.statistics.has(queryKey)) {
      this.statistics.set(queryKey, {
        hitCount: 0,
        totalDuration: 0,
        avgDuration: 0,
        maxDuration: 0,
        minDuration: Infinity
      })
    }
    
    return this.statistics.get(queryKey)!
  }
  
  private updateStatistics(
    queryKey: string,
    duration: number,
    rowCount: number
  ): void {
    const stats = this.getStatistics(queryKey)
    
    stats.hitCount++
    stats.totalDuration += duration
    stats.avgDuration = stats.totalDuration / stats.hitCount
    stats.maxDuration = Math.max(stats.maxDuration, duration)
    stats.minDuration = Math.min(stats.minDuration, duration)
    stats.lastRowCount = rowCount
  }
}
```

---

## Milestone 7.2: ç›‘æ§ä½“ç³»æ­å»ºï¼ˆ1å¤©ï¼‰

### Day 2: ç›‘æ§ç³»ç»Ÿå®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. æŒ‡æ ‡æ”¶é›†å™¨
```typescript
// src/monitoring/MetricsCollector.ts
@Injectable()
export class MetricsCollector {
  private metrics = new Map<string, Metric>()
  private timers = new Map<string, Timer>()
  
  constructor(
    @Inject('MetricsExporter') private exporter: MetricsExporter,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.setupDefaultMetrics()
    this.startExportInterval()
  }
  
  private setupDefaultMetrics(): void {
    // ç³»ç»ŸæŒ‡æ ‡
    this.registerMetric('system.cpu.usage', MetricType.GAUGE)
    this.registerMetric('system.memory.usage', MetricType.GAUGE)
    this.registerMetric('system.disk.usage', MetricType.GAUGE)
    
    // åº”ç”¨æŒ‡æ ‡
    this.registerMetric('app.requests.total', MetricType.COUNTER)
    this.registerMetric('app.requests.duration', MetricType.HISTOGRAM)
    this.registerMetric('app.errors.total', MetricType.COUNTER)
    
    // ä¸šåŠ¡æŒ‡æ ‡
    this.registerMetric('business.tickets.created', MetricType.COUNTER)
    this.registerMetric('business.tickets.completed', MetricType.COUNTER)
    this.registerMetric('business.tickets.sla.breached', MetricType.COUNTER)
    this.registerMetric('business.inspections.completed', MetricType.COUNTER)
    this.registerMetric('business.anomalies.detected', MetricType.COUNTER)
    
    // æ€§èƒ½æŒ‡æ ‡
    this.registerMetric('performance.database.queries', MetricType.COUNTER)
    this.registerMetric('performance.database.latency', MetricType.HISTOGRAM)
    this.registerMetric('performance.cache.hits', MetricType.COUNTER)
    this.registerMetric('performance.cache.misses', MetricType.COUNTER)
  }
  
  registerMetric(
    name: string,
    type: MetricType,
    labels?: string[]
  ): void {
    this.metrics.set(name, {
      name,
      type,
      labels: labels || [],
      value: type === MetricType.COUNTER ? 0 : null,
      values: type === MetricType.HISTOGRAM ? [] : null
    })
  }
  
  // è®¡æ•°å™¨æ“ä½œ
  increment(name: string, value: number = 1, labels?: Record<string, string>): void {
    const metric = this.metrics.get(name)
    if (!metric || metric.type !== MetricType.COUNTER) {
      return
    }
    
    metric.value = (metric.value || 0) + value
    
    // å‘å¸ƒæŒ‡æ ‡äº‹ä»¶
    this.publishMetricEvent(name, value, labels)
  }
  
  // ä»ªè¡¨æ“ä½œ
  gauge(name: string, value: number, labels?: Record<string, string>): void {
    const metric = this.metrics.get(name)
    if (!metric || metric.type !== MetricType.GAUGE) {
      return
    }
    
    metric.value = value
    this.publishMetricEvent(name, value, labels)
  }
  
  // ç›´æ–¹å›¾æ“ä½œ
  histogram(name: string, value: number, labels?: Record<string, string>): void {
    const metric = this.metrics.get(name)
    if (!metric || metric.type !== MetricType.HISTOGRAM) {
      return
    }
    
    metric.values = metric.values || []
    metric.values.push(value)
    
    // ä¿ç•™æœ€è¿‘1000ä¸ªå€¼
    if (metric.values.length > 1000) {
      metric.values.shift()
    }
    
    this.publishMetricEvent(name, value, labels)
  }
  
  // è®¡æ—¶å™¨
  startTimer(name: string): () => void {
    const startTime = Date.now()
    const timerId = generateId()
    
    this.timers.set(timerId, {
      name,
      startTime
    })
    
    return () => {
      const timer = this.timers.get(timerId)
      if (timer) {
        const duration = Date.now() - timer.startTime
        this.histogram(name, duration)
        this.timers.delete(timerId)
      }
    }
  }
  
  // å¯¼å‡ºæŒ‡æ ‡
  private async exportMetrics(): Promise<void> {
    const snapshot = this.getSnapshot()
    
    try {
      await this.exporter.export(snapshot)
    } catch (error) {
      console.error('Failed to export metrics', error)
    }
  }
  
  private getSnapshot(): MetricsSnapshot {
    const snapshot: MetricsSnapshot = {
      timestamp: new Date(),
      metrics: []
    }
    
    this.metrics.forEach(metric => {
      if (metric.type === MetricType.HISTOGRAM && metric.values) {
        snapshot.metrics.push({
          name: metric.name,
          type: metric.type,
          value: this.calculateHistogramStats(metric.values)
        })
      } else {
        snapshot.metrics.push({
          name: metric.name,
          type: metric.type,
          value: metric.value
        })
      }
    })
    
    return snapshot
  }
  
  private calculateHistogramStats(values: number[]): HistogramStats {
    if (values.length === 0) {
      return { count: 0, sum: 0, avg: 0, min: 0, max: 0, p50: 0, p95: 0, p99: 0 }
    }
    
    const sorted = [...values].sort((a, b) => a - b)
    const sum = values.reduce((acc, val) => acc + val, 0)
    
    return {
      count: values.length,
      sum,
      avg: sum / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    }
  }
  
  private startExportInterval(): void {
    const interval = this.config.get('monitoring.exportInterval', 60000)
    
    setInterval(() => {
      this.exportMetrics()
    }, interval)
  }
  
  private publishMetricEvent(
    name: string,
    value: number,
    labels?: Record<string, string>
  ): void {
    // å¯ä»¥å‘å¸ƒåˆ°äº‹ä»¶æ€»çº¿ä¾›å®æ—¶ç›‘æ§ä½¿ç”¨
    process.nextTick(() => {
      this.eventBus?.emit('metric.recorded', {
        name,
        value,
        labels,
        timestamp: Date.now()
      })
    })
  }
}
```

#### 2. å¥åº·æ£€æŸ¥æœåŠ¡
```typescript
// src/monitoring/HealthCheckService.ts
@Injectable()
export class HealthCheckService {
  private checks = new Map<string, HealthCheck>()
  private status: HealthStatus = HealthStatus.UNKNOWN
  
  constructor(
    @Inject('Logger') private logger: Logger,
    @Inject('AlertingService') private alerting: AlertingService
  ) {
    this.registerDefaultChecks()
    this.startHealthChecks()
  }
  
  private registerDefaultChecks(): void {
    // æ•°æ®åº“å¥åº·æ£€æŸ¥
    this.register({
      name: 'database',
      check: async () => {
        const db = container.get('DatabaseConnection')
        await db.execute('SELECT 1')
        return { healthy: true }
      },
      critical: true,
      interval: 30000
    })
    
    // Rediså¥åº·æ£€æŸ¥
    this.register({
      name: 'redis',
      check: async () => {
        const redis = container.get('RedisClient')
        await redis.ping()
        return { healthy: true }
      },
      critical: false,
      interval: 30000
    })
    
    // å¤–éƒ¨APIå¥åº·æ£€æŸ¥
    this.register({
      name: 'external-api',
      check: async () => {
        const adapter = container.get('LegacyTicketSystemAdapter')
        const healthy = await adapter.healthCheck()
        return { healthy }
      },
      critical: false,
      interval: 60000
    })
    
    // ç£ç›˜ç©ºé—´æ£€æŸ¥
    this.register({
      name: 'disk-space',
      check: async () => {
        const stats = await this.checkDiskSpace()
        const healthy = stats.available > 1024 * 1024 * 1024 // 1GB
        return {
          healthy,
          details: {
            available: stats.available,
            used: stats.used,
            percentage: stats.percentage
          }
        }
      },
      critical: true,
      interval: 300000
    })
    
    // å†…å­˜ä½¿ç”¨æ£€æŸ¥
    this.register({
      name: 'memory',
      check: async () => {
        const usage = process.memoryUsage()
        const healthy = usage.heapUsed < 1024 * 1024 * 1024 // 1GB
        return {
          healthy,
          details: {
            heapUsed: usage.heapUsed,
            heapTotal: usage.heapTotal,
            rss: usage.rss
          }
        }
      },
      critical: false,
      interval: 60000
    })
  }
  
  register(check: HealthCheck): void {
    this.checks.set(check.name, check)
  }
  
  private async startHealthChecks(): Promise<void> {
    for (const [name, check] of this.checks) {
      this.scheduleCheck(name, check)
    }
  }
  
  private scheduleCheck(name: string, check: HealthCheck): void {
    const execute = async () => {
      try {
        const result = await check.check()
        
        if (!result.healthy) {
          this.handleUnhealthy(name, check, result)
        } else {
          this.handleHealthy(name)
        }
        
        // æ›´æ–°æ•´ä½“çŠ¶æ€
        this.updateOverallStatus()
      } catch (error) {
        this.handleCheckError(name, check, error)
      }
    }
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    execute()
    
    // å®šæœŸæ‰§è¡Œ
    setInterval(execute, check.interval)
  }
  
  private handleUnhealthy(
    name: string,
    check: HealthCheck,
    result: HealthCheckResult
  ): void {
    this.logger.warn(`Health check failed: ${name}`, result.details)
    
    if (check.critical) {
      this.status = HealthStatus.UNHEALTHY
      
      // å‘é€å‘Šè­¦
      this.alerting.sendAlert({
        severity: 'critical',
        title: `Critical service unhealthy: ${name}`,
        message: `Health check ${name} failed`,
        details: result.details
      })
    }
  }
  
  private handleHealthy(name: string): void {
    this.logger.debug(`Health check passed: ${name}`)
  }
  
  private handleCheckError(name: string, check: HealthCheck, error: Error): void {
    this.logger.error(`Health check error: ${name}`, error)
    
    if (check.critical) {
      this.status = HealthStatus.UNHEALTHY
    }
  }
  
  private updateOverallStatus(): void {
    let hasUnhealthy = false
    let hasCriticalUnhealthy = false
    
    for (const [name, check] of this.checks) {
      const lastResult = this.getLastResult(name)
      if (!lastResult?.healthy) {
        hasUnhealthy = true
        if (check.critical) {
          hasCriticalUnhealthy = true
        }
      }
    }
    
    if (hasCriticalUnhealthy) {
      this.status = HealthStatus.UNHEALTHY
    } else if (hasUnhealthy) {
      this.status = HealthStatus.DEGRADED
    } else {
      this.status = HealthStatus.HEALTHY
    }
  }
  
  getStatus(): HealthStatusReport {
    const checks: Record<string, HealthCheckResult> = {}
    
    for (const [name, check] of this.checks) {
      checks[name] = this.getLastResult(name) || { healthy: false }
    }
    
    return {
      status: this.status,
      timestamp: new Date(),
      checks
    }
  }
  
  private getLastResult(name: string): HealthCheckResult | null {
    // å®é™…åº”è¯¥å­˜å‚¨æœ€åçš„æ£€æŸ¥ç»“æœ
    return null
  }
  
  private async checkDiskSpace(): Promise<DiskStats> {
    // å®é™…å®ç°æ£€æŸ¥ç£ç›˜ç©ºé—´
    return {
      available: 10 * 1024 * 1024 * 1024,
      used: 50 * 1024 * 1024 * 1024,
      percentage: 83
    }
  }
}
```

---

## Milestone 7.3: æ—¥å¿—å’Œè¿½è¸ªç³»ç»Ÿï¼ˆ1å¤©ï¼‰

### Day 3: åˆ†å¸ƒå¼è¿½è¸ªå®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. è¿½è¸ªç³»ç»Ÿ
```typescript
// src/monitoring/TracingService.ts
@Injectable()
export class TracingService {
  private tracer: Tracer
  private activeSpans = new Map<string, Span>()
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('Logger') private logger: Logger
  ) {
    this.initializeTracer()
  }
  
  private initializeTracer(): void {
    this.tracer = new Tracer({
      serviceName: this.config.get('app.name'),
      sampler: {
        type: 'probabilistic',
        param: this.config.get('tracing.samplingRate', 0.1)
      },
      reporter: {
        endpoint: this.config.get('tracing.endpoint'),
        interval: 60000
      }
    })
  }
  
  startSpan(
    name: string,
    options?: SpanOptions
  ): Span {
    const parentSpan = options?.parent || this.getCurrentSpan()
    
    const span = this.tracer.startSpan(name, {
      childOf: parentSpan,
      tags: {
        ...options?.tags,
        'span.kind': options?.kind || 'internal'
      }
    })
    
    // å­˜å‚¨æ´»åŠ¨span
    const spanId = span.context().toSpanId()
    this.activeSpans.set(spanId, span)
    
    return span
  }
  
  finishSpan(span: Span, error?: Error): void {
    if (error) {
      span.setTag('error', true)
      span.log({
        event: 'error',
        message: error.message,
        stack: error.stack
      })
    }
    
    span.finish()
    
    // æ¸…ç†æ´»åŠ¨span
    const spanId = span.context().toSpanId()
    this.activeSpans.delete(spanId)
  }
  
  // è£…é¥°å™¨ï¼šè‡ªåŠ¨è¿½è¸ªæ–¹æ³•
  trace(name?: string) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
      const originalMethod = descriptor.value
      
      descriptor.value = async function(...args: any[]) {
        const spanName = name || `${target.constructor.name}.${propertyKey}`
        const span = this.tracingService.startSpan(spanName, {
          tags: {
            'component': target.constructor.name,
            'method': propertyKey
          }
        })
        
        try {
          const result = await originalMethod.apply(this, args)
          this.tracingService.finishSpan(span)
          return result
        } catch (error) {
          this.tracingService.finishSpan(span, error)
          throw error
        }
      }
      
      return descriptor
    }
  }
  
  // è¿½è¸ªHTTPè¯·æ±‚
  traceHttpRequest(req: Request, res: Response, next: NextFunction): void {
    const span = this.startSpan('http_request', {
      kind: 'server',
      tags: {
        'http.method': req.method,
        'http.url': req.url,
        'http.remote_addr': req.ip,
        'user.id': req.user?.id
      }
    })
    
    // æ³¨å…¥spanåˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
    req.span = span
    
    // ç›‘å¬å“åº”å®Œæˆ
    res.on('finish', () => {
      span.setTag('http.status_code', res.statusCode)
      
      if (res.statusCode >= 400) {
        span.setTag('error', true)
      }
      
      this.finishSpan(span)
    })
    
    next()
  }
  
  // è¿½è¸ªæ•°æ®åº“æŸ¥è¯¢
  traceDatabaseQuery(query: string, params?: any[]): Span {
    return this.startSpan('db_query', {
      kind: 'client',
      tags: {
        'db.type': 'mysql',
        'db.statement': query.substring(0, 100),
        'db.params_count': params?.length || 0
      }
    })
  }
  
  // è¿½è¸ªå¤–éƒ¨APIè°ƒç”¨
  traceExternalCall(url: string, method: string): Span {
    return this.startSpan('external_call', {
      kind: 'client',
      tags: {
        'http.url': url,
        'http.method': method,
        'peer.service': new URL(url).hostname
      }
    })
  }
  
  private getCurrentSpan(): Span | undefined {
    // ä»å¼‚æ­¥ä¸Šä¸‹æ–‡è·å–å½“å‰span
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨AsyncLocalStorage
    return undefined
  }
}
```

#### 2. ç»“æ„åŒ–æ—¥å¿—
```typescript
// src/monitoring/StructuredLogger.ts
@Injectable()
export class StructuredLogger {
  private transports: LogTransport[] = []
  private context: Map<string, any> = new Map()
  
  constructor(
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.initializeTransports()
  }
  
  private initializeTransports(): void {
    // æ§åˆ¶å°è¾“å‡º
    if (this.config.get('logging.console.enabled', true)) {
      this.transports.push(new ConsoleTransport({
        level: this.config.get('logging.console.level', 'info'),
        format: this.config.get('logging.console.format', 'json')
      }))
    }
    
    // æ–‡ä»¶è¾“å‡º
    if (this.config.get('logging.file.enabled', true)) {
      this.transports.push(new FileTransport({
        level: this.config.get('logging.file.level', 'info'),
        filename: this.config.get('logging.file.path', 'logs/app.log'),
        maxSize: this.config.get('logging.file.maxSize', '100m'),
        maxFiles: this.config.get('logging.file.maxFiles', 30)
      }))
    }
    
    // Elasticsearchè¾“å‡º
    if (this.config.get('logging.elasticsearch.enabled', false)) {
      this.transports.push(new ElasticsearchTransport({
        node: this.config.get('logging.elasticsearch.node'),
        index: this.config.get('logging.elasticsearch.index', 'logs')
      }))
    }
  }
  
  log(level: LogLevel, message: string, meta?: any): void {
    const logEntry: LogEntry = {
      timestamp: new Date(),
      level,
      message,
      ...this.enrichWithContext(meta)
    }
    
    // æ·»åŠ è¿½è¸ªä¿¡æ¯
    const span = this.getCurrentSpan()
    if (span) {
      logEntry.traceId = span.context().toTraceId()
      logEntry.spanId = span.context().toSpanId()
    }
    
    // å‘é€åˆ°æ‰€æœ‰ä¼ è¾“
    this.transports.forEach(transport => {
      if (this.shouldLog(level, transport.level)) {
        transport.log(logEntry)
      }
    })
  }
  
  info(message: string, meta?: any): void {
    this.log(LogLevel.INFO, message, meta)
  }
  
  warn(message: string, meta?: any): void {
    this.log(LogLevel.WARN, message, meta)
  }
  
  error(message: string, error?: Error, meta?: any): void {
    this.log(LogLevel.ERROR, message, {
      ...meta,
      error: {
        message: error?.message,
        stack: error?.stack,
        name: error?.name
      }
    })
  }
  
  debug(message: string, meta?: any): void {
    this.log(LogLevel.DEBUG, message, meta)
  }
  
  // å®¡è®¡æ—¥å¿—
  audit(action: string, meta: any): void {
    this.log(LogLevel.INFO, `AUDIT: ${action}`, {
      ...meta,
      audit: true,
      action
    })
  }
  
  // æ€§èƒ½æ—¥å¿—
  performance(operation: string, duration: number, meta?: any): void {
    this.log(LogLevel.INFO, `PERFORMANCE: ${operation}`, {
      ...meta,
      performance: true,
      operation,
      duration
    })
  }
  
  // å®‰å…¨æ—¥å¿—
  security(event: string, meta: any): void {
    this.log(LogLevel.WARN, `SECURITY: ${event}`, {
      ...meta,
      security: true,
      event
    })
  }
  
  // è®¾ç½®ä¸Šä¸‹æ–‡
  setContext(key: string, value: any): void {
    this.context.set(key, value)
  }
  
  clearContext(): void {
    this.context.clear()
  }
  
  private enrichWithContext(meta: any): any {
    const enriched = { ...meta }
    
    // æ·»åŠ å…¨å±€ä¸Šä¸‹æ–‡
    this.context.forEach((value, key) => {
      enriched[key] = value
    })
    
    // æ·»åŠ è¯·æ±‚ID
    enriched.requestId = this.getRequestId()
    
    // æ·»åŠ ç”¨æˆ·ä¿¡æ¯
    enriched.userId = this.getCurrentUserId()
    
    // æ·»åŠ ç¯å¢ƒä¿¡æ¯
    enriched.environment = this.config.get('app.env')
    enriched.hostname = os.hostname()
    enriched.pid = process.pid
    
    return enriched
  }
  
  private shouldLog(level: LogLevel, transportLevel: LogLevel): boolean {
    const levels = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR]
    return levels.indexOf(level) >= levels.indexOf(transportLevel)
  }
  
  private getCurrentSpan(): Span | undefined {
    // ä»è¿½è¸ªæœåŠ¡è·å–å½“å‰span
    return container.get('TracingService').getCurrentSpan()
  }
  
  private getRequestId(): string | undefined {
    // ä»å¼‚æ­¥ä¸Šä¸‹æ–‡è·å–è¯·æ±‚ID
    return undefined
  }
  
  private getCurrentUserId(): string | undefined {
    // ä»å¼‚æ­¥ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·ID
    return undefined
  }
}
```

## ğŸ“Š Phase 7 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] ç¼“å­˜å‘½ä¸­ç‡ > 80%
- [ ] P95å“åº”æ—¶é—´ < 200ms
- [ ] æ…¢æŸ¥è¯¢å æ¯” < 1%
- [ ] æŒ‡æ ‡æ”¶é›†è¦†ç›–ç‡ > 90%
- [ ] æ—¥å¿—ç»“æ„åŒ–ç‡ 100%

### åŠŸèƒ½éªŒè¯
- [ ] å¤šå±‚ç¼“å­˜æ­£å¸¸å·¥ä½œ
- [ ] æŸ¥è¯¢è‡ªåŠ¨ä¼˜åŒ–ç”Ÿæ•ˆ
- [ ] å¥åº·æ£€æŸ¥å‡†ç¡®
- [ ] å‘Šè­¦åŠæ—¶å‘é€
- [ ] è¿½è¸ªé“¾è·¯å®Œæ•´

### è¿ç»´æŒ‡æ ‡
- [ ] ç›‘æ§å¤§ç›˜å®Œæ•´
- [ ] æ—¥å¿—å¯æ£€ç´¢
- [ ] è¿½è¸ªå¯è§†åŒ–
- [ ] å‘Šè­¦è§„åˆ™åˆç†

---

## ğŸš€ Phase 7 äº¤ä»˜ç‰©

1. **æ€§èƒ½ä¼˜åŒ–**
   - CacheManagerå¤šå±‚ç¼“å­˜
   - QueryOptimizeræŸ¥è¯¢ä¼˜åŒ–
   - æ…¢æŸ¥è¯¢åˆ†æå·¥å…·

2. **ç›‘æ§ç³»ç»Ÿ**
   - MetricsCollectoræŒ‡æ ‡æ”¶é›†
   - HealthCheckServiceå¥åº·æ£€æŸ¥
   - AlertingServiceå‘Šè­¦æœåŠ¡

3. **æ—¥å¿—è¿½è¸ª**
   - TracingServiceåˆ†å¸ƒå¼è¿½è¸ª
   - StructuredLoggerç»“æ„åŒ–æ—¥å¿—
   - æ—¥å¿—èšåˆé…ç½®

4. **æ–‡æ¡£**
   - PERFORMANCE-TUNING.md
   - MONITORING-GUIDE.md
   - LOGGING-STANDARDS.md

---

## ğŸ“‹ åç»­é˜¶æ®µè§„åˆ’

### Phase 8: éƒ¨ç½²ä¸è¿ç»´ï¼ˆ3å¤©ï¼‰
**ç›®æ ‡**: å®ç°è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œè¿ç»´èƒ½åŠ›

**ä¸»è¦ä»»åŠ¡**:
- CI/CDæµæ°´çº¿æ­å»º
- å®¹å™¨åŒ–éƒ¨ç½²(Docker/K8s)
- è“ç»¿éƒ¨ç½²/é‡‘ä¸é›€å‘å¸ƒ
- è‡ªåŠ¨åŒ–è¿ç»´è„šæœ¬
- å¤‡ä»½æ¢å¤æœºåˆ¶

### Phase 9: å®‰å…¨åŠ å›ºï¼ˆ2å¤©ï¼‰
**ç›®æ ‡**: æå‡ç³»ç»Ÿå®‰å…¨æ€§

**ä¸»è¦ä»»åŠ¡**:
- èº«ä»½è®¤è¯å¢å¼º(OAuth2/JWT)
- æƒé™ç»†ç²’åº¦æ§åˆ¶(RBAC/ABAC)
- æ•°æ®åŠ å¯†(ä¼ è¾“/å­˜å‚¨)
- å®‰å…¨å®¡è®¡æ—¥å¿—
- æ¼æ´æ‰«æå’Œä¿®å¤

### Phase 10: æ–‡æ¡£ä¸åŸ¹è®­ï¼ˆ2å¤©ï¼‰
**ç›®æ ‡**: å®Œå–„æ–‡æ¡£å’ŒçŸ¥è¯†ä¼ æ‰¿

**ä¸»è¦ä»»åŠ¡**:
- æ¶æ„æ–‡æ¡£å®Œå–„
- APIæ–‡æ¡£ç”Ÿæˆ
- è¿ç»´æ‰‹å†Œç¼–å†™
- å¼€å‘è§„èŒƒåˆ¶å®š
- å›¢é˜ŸåŸ¹è®­è®¡åˆ’

### Phase 11: æ€§èƒ½å‹æµ‹ä¸ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰
**ç›®æ ‡**: éªŒè¯ç³»ç»Ÿæ€§èƒ½å¹¶ä¼˜åŒ–

**ä¸»è¦ä»»åŠ¡**:
- å‹åŠ›æµ‹è¯•æ–¹æ¡ˆè®¾è®¡
- æ€§èƒ½åŸºå‡†æµ‹è¯•
- ç“¶é¢ˆåˆ†æä¸ä¼˜åŒ–
- å®¹é‡è§„åˆ’
- æ€§èƒ½ç›‘æ§é¢„è­¦

### Phase 12: ç¾å¤‡ä¸é«˜å¯ç”¨ï¼ˆ3å¤©ï¼‰
**ç›®æ ‡**: æå‡ç³»ç»Ÿå¯é æ€§

**ä¸»è¦ä»»åŠ¡**:
- ä¸»ä»å¤åˆ¶é…ç½®
- æ•…éšœè‡ªåŠ¨åˆ‡æ¢
- æ•°æ®å¤‡ä»½ç­–ç•¥
- ç¾éš¾æ¢å¤æ¼”ç»ƒ
- SLAæŒ‡æ ‡åˆ¶å®š

## ğŸ¯ é•¿æœŸä¼˜åŒ–æ–¹å‘

### æŠ€æœ¯å€ºåŠ¡æ¸…ç†
- é—ç•™ä»£ç é€æ­¥æ›¿æ¢
- ä¾èµ–åŒ…å‡çº§ç®¡ç†
- ä»£ç è´¨é‡æŒç»­æ”¹è¿›
- æŠ€æœ¯æ ˆç»Ÿä¸€

### æ¶æ„æ¼”è¿›
- å¾®æœåŠ¡åŒ–è¯„ä¼°
- Serverlessæ¢ç´¢
- äº‹ä»¶æº¯æºå®æ–½
- CQRSæ¨¡å¼åº”ç”¨

### æ™ºèƒ½åŒ–æå‡
- æ™ºèƒ½å‘Šè­¦(å¼‚å¸¸æ£€æµ‹)
- è‡ªåŠ¨åŒ–è¿ç»´(AIOps)
- æ™ºèƒ½å·¥å•åˆ†é…
- é¢„æµ‹æ€§ç»´æŠ¤

### ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- å‰ç«¯æ€§èƒ½ä¼˜åŒ–
- ç§»åŠ¨ç«¯é€‚é…
- å®æ—¶åä½œåŠŸèƒ½
- ä¸ªæ€§åŒ–æ¨è

è¿™æ ·æ•´ä¸ªé‡æ„è®¡åˆ’å°±å®Œæ•´äº†ï¼Œä»åŸºç¡€è®¾æ–½åˆ°æ ¸å¿ƒä¸šåŠ¡ï¼Œå†åˆ°è¿ç»´ç›‘æ§ï¼Œå½¢æˆäº†å®Œæ•´çš„æŠ€æœ¯æ”¹é€ é—­ç¯ã€‚æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„ç›®æ ‡ã€ä»»åŠ¡å’Œäº¤ä»˜ç‰©ï¼Œä¾¿äºé¡¹ç›®ç®¡ç†å’Œè¿›åº¦è·Ÿè¸ªã€‚