## Phase 3: æ ¸å¿ƒä¸šåŠ¡æ¨¡å—é‡æ„ - å·¥å•ï¼ˆ7å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1-3**: Milestone 3.1 å·¥å•é¢†åŸŸæ¨¡å‹
- **Day 4-5**: Milestone 3.2 å·¥å•æœåŠ¡è§£è€¦  
- **Day 6-7**: Milestone 3.3 å·¥å•è§†å›¾ç˜¦èº«

---

## Milestone 3.1: å·¥å•é¢†åŸŸæ¨¡å‹ï¼ˆ3å¤©ï¼‰

### Day 1: é¢†åŸŸæ¨¡å‹è®¾è®¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. åˆ›å»ºå·¥å•å®ä½“å’Œå€¼å¯¹è±¡
```typescript
// src/domain/ticket/entities/Ticket.ts
export class Ticket {
  private _id: string
  private _title: string
  private _description: string
  private _status: TicketStatus
  private _priority: TicketPriority
  private _assigneeId?: string
  private _reporterId: string
  private _deadline: Date
  private _lastStatusTime: Date
  private _lastAction: string
  private _escalationCount: number = 0
  
  constructor(props: TicketProps) {
    this.validate(props)
    Object.assign(this, props)
  }
  
  // é¢†åŸŸè¡Œä¸º
  assign(assigneeId: string): void {
    if (this._status !== TicketStatus.PENDING) {
      throw new DomainError('åªèƒ½åˆ†é…å¾…å¤„ç†çš„å·¥å•')
    }
    this._assigneeId = assigneeId
    this._status = TicketStatus.ASSIGNED
    this.updateStatusTime('assign')
  }
  
  start(): void {
    if (this._status !== TicketStatus.ASSIGNED) {
      throw new DomainError('åªèƒ½å¼€å§‹å·²åˆ†é…çš„å·¥å•')
    }
    this._status = TicketStatus.PROCESSING
    this.updateStatusTime('start')
  }
  
  complete(resolution: string): void {
    if (this._status !== TicketStatus.PROCESSING) {
      throw new DomainError('åªèƒ½å®Œæˆå¤„ç†ä¸­çš„å·¥å•')
    }
    this._status = TicketStatus.COMPLETED
    this._resolution = resolution
    this.updateStatusTime('complete')
  }
  
  close(): void {
    if (this._status !== TicketStatus.COMPLETED) {
      throw new DomainError('åªèƒ½å…³é—­å·²å®Œæˆçš„å·¥å•')
    }
    this._status = TicketStatus.CLOSED
    this.updateStatusTime('close')
  }
  
  reopen(): void {
    if (this._status !== TicketStatus.CLOSED) {
      throw new DomainError('åªèƒ½é‡å¼€å·²å…³é—­çš„å·¥å•')
    }
    this._status = TicketStatus.PENDING
    this.updateStatusTime('reopen')
  }
  
  escalate(): void {
    const nextPriority = this.getNextPriority()
    if (nextPriority === this._priority) {
      throw new DomainError('å·¥å•å·²è¾¾æœ€é«˜ä¼˜å…ˆçº§')
    }
    this._priority = nextPriority
    this._escalationCount++
    this.updateStatusTime('escalate')
  }
  
  private updateStatusTime(action: string): void {
    this._lastStatusTime = new Date()
    this._lastAction = action
  }
  
  private getNextPriority(): TicketPriority {
    const priorities = [
      TicketPriority.LOW,
      TicketPriority.MEDIUM,
      TicketPriority.HIGH,
      TicketPriority.URGENT
    ]
    const currentIndex = priorities.indexOf(this._priority)
    return priorities[Math.min(currentIndex + 1, priorities.length - 1)]
  }
  
  private validate(props: TicketProps): void {
    if (!props.title || props.title.length < 3) {
      throw new ValidationError('å·¥å•æ ‡é¢˜è‡³å°‘3ä¸ªå­—ç¬¦')
    }
    if (!props.reporterId) {
      throw new ValidationError('å¿…é¡»æŒ‡å®šæŠ¥å‘Šäºº')
    }
  }
  
  // è®¡ç®—å±æ€§
  get isOverdue(): boolean {
    return this._deadline && new Date() > this._deadline
  }
  
  get isNearDue(): boolean {
    if (!this._deadline) return false
    const hoursUntilDue = (this._deadline.getTime() - Date.now()) / (1000 * 60 * 60)
    return hoursUntilDue > 0 && hoursUntilDue < 2
  }
  
  get canEscalate(): boolean {
    return this._priority !== TicketPriority.URGENT
  }
}
```

#### 2. åˆ›å»ºå€¼å¯¹è±¡
```typescript
// src/domain/ticket/value-objects/TicketStatus.ts
export enum TicketStatus {
  PENDING = 'pending',
  ASSIGNED = 'assigned',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  CLOSED = 'closed'
}

// src/domain/ticket/value-objects/TicketPriority.ts
export enum TicketPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

// src/domain/ticket/value-objects/SLA.ts
export class SLA {
  private static readonly HOURS_BY_PRIORITY = {
    [TicketPriority.LOW]: 48,
    [TicketPriority.MEDIUM]: 24,
    [TicketPriority.HIGH]: 12,
    [TicketPriority.URGENT]: 2
  }
  
  constructor(private priority: TicketPriority) {}
  
  get hours(): number {
    return SLA.HOURS_BY_PRIORITY[this.priority]
  }
  
  get deadline(): Date {
    const deadline = new Date()
    deadline.setHours(deadline.getHours() + this.hours)
    return deadline
  }
  
  calculateOverdueHours(createdAt: Date): number {
    const now = new Date()
    const deadline = new Date(createdAt)
    deadline.setHours(deadline.getHours() + this.hours)
    
    if (now <= deadline) return 0
    
    return (now.getTime() - deadline.getTime()) / (1000 * 60 * 60)
  }
}
```

### Day 2: çŠ¶æ€æœºå®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¥å•çŠ¶æ€æœº
```typescript
// src/domain/ticket/TicketStateMachine.ts
export interface StateTransition {
  from: TicketStatus
  to: TicketStatus
  action: string
  guard?: (ticket: Ticket) => boolean
  effect?: (ticket: Ticket) => void
}

export class TicketStateMachine {
  private transitions: StateTransition[] = [
    {
      from: TicketStatus.PENDING,
      to: TicketStatus.ASSIGNED,
      action: 'assign',
      guard: (ticket) => !!ticket.assigneeId,
      effect: (ticket) => ticket.notifyAssignee()
    },
    {
      from: TicketStatus.ASSIGNED,
      to: TicketStatus.PROCESSING,
      action: 'start',
      guard: (ticket) => ticket.assigneeId === getCurrentUserId()
    },
    {
      from: TicketStatus.PROCESSING,
      to: TicketStatus.COMPLETED,
      action: 'complete',
      guard: (ticket) => !!ticket.resolution
    },
    {
      from: TicketStatus.COMPLETED,
      to: TicketStatus.CLOSED,
      action: 'close'
    },
    {
      from: TicketStatus.CLOSED,
      to: TicketStatus.PENDING,
      action: 'reopen',
      effect: (ticket) => ticket.clearAssignee()
    }
  ]
  
  canTransition(ticket: Ticket, action: string): boolean {
    const transition = this.findTransition(ticket.status, action)
    if (!transition) return false
    
    if (transition.guard) {
      return transition.guard(ticket)
    }
    
    return true
  }
  
  transition(ticket: Ticket, action: string): void {
    const transition = this.findTransition(ticket.status, action)
    
    if (!transition) {
      throw new Error(`Invalid transition: ${action} from ${ticket.status}`)
    }
    
    if (transition.guard && !transition.guard(ticket)) {
      throw new Error(`Guard failed for transition: ${action}`)
    }
    
    // æ‰§è¡ŒçŠ¶æ€è½¬æ¢
    ticket.status = transition.to
    ticket.lastAction = action
    ticket.lastStatusTime = new Date()
    
    // æ‰§è¡Œå‰¯ä½œç”¨
    if (transition.effect) {
      transition.effect(ticket)
    }
  }
  
  private findTransition(from: TicketStatus, action: string): StateTransition | undefined {
    return this.transitions.find(t => t.from === from && t.action === action)
  }
  
  getAvailableActions(ticket: Ticket): string[] {
    return this.transitions
      .filter(t => t.from === ticket.status)
      .filter(t => !t.guard || t.guard(ticket))
      .map(t => t.action)
  }
}
```

#### 2. é¢†åŸŸäº‹ä»¶
```typescript
// src/domain/ticket/events/TicketEvents.ts
export abstract class DomainEvent {
  readonly occurredAt: Date = new Date()
  readonly aggregateId: string
  
  constructor(aggregateId: string) {
    this.aggregateId = aggregateId
  }
}

export class TicketCreated extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly title: string,
    public readonly priority: TicketPriority,
    public readonly reporterId: string
  ) {
    super(aggregateId)
  }
}

export class TicketAssigned extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly assigneeId: string,
    public readonly assignedBy: string
  ) {
    super(aggregateId)
  }
}

export class TicketEscalated extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly oldPriority: TicketPriority,
    public readonly newPriority: TicketPriority,
    public readonly reason: string
  ) {
    super(aggregateId)
  }
}

export class TicketCompleted extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly resolution: string,
    public readonly completedBy: string
  ) {
    super(aggregateId)
  }
}
```

### Day 3: é¢†åŸŸæœåŠ¡å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¥å•é¢†åŸŸæœåŠ¡
```typescript
// src/domain/ticket/TicketDomain.ts
@Injectable()
export class TicketDomain {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.stateMachine = new TicketStateMachine()
  }
  
  private stateMachine: TicketStateMachine
  
  async createTicket(dto: CreateTicketDto): Promise<Ticket> {
    // 1. åˆ›å»ºå®ä½“
    const ticket = new Ticket({
      title: dto.title,
      description: dto.description,
      priority: dto.priority || TicketPriority.MEDIUM,
      reporterId: dto.reporterId,
      status: TicketStatus.PENDING,
      deadline: new SLA(dto.priority).deadline
    })
    
    // 2. ä¸šåŠ¡è§„åˆ™éªŒè¯
    await this.validateBusinessRules(ticket)
    
    // 3. æŒä¹…åŒ–
    const saved = await this.repository.save(ticket)
    
    // 4. å‘å¸ƒé¢†åŸŸäº‹ä»¶
    this.eventBus.emit(new TicketCreated(
      saved.id,
      saved.title,
      saved.priority,
      saved.reporterId
    ))
    
    // 5. è®°å½•æ—¥å¿—
    this.logger.info('Ticket created', {
      ticketId: saved.id,
      title: saved.title,
      priority: saved.priority
    })
    
    return saved
  }
  
  async assignTicket(ticketId: string, assigneeId: string): Promise<void> {
    const ticket = await this.repository.findById(ticketId)
    
    if (!ticket) {
      throw new NotFoundError(`Ticket ${ticketId} not found`)
    }
    
    // ä½¿ç”¨çŠ¶æ€æœºéªŒè¯å’Œæ‰§è¡Œ
    if (!this.stateMachine.canTransition(ticket, 'assign')) {
      throw new DomainError('Cannot assign ticket in current state')
    }
    
    ticket.assign(assigneeId)
    await this.repository.update(ticket)
    
    this.eventBus.emit(new TicketAssigned(
      ticketId,
      assigneeId,
      getCurrentUserId()
    ))
  }
  
  async processTicket(ticketId: string, action: string, data?: any): Promise<void> {
    const ticket = await this.repository.findById(ticketId)
    
    if (!ticket) {
      throw new NotFoundError(`Ticket ${ticketId} not found`)
    }
    
    // çŠ¶æ€æœºå¤„ç†
    this.stateMachine.transition(ticket, action)
    
    // æŒä¹…åŒ–
    await this.repository.update(ticket)
    
    // å‘å¸ƒå¯¹åº”äº‹ä»¶
    this.publishActionEvent(ticket, action, data)
  }
  
  async escalateOverdueTickets(): Promise<void> {
    const overdueTickets = await this.repository.findOverdue()
    
    for (const ticket of overdueTickets) {
      if (ticket.canEscalate) {
        try {
          ticket.escalate()
          await this.repository.update(ticket)
          
          this.eventBus.emit(new TicketEscalated(
            ticket.id,
            ticket.previousPriority,
            ticket.priority,
            'Automatic escalation due to SLA breach'
          ))
        } catch (error) {
          this.logger.error('Failed to escalate ticket', {
            ticketId: ticket.id,
            error
          })
        }
      }
    }
  }
  
  async getTicketStatistics(): Promise<TicketStatistics> {
    const [byStatus, byPriority, todayStats] = await Promise.all([
      this.repository.countByStatus(),
      this.repository.countByPriority(),
      this.repository.getTodayStatistics()
    ])
    
    return {
      byStatus,
      byPriority,
      todayNew: todayStats.new,
      todayCompleted: todayStats.completed,
      overdue: await this.repository.countOverdue(),
      nearDue: await this.repository.countNearDue(2) // 2å°æ—¶å†…
    }
  }
  
  private async validateBusinessRules(ticket: Ticket): Promise<void> {
    // éªŒè¯æŠ¥å‘Šäººæƒé™
    const reporter = await this.repository.findUser(ticket.reporterId)
    if (!reporter || !reporter.canCreateTicket) {
      throw new DomainError('User cannot create tickets')
    }
    
    // éªŒè¯ä¼˜å…ˆçº§æƒé™
    if (ticket.priority === TicketPriority.URGENT && !reporter.isManager) {
      throw new DomainError('Only managers can create urgent tickets')
    }
    
    // æ£€æŸ¥é‡å¤å·¥å•
    const duplicate = await this.repository.findDuplicate(ticket.title)
    if (duplicate) {
      throw new DomainError(`Duplicate ticket found: ${duplicate.id}`)
    }
  }
  
  private publishActionEvent(ticket: Ticket, action: string, data: any): void {
    const eventMap = {
      'complete': () => new TicketCompleted(
        ticket.id,
        data.resolution,
        getCurrentUserId()
      ),
      'assign': () => new TicketAssigned(
        ticket.id,
        data.assigneeId,
        getCurrentUserId()
      )
    }
    
    const eventFactory = eventMap[action]
    if (eventFactory) {
      this.eventBus.emit(eventFactory())
    }
  }
}
```

---

## Milestone 3.2: å·¥å•æœåŠ¡è§£è€¦ï¼ˆ2å¤©ï¼‰

### Day 4: é‡æ„ticketEscalationæœåŠ¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. è§£è€¦å‡çº§æœåŠ¡
```typescript
// src/services/ticket/TicketEscalationService.ts
@Injectable()
export class TicketEscalationService {
  private timer: NodeJS.Timer | null = null
  private isRunning = false
  
  constructor(
    @Inject('TicketDomain') private domain: TicketDomain,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.setupEventListeners()
  }
  
  start(): void {
    if (this.isRunning) return
    
    const interval = this.config.get('business.ticket.escalation.checkInterval')
    
    this.timer = setInterval(() => {
      this.checkAndEscalate()
    }, interval)
    
    this.isRunning = true
    this.logger.info('Ticket escalation service started', { interval })
  }
  
  stop(): void {
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
    this.isRunning = false
    this.logger.info('Ticket escalation service stopped')
  }
  
  async checkAndEscalate(): Promise<void> {
    try {
      // å§”æ‰˜ç»™é¢†åŸŸæœåŠ¡
      await this.domain.escalateOverdueTickets()
      
      // å‘å¸ƒæœåŠ¡çº§äº‹ä»¶
      this.eventBus.emit('escalation.check.completed', {
        timestamp: new Date(),
        service: 'TicketEscalation'
      })
    } catch (error) {
      this.logger.error('Escalation check failed', error)
      
      this.eventBus.emit('escalation.check.failed', {
        error,
        timestamp: new Date()
      })
    }
  }
  
  private setupEventListeners(): void {
    // ç›‘å¬å·¥å•åˆ›å»ºäº‹ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³å‡çº§
    this.eventBus.on('ticket.created', async (event: TicketCreated) => {
      if (event.priority === TicketPriority.URGENT) {
        // ç´§æ€¥å·¥å•ç«‹å³é€šçŸ¥
        this.notifyUrgentTicket(event.aggregateId)
      }
    })
    
    // ç›‘å¬SLAå³å°†è¿è§„äº‹ä»¶
    this.eventBus.on('ticket.nearSLABreach', async (event) => {
      await this.handleNearSLABreach(event)
    })
  }
  
  private async notifyUrgentTicket(ticketId: string): Promise<void> {
    // é€šè¿‡äº‹ä»¶æ€»çº¿é€šçŸ¥ï¼Œè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨é€šçŸ¥æœåŠ¡
    this.eventBus.emit('notification.urgent', {
      type: 'urgent_ticket',
      ticketId,
      recipients: await this.getUrgentRecipients()
    })
  }
  
  private async handleNearSLABreach(event: any): Promise<void> {
    this.eventBus.emit('notification.warning', {
      type: 'sla_warning',
      ticketId: event.ticketId,
      hoursRemaining: event.hoursRemaining
    })
  }
  
  private async getUrgentRecipients(): Promise<string[]> {
    // ä»é…ç½®æˆ–repositoryè·å–ç´§æ€¥é€šçŸ¥æ¥æ”¶äºº
    return this.config.get('business.ticket.urgentRecipients', [])
  }
}
```

#### 2. åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
```typescript
// src/services/ticket/TicketEventHandler.ts
@Injectable()
export class TicketEventHandler {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('NotificationService') private notificationService: NotificationService,
    @Inject('AuditService') private auditService: AuditService,
    @Inject('EventBus') private eventBus: EventBus
  ) {
    this.registerHandlers()
  }
  
  private registerHandlers(): void {
    // å·¥å•åˆ›å»º
    this.eventBus.on('ticket.created', this.handleTicketCreated.bind(this))
    
    // å·¥å•åˆ†é…
    this.eventBus.on('ticket.assigned', this.handleTicketAssigned.bind(this))
    
    // å·¥å•å‡çº§
    this.eventBus.on('ticket.escalated', this.handleTicketEscalated.bind(this))
    
    // å·¥å•å®Œæˆ
    this.eventBus.on('ticket.completed', this.handleTicketCompleted.bind(this))
  }
  
  private async handleTicketCreated(event: TicketCreated): Promise<void> {
    // 1. è®°å½•å®¡è®¡æ—¥å¿—
    await this.auditService.log({
      action: 'TICKET_CREATED',
      entityId: event.aggregateId,
      entityType: 'Ticket',
      userId: event.reporterId,
      timestamp: event.occurredAt,
      details: {
        title: event.title,
        priority: event.priority
      }
    })
    
    // 2. å‘é€é€šçŸ¥
    if (event.priority === TicketPriority.URGENT) {
      await this.notificationService.sendUrgentTicketNotification(event.aggregateId)
    }
    
    // 3. æ›´æ–°ç»Ÿè®¡
    this.eventBus.emit('statistics.update', {
      type: 'ticket_created',
      data: event
    })
  }
  
  private async handleTicketAssigned(event: TicketAssigned): Promise<void> {
    // é€šçŸ¥è¢«åˆ†é…äºº
    await this.notificationService.notifyAssignee(
      event.assigneeId,
      event.aggregateId
    )
    
    // è®°å½•åˆ†é…å†å²
    await this.repository.saveAssignmentHistory({
      ticketId: event.aggregateId,
      assigneeId: event.assigneeId,
      assignedBy: event.assignedBy,
      assignedAt: event.occurredAt
    })
  }
  
  private async handleTicketEscalated(event: TicketEscalated): Promise<void> {
    // é€šçŸ¥ç®¡ç†å±‚
    const managers = await this.repository.findManagers()
    
    await this.notificationService.broadcast(managers, {
      type: 'ticket_escalated',
      ticketId: event.aggregateId,
      oldPriority: event.oldPriority,
      newPriority: event.newPriority,
      reason: event.reason
    })
    
    // è®°å½•å‡çº§å†å²
    await this.auditService.log({
      action: 'TICKET_ESCALATED',
      entityId: event.aggregateId,
      details: event
    })
  }
  
  private async handleTicketCompleted(event: TicketCompleted): Promise<void> {
    // è®¡ç®—å¤„ç†æ—¶é•¿
    const ticket = await this.repository.findById(event.aggregateId)
    const duration = event.occurredAt.getTime() - ticket.createdAt.getTime()
    
    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    await this.repository.updatePerformanceMetrics({
      ticketId: event.aggregateId,
      completedBy: event.completedBy,
      duration,
      resolution: event.resolution
    })
    
    // å‘é€æ»¡æ„åº¦è°ƒæŸ¥
    this.eventBus.emit('survey.send', {
      ticketId: event.aggregateId,
      reporterId: ticket.reporterId
    })
  }
}
```

### Day 5: å®ç°æœåŠ¡é€šä¿¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. äº‹ä»¶é©±åŠ¨çš„æœåŠ¡é€šä¿¡
```typescript
// src/services/core/ServiceOrchestrator.ts
@Injectable()
export class ServiceOrchestrator {
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.setupCrossServiceCommunication()
  }
  
  private setupCrossServiceCommunication(): void {
    // å·¡æ£€å¼‚å¸¸ -> å·¥å•åˆ›å»º
    this.eventBus.on('inspection.anomaly.detected', async (event) => {
      await this.createTicketFromAnomaly(event)
    })
    
    // ç»´ä¿åˆ°æœŸ -> å·¥å•åˆ›å»º
    this.eventBus.on('maintenance.due', async (event) => {
      await this.createMaintenanceTicket(event)
    })
    
    // å·¥å•å®Œæˆ -> æ›´æ–°ç›¸å…³å®ä½“
    this.eventBus.on('ticket.completed', async (event) => {
      await this.updateRelatedEntities(event)
    })
  }
  
  private async createTicketFromAnomaly(event: any): Promise<void> {
    const ticketDomain = container.get<TicketDomain>('TicketDomain')
    
    try {
      const ticket = await ticketDomain.createTicket({
        title: `[å·¡æ£€å¼‚å¸¸] ${event.floor} - ${event.item}`,
        description: event.description,
        priority: this.mapAnomalyToPriority(event.severity),
        reporterId: event.inspectorId,
        sourceType: 'inspection',
        sourceId: event.inspectionId
      })
      
      // é€šçŸ¥å·¡æ£€æœåŠ¡å·¥å•å·²åˆ›å»º
      this.eventBus.emit('ticket.created.from.inspection', {
        ticketId: ticket.id,
        inspectionId: event.inspectionId
      })
    } catch (error) {
      this.logger.error('Failed to create ticket from anomaly', error)
    }
  }
  
  private async createMaintenanceTicket(event: any): Promise<void> {
    const ticketDomain = container.get<TicketDomain>('TicketDomain')
    
    const ticket = await ticketDomain.createTicket({
      title: `[ç»´ä¿ä»»åŠ¡] ${event.planTitle}`,
      description: `ç»´ä¿è®¡åˆ’å³å°†åˆ°æœŸï¼š${event.dueDate}`,
      priority: TicketPriority.HIGH,
      reporterId: event.responsibleId,
      sourceType: 'maintenance',
      sourceId: event.planId
    })
    
    this.eventBus.emit('ticket.created.from.maintenance', {
      ticketId: ticket.id,
      maintenanceId: event.planId
    })
  }
  
  private async updateRelatedEntities(event: TicketCompleted): Promise<void> {
    const ticket = await container.get('TicketRepository').findById(event.aggregateId)
    
    if (ticket.sourceType === 'inspection') {
      this.eventBus.emit('inspection.ticket.completed', {
        inspectionId: ticket.sourceId,
        ticketId: ticket.id
      })
    } else if (ticket.sourceType === 'maintenance') {
      this.eventBus.emit('maintenance.ticket.completed', {
        maintenanceId: ticket.sourceId,
        ticketId: ticket.id
      })
    }
  }
  
  private mapAnomalyToPriority(severity: string): TicketPriority {
    const map = {
      'critical': TicketPriority.URGENT,
      'high': TicketPriority.HIGH,
      'medium': TicketPriority.MEDIUM,
      'low': TicketPriority.LOW
    }
    return map[severity] || TicketPriority.MEDIUM
  }
}
```

---

## Milestone 3.3: å·¥å•è§†å›¾ç˜¦èº«ï¼ˆ2å¤©ï¼‰

### Day 6: æ‹†åˆ†å·¥å•åˆ—è¡¨ç»„ä»¶ï¼ˆ8å°æ—¶ï¼‰

#### 1. ä¸»åˆ—è¡¨ç»„ä»¶ç˜¦èº«
```vue
<!-- src/views/business/ticket/index.vue (ç˜¦èº«å <300è¡Œ) -->
<template>
  <div class="app-container">
    <!-- æœç´¢æ  -->
    <TicketSearch 
      v-model="queryParams"
      @search="handleSearch"
      @reset="handleReset"
    />
    
    <!-- å·¥å…·æ  -->
    <TicketToolbar
      :selected-ids="selectedIds"
      @create="handleCreate"
      @batch-assign="handleBatchAssign"
      @export="handleExport"
    />
    
    <!-- æ•°æ®è¡¨æ ¼ -->
    <TicketTable
      :loading="loading"
      :data="ticketList"
      :total="total"
      v-model:page="queryParams.pageNum"
      v-model:page-size="queryParams.pageSize"
      @sort-change="handleSort"
      @selection-change="handleSelectionChange"
      @row-action="handleRowAction"
    />
  </div>
</template>

<script setup lang="ts" name="TicketList">
import { useTicketList } from '@/composables/useTicketList'
import TicketSearch from './components/TicketSearch.vue'
import TicketToolbar from './components/TicketToolbar.vue'
import TicketTable from './components/TicketTable.vue'

// ä½¿ç”¨ç»„åˆå¼å‡½æ•°ç®¡ç†ä¸šåŠ¡é€»è¾‘
const {
  loading,
  ticketList,
  total,
  queryParams,
  selectedIds,
  handleSearch,
  handleReset,
  handleCreate,
  handleBatchAssign,
  handleExport,
  handleSort,
  handleSelectionChange,
  handleRowAction
} = useTicketList()
</script>
```

#### 2. æŠ½å–ç»„åˆå¼å‡½æ•°
```typescript
// src/composables/useTicketList.ts
export function useTicketList() {
  // ä¾èµ–æ³¨å…¥
  const ticketService = FeatureFlags.isEnabled('USE_NEW_TICKET') 
    ? container.get('TicketDomain')
    : legacyTicketService
    
  const eventBus = container.get('EventBus')
  const router = useRouter()
  const { proxy } = getCurrentInstance()
  
  // çŠ¶æ€ç®¡ç†
  const store = useTicketStore()
  const { ticketList, total, loading } = storeToRefs(store)
  
  // æŸ¥è¯¢å‚æ•°
  const queryParams = ref({
    pageNum: 1,
    pageSize: 20,
    title: '',
    status: '',
    priority: '',
    assigneeId: ''
  })
  
  // é€‰ä¸­é¡¹
  const selectedIds = ref<string[]>([])
  
  // æ•°æ®åŠ è½½
  const loadData = async () => {
    await store.fetchList(queryParams.value)
  }
  
  // æœç´¢å¤„ç†
  const handleSearch = () => {
    queryParams.value.pageNum = 1
    loadData()
  }
  
  // é‡ç½®å¤„ç†
  const handleReset = () => {
    queryParams.value = {
      pageNum: 1,
      pageSize: 20,
      title: '',
      status: '',
      priority: '',
      assigneeId: ''
    }
    loadData()
  }
  
  // åˆ›å»ºå·¥å•
  const handleCreate = () => {
    router.push('/business/ticket/create')
  }
  
  // æ‰¹é‡åˆ†é…
  const handleBatchAssign = async (assigneeId: string) => {
    if (selectedIds.value.length === 0) {
      proxy.$modal.msgWarning('è¯·é€‰æ‹©è¦åˆ†é…çš„å·¥å•')
      return
    }
    
    try {
      await store.batchAssign(selectedIds.value, assigneeId)
      proxy.$modal.msgSuccess('æ‰¹é‡åˆ†é…æˆåŠŸ')
      
      // å‘å¸ƒäº‹ä»¶
      eventBus.emit('tickets.batch.assigned', {
        ticketIds: selectedIds.value,
        assigneeId
      })
      
      loadData()
    } catch (error) {
      proxy.$modal.msgError('æ‰¹é‡åˆ†é…å¤±è´¥')
    }
  }
  
  // å¯¼å‡º
  const handleExport = async () => {
    await store.exportTickets(queryParams.value)
  }
  
  // æ’åº
  const handleSort = ({ prop, order }) => {
    queryParams.value.orderByColumn = prop
    queryParams.value.isAsc = order === 'ascending' ? 'asc' : 'desc'
    loadData()
  }
  
  // é€‰æ‹©å˜åŒ–
  const handleSelectionChange = (selection: Ticket[]) => {
    selectedIds.value = selection.map(item => item.id)
  }
  
  // è¡Œæ“ä½œ
  const handleRowAction = ({ action, row }) => {
    switch (action) {
      case 'view':
        router.push(`/business/ticket/detail/${row.id}`)
        break
      case 'edit':
        router.push(`/business/ticket/edit/${row.id}`)
        break
      case 'delete':
        handleDelete(row)
        break
      case 'assign':
        handleAssign(row)
        break
    }
  }
  
  // ç”Ÿå‘½å‘¨æœŸ
  onMounted(() => {
    loadData()
    
    // ç›‘å¬äº‹ä»¶
    eventBus.on('ticket.created', loadData)
    eventBus.on('ticket.updated', loadData)
  })
  
  onUnmounted(() => {
    eventBus.off('ticket.created', loadData)
    eventBus.off('ticket.updated', loadData)
  })
  
  return {
    loading,
    ticketList,
    total,
    queryParams,
    selectedIds,
    handleSearch,
    handleReset,
    handleCreate,
    handleBatchAssign,
    handleExport,
    handleSort,
    handleSelectionChange,
    handleRowAction
  }
}
```

### Day 7: åˆ›å»ºå¯å¤ç”¨ç»„ä»¶ï¼ˆ8å°æ—¶ï¼‰

#### 1. æœç´¢ç»„ä»¶
```vue
<!-- src/views/business/ticket/components/TicketSearch.vue -->
<template>
  <el-form :model="modelValue" ref="queryRef" :inline="true" v-show="showSearch">
    <el-form-item label="æ ‡é¢˜" prop="title">
      <el-input
        v-model="modelValue.title"
        placeholder="è¯·è¾“å…¥å·¥å•æ ‡é¢˜"
        clearable
        @keyup.enter="handleSearch"
      />
    </el-form-item>
    
    <el-form-item label="çŠ¶æ€" prop="status">
      <el-select v-model="modelValue.status" placeholder="è¯·é€‰æ‹©çŠ¶æ€" clearable>
        <el-option
          v-for="status in ticketStatuses"
          :key="status.value"
          :label="status.label"
          :value="status.value"
        />
      </el-select>
    </el-form-item>
    
    <el-form-item label="ä¼˜å…ˆçº§" prop="priority">
      <el-select v-model="modelValue.priority" placeholder="è¯·é€‰æ‹©ä¼˜å…ˆçº§" clearable>
        <el-option
          v-for="priority in ticketPriorities"
          :key="priority.value"
          :label="priority.label"
          :value="priority.value"
        />
      </el-select>
    </el-form-item>
    
    <el-form-item>
      <el-button type="primary" icon="Search" @click="handleSearch">æœç´¢</el-button>
      <el-button icon="Refresh" @click="handleReset">é‡ç½®</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup lang="ts">
import { ticketStatuses, ticketPriorities } from '@/constants/ticket'

const props = defineProps<{
  modelValue: any
}>()

const emit = defineEmits<{
  'update:modelValue': [value: any]
  'search': []
  'reset': []
}>()

const showSearch = ref(true)
const queryRef = ref()

const handleSearch = () => {
  emit('search')
}

const handleReset = () => {
  queryRef.value?.resetFields()
  emit('reset')
}
</script>
```

#### 2. è¡¨æ ¼ç»„ä»¶
```vue
<!-- src/views/business/ticket/components/TicketTable.vue -->
<template>
  <div>
    <el-table
      v-loading="loading"
      :data="data"
      @selection-change="handleSelectionChange"
      @sort-change="handleSortChange"
    >
      <el-table-column type="selection" width="55" align="center" />
      <el-table-column label="å·¥å•ç¼–å·" align="center" prop="ticketNo" sortable="custom" />
      <el-table-column label="æ ‡é¢˜" align="center" prop="title" :show-overflow-tooltip="true" />
      
      <el-table-column label="çŠ¶æ€" align="center" prop="status">
        <template #default="scope">
          <TicketStatusTag :status="scope.row.status" />
        </template>
      </el-table-column>
      
      <el-table-column label="ä¼˜å…ˆçº§" align="center" prop="priority" sortable="custom">
        <template #default="scope">
          <TicketPriorityTag :priority="scope.row.priority" />
        </template>
      </el-table-column>
      
      <el-table-column label="å¤„ç†äºº" align="center" prop="assigneeName" />
      <el-table-column label="åˆ›å»ºæ—¶é—´" align="center" prop="createTime" sortable="custom" width="180">
        <template #default="scope">
          <span>{{ parseTime(scope.row.createTime) }}</span>
        </template>
      </el-table-column>
      
      <el-table-column label="æ“ä½œ" align="center" class-name="small-padding fixed-width">
        <template #default="scope">
          <TicketActions 
            :ticket="scope.row"
            @action="handleAction($event, scope.row)"
          />
        </template>
      </el-table-column>
    </el-table>
    
    <pagination
      v-show="total > 0"
      :total="total"
      v-model:page="currentPage"
      v-model:limit="pageSize"
      @pagination="handlePagination"
    />
  </div>
</template>

<script setup lang="ts">
import { parseTime } from '@/utils/ruoyi'
import TicketStatusTag from './TicketStatusTag.vue'
import TicketPriorityTag from './TicketPriorityTag.vue'
import TicketActions from './TicketActions.vue'

const props = defineProps<{
  loading: boolean
  data: any[]
  total: number
  page: number
  pageSize: number
}>()

const emit = defineEmits<{
  'update:page': [value: number]
  'update:pageSize': [value: number]
  'sort-change': [value: any]
  'selection-change': [value: any[]]
  'row-action': [value: { action: string; row: any }]
}>()

const currentPage = computed({
  get: () => props.page,
  set: (val) => emit('update:page', val)
})

const pageSize = computed({
  get: () => props.pageSize,
  set: (val) => emit('update:pageSize', val)
})

const handleSelectionChange = (selection: any[]) => {
  emit('selection-change', selection)
}

const handleSortChange = (sort: any) => {
  emit('sort-change', sort)
}

const handleAction = (action: string, row: any) => {
  emit('row-action', { action, row })
}

const handlePagination = () => {
  // åˆ†é¡µç»„ä»¶ä¼šè‡ªåŠ¨æ›´æ–°currentPageå’ŒpageSize
}
</script>
```

## ğŸ“Š Phase 3 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] å•ä¸ªæ–‡ä»¶ä¸è¶…è¿‡300è¡Œ
- [ ] åœˆå¤æ‚åº¦ä¸è¶…è¿‡10
- [ ] é¢†åŸŸæ¨¡å‹æµ‹è¯•è¦†ç›–ç‡ > 90%
- [ ] æœåŠ¡å±‚æµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] æ— ç›´æ¥APIè°ƒç”¨

### åŠŸèƒ½éªŒè¯
- [ ] å·¥å•çŠ¶æ€æœºæ­£å¸¸å·¥ä½œ
- [ ] äº‹ä»¶é©±åŠ¨é€šä¿¡æ­£å¸¸
- [ ] é¢†åŸŸè§„åˆ™éªŒè¯ç”Ÿæ•ˆ
- [ ] è‡ªåŠ¨å‡çº§åŠŸèƒ½æ­£å¸¸
- [ ] æ‰¹é‡æ“ä½œåŠŸèƒ½æ­£å¸¸

### æ€§èƒ½æŒ‡æ ‡
- [ ] åˆ—è¡¨åŠ è½½æ—¶é—´ < 500ms
- [ ] çŠ¶æ€è½¬æ¢å“åº” < 100ms
- [ ] äº‹ä»¶å¤„ç†å»¶è¿Ÿ < 50ms

## ğŸš€ Phase 3 äº¤ä»˜ç‰©

1. **é¢†åŸŸæ¨¡å‹**
   - Ticketå®ä½“
   - TicketStateMachine
   - TicketDomainæœåŠ¡
   - é¢†åŸŸäº‹ä»¶å®šä¹‰

2. **æœåŠ¡å±‚**
   - TicketEscalationServiceï¼ˆè§£è€¦ç‰ˆï¼‰
   - TicketEventHandler
   - ServiceOrchestrator

3. **è§†å›¾ç»„ä»¶**
   - ç˜¦èº«åçš„index.vue (<300è¡Œ)
   - å¯å¤ç”¨ç»„ä»¶åº“
   - ç»„åˆå¼å‡½æ•°

4. **æµ‹è¯•æ–‡ä»¶**
   - é¢†åŸŸæ¨¡å‹å•å…ƒæµ‹è¯•
   - çŠ¶æ€æœºæµ‹è¯•
   - æœåŠ¡é›†æˆæµ‹è¯•

5. **æ–‡æ¡£**
   - TICKET-DOMAIN.md
   - STATE-MACHINE.md
   - EVENT-DRIVEN.md

è¿™å°±æ˜¯Phase 3çš„å®Œæ•´å®æ–½æ–¹æ¡ˆï¼Œé‡ç‚¹æ˜¯å»ºç«‹å·¥å•çš„é¢†åŸŸæ¨¡å‹ã€å®ç°çŠ¶æ€æœºã€è§£è€¦æœåŠ¡é€šä¿¡ï¼Œå¹¶å°†è§†å›¾å±‚ç˜¦èº«åˆ°åˆç†èŒƒå›´ã€‚