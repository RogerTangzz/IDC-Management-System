## Phase 3: 核心业务模块重构 - 工单（7天）

### 📅 时间安排
- **Day 1-3**: Milestone 3.1 工单领域模型
- **Day 4-5**: Milestone 3.2 工单服务解耦  
- **Day 6-7**: Milestone 3.3 工单视图瘦身

---

## Milestone 3.1: 工单领域模型（3天）

### Day 1: 领域模型设计（8小时）

#### 1. 创建工单实体和值对象
```typescript
// src/domain/ticket/entities/Ticket.ts
export class Ticket {
  private _id: string
  private _title: string
  private _description: string
  private _status: TicketStatus
  private _priority: TicketPriority
  private _assigneeId?: string
  private _reporterId: string
  private _deadline: Date
  private _lastStatusTime: Date
  private _lastAction: string
  private _escalationCount: number = 0
  
  constructor(props: TicketProps) {
    this.validate(props)
    Object.assign(this, props)
  }
  
  // 领域行为
  assign(assigneeId: string): void {
    if (this._status !== TicketStatus.PENDING) {
      throw new DomainError('只能分配待处理的工单')
    }
    this._assigneeId = assigneeId
    this._status = TicketStatus.ASSIGNED
    this.updateStatusTime('assign')
  }
  
  start(): void {
    if (this._status !== TicketStatus.ASSIGNED) {
      throw new DomainError('只能开始已分配的工单')
    }
    this._status = TicketStatus.PROCESSING
    this.updateStatusTime('start')
  }
  
  complete(resolution: string): void {
    if (this._status !== TicketStatus.PROCESSING) {
      throw new DomainError('只能完成处理中的工单')
    }
    this._status = TicketStatus.COMPLETED
    this._resolution = resolution
    this.updateStatusTime('complete')
  }
  
  close(): void {
    if (this._status !== TicketStatus.COMPLETED) {
      throw new DomainError('只能关闭已完成的工单')
    }
    this._status = TicketStatus.CLOSED
    this.updateStatusTime('close')
  }
  
  reopen(): void {
    if (this._status !== TicketStatus.CLOSED) {
      throw new DomainError('只能重开已关闭的工单')
    }
    this._status = TicketStatus.PENDING
    this.updateStatusTime('reopen')
  }
  
  escalate(): void {
    const nextPriority = this.getNextPriority()
    if (nextPriority === this._priority) {
      throw new DomainError('工单已达最高优先级')
    }
    this._priority = nextPriority
    this._escalationCount++
    this.updateStatusTime('escalate')
  }
  
  private updateStatusTime(action: string): void {
    this._lastStatusTime = new Date()
    this._lastAction = action
  }
  
  private getNextPriority(): TicketPriority {
    const priorities = [
      TicketPriority.LOW,
      TicketPriority.MEDIUM,
      TicketPriority.HIGH,
      TicketPriority.URGENT
    ]
    const currentIndex = priorities.indexOf(this._priority)
    return priorities[Math.min(currentIndex + 1, priorities.length - 1)]
  }
  
  private validate(props: TicketProps): void {
    if (!props.title || props.title.length < 3) {
      throw new ValidationError('工单标题至少3个字符')
    }
    if (!props.reporterId) {
      throw new ValidationError('必须指定报告人')
    }
  }
  
  // 计算属性
  get isOverdue(): boolean {
    return this._deadline && new Date() > this._deadline
  }
  
  get isNearDue(): boolean {
    if (!this._deadline) return false
    const hoursUntilDue = (this._deadline.getTime() - Date.now()) / (1000 * 60 * 60)
    return hoursUntilDue > 0 && hoursUntilDue < 2
  }
  
  get canEscalate(): boolean {
    return this._priority !== TicketPriority.URGENT
  }
}
```

#### 2. 创建值对象
```typescript
// src/domain/ticket/value-objects/TicketStatus.ts
export enum TicketStatus {
  PENDING = 'pending',
  ASSIGNED = 'assigned',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  CLOSED = 'closed'
}

// src/domain/ticket/value-objects/TicketPriority.ts
export enum TicketPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

// src/domain/ticket/value-objects/SLA.ts
export class SLA {
  private static readonly HOURS_BY_PRIORITY = {
    [TicketPriority.LOW]: 48,
    [TicketPriority.MEDIUM]: 24,
    [TicketPriority.HIGH]: 12,
    [TicketPriority.URGENT]: 2
  }
  
  constructor(private priority: TicketPriority) {}
  
  get hours(): number {
    return SLA.HOURS_BY_PRIORITY[this.priority]
  }
  
  get deadline(): Date {
    const deadline = new Date()
    deadline.setHours(deadline.getHours() + this.hours)
    return deadline
  }
  
  calculateOverdueHours(createdAt: Date): number {
    const now = new Date()
    const deadline = new Date(createdAt)
    deadline.setHours(deadline.getHours() + this.hours)
    
    if (now <= deadline) return 0
    
    return (now.getTime() - deadline.getTime()) / (1000 * 60 * 60)
  }
}
```

### Day 2: 状态机实现（8小时）

#### 1. 工单状态机
```typescript
// src/domain/ticket/TicketStateMachine.ts
export interface StateTransition {
  from: TicketStatus
  to: TicketStatus
  action: string
  guard?: (ticket: Ticket) => boolean
  effect?: (ticket: Ticket) => void
}

export class TicketStateMachine {
  private transitions: StateTransition[] = [
    {
      from: TicketStatus.PENDING,
      to: TicketStatus.ASSIGNED,
      action: 'assign',
      guard: (ticket) => !!ticket.assigneeId,
      effect: (ticket) => ticket.notifyAssignee()
    },
    {
      from: TicketStatus.ASSIGNED,
      to: TicketStatus.PROCESSING,
      action: 'start',
      guard: (ticket) => ticket.assigneeId === getCurrentUserId()
    },
    {
      from: TicketStatus.PROCESSING,
      to: TicketStatus.COMPLETED,
      action: 'complete',
      guard: (ticket) => !!ticket.resolution
    },
    {
      from: TicketStatus.COMPLETED,
      to: TicketStatus.CLOSED,
      action: 'close'
    },
    {
      from: TicketStatus.CLOSED,
      to: TicketStatus.PENDING,
      action: 'reopen',
      effect: (ticket) => ticket.clearAssignee()
    }
  ]
  
  canTransition(ticket: Ticket, action: string): boolean {
    const transition = this.findTransition(ticket.status, action)
    if (!transition) return false
    
    if (transition.guard) {
      return transition.guard(ticket)
    }
    
    return true
  }
  
  transition(ticket: Ticket, action: string): void {
    const transition = this.findTransition(ticket.status, action)
    
    if (!transition) {
      throw new Error(`Invalid transition: ${action} from ${ticket.status}`)
    }
    
    if (transition.guard && !transition.guard(ticket)) {
      throw new Error(`Guard failed for transition: ${action}`)
    }
    
    // 执行状态转换
    ticket.status = transition.to
    ticket.lastAction = action
    ticket.lastStatusTime = new Date()
    
    // 执行副作用
    if (transition.effect) {
      transition.effect(ticket)
    }
  }
  
  private findTransition(from: TicketStatus, action: string): StateTransition | undefined {
    return this.transitions.find(t => t.from === from && t.action === action)
  }
  
  getAvailableActions(ticket: Ticket): string[] {
    return this.transitions
      .filter(t => t.from === ticket.status)
      .filter(t => !t.guard || t.guard(ticket))
      .map(t => t.action)
  }
}
```

#### 2. 领域事件
```typescript
// src/domain/ticket/events/TicketEvents.ts
export abstract class DomainEvent {
  readonly occurredAt: Date = new Date()
  readonly aggregateId: string
  
  constructor(aggregateId: string) {
    this.aggregateId = aggregateId
  }
}

export class TicketCreated extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly title: string,
    public readonly priority: TicketPriority,
    public readonly reporterId: string
  ) {
    super(aggregateId)
  }
}

export class TicketAssigned extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly assigneeId: string,
    public readonly assignedBy: string
  ) {
    super(aggregateId)
  }
}

export class TicketEscalated extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly oldPriority: TicketPriority,
    public readonly newPriority: TicketPriority,
    public readonly reason: string
  ) {
    super(aggregateId)
  }
}

export class TicketCompleted extends DomainEvent {
  constructor(
    aggregateId: string,
    public readonly resolution: string,
    public readonly completedBy: string
  ) {
    super(aggregateId)
  }
}
```

### Day 3: 领域服务实现（8小时）

#### 1. 工单领域服务
```typescript
// src/domain/ticket/TicketDomain.ts
@Injectable()
export class TicketDomain {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.stateMachine = new TicketStateMachine()
  }
  
  private stateMachine: TicketStateMachine
  
  async createTicket(dto: CreateTicketDto): Promise<Ticket> {
    // 1. 创建实体
    const ticket = new Ticket({
      title: dto.title,
      description: dto.description,
      priority: dto.priority || TicketPriority.MEDIUM,
      reporterId: dto.reporterId,
      status: TicketStatus.PENDING,
      deadline: new SLA(dto.priority).deadline
    })
    
    // 2. 业务规则验证
    await this.validateBusinessRules(ticket)
    
    // 3. 持久化
    const saved = await this.repository.save(ticket)
    
    // 4. 发布领域事件
    this.eventBus.emit(new TicketCreated(
      saved.id,
      saved.title,
      saved.priority,
      saved.reporterId
    ))
    
    // 5. 记录日志
    this.logger.info('Ticket created', {
      ticketId: saved.id,
      title: saved.title,
      priority: saved.priority
    })
    
    return saved
  }
  
  async assignTicket(ticketId: string, assigneeId: string): Promise<void> {
    const ticket = await this.repository.findById(ticketId)
    
    if (!ticket) {
      throw new NotFoundError(`Ticket ${ticketId} not found`)
    }
    
    // 使用状态机验证和执行
    if (!this.stateMachine.canTransition(ticket, 'assign')) {
      throw new DomainError('Cannot assign ticket in current state')
    }
    
    ticket.assign(assigneeId)
    await this.repository.update(ticket)
    
    this.eventBus.emit(new TicketAssigned(
      ticketId,
      assigneeId,
      getCurrentUserId()
    ))
  }
  
  async processTicket(ticketId: string, action: string, data?: any): Promise<void> {
    const ticket = await this.repository.findById(ticketId)
    
    if (!ticket) {
      throw new NotFoundError(`Ticket ${ticketId} not found`)
    }
    
    // 状态机处理
    this.stateMachine.transition(ticket, action)
    
    // 持久化
    await this.repository.update(ticket)
    
    // 发布对应事件
    this.publishActionEvent(ticket, action, data)
  }
  
  async escalateOverdueTickets(): Promise<void> {
    const overdueTickets = await this.repository.findOverdue()
    
    for (const ticket of overdueTickets) {
      if (ticket.canEscalate) {
        try {
          ticket.escalate()
          await this.repository.update(ticket)
          
          this.eventBus.emit(new TicketEscalated(
            ticket.id,
            ticket.previousPriority,
            ticket.priority,
            'Automatic escalation due to SLA breach'
          ))
        } catch (error) {
          this.logger.error('Failed to escalate ticket', {
            ticketId: ticket.id,
            error
          })
        }
      }
    }
  }
  
  async getTicketStatistics(): Promise<TicketStatistics> {
    const [byStatus, byPriority, todayStats] = await Promise.all([
      this.repository.countByStatus(),
      this.repository.countByPriority(),
      this.repository.getTodayStatistics()
    ])
    
    return {
      byStatus,
      byPriority,
      todayNew: todayStats.new,
      todayCompleted: todayStats.completed,
      overdue: await this.repository.countOverdue(),
      nearDue: await this.repository.countNearDue(2) // 2小时内
    }
  }
  
  private async validateBusinessRules(ticket: Ticket): Promise<void> {
    // 验证报告人权限
    const reporter = await this.repository.findUser(ticket.reporterId)
    if (!reporter || !reporter.canCreateTicket) {
      throw new DomainError('User cannot create tickets')
    }
    
    // 验证优先级权限
    if (ticket.priority === TicketPriority.URGENT && !reporter.isManager) {
      throw new DomainError('Only managers can create urgent tickets')
    }
    
    // 检查重复工单
    const duplicate = await this.repository.findDuplicate(ticket.title)
    if (duplicate) {
      throw new DomainError(`Duplicate ticket found: ${duplicate.id}`)
    }
  }
  
  private publishActionEvent(ticket: Ticket, action: string, data: any): void {
    const eventMap = {
      'complete': () => new TicketCompleted(
        ticket.id,
        data.resolution,
        getCurrentUserId()
      ),
      'assign': () => new TicketAssigned(
        ticket.id,
        data.assigneeId,
        getCurrentUserId()
      )
    }
    
    const eventFactory = eventMap[action]
    if (eventFactory) {
      this.eventBus.emit(eventFactory())
    }
  }
}
```

---

## Milestone 3.2: 工单服务解耦（2天）

### Day 4: 重构ticketEscalation服务（8小时）

#### 1. 解耦升级服务
```typescript
// src/services/ticket/TicketEscalationService.ts
@Injectable()
export class TicketEscalationService {
  private timer: NodeJS.Timer | null = null
  private isRunning = false
  
  constructor(
    @Inject('TicketDomain') private domain: TicketDomain,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.setupEventListeners()
  }
  
  start(): void {
    if (this.isRunning) return
    
    const interval = this.config.get('business.ticket.escalation.checkInterval')
    
    this.timer = setInterval(() => {
      this.checkAndEscalate()
    }, interval)
    
    this.isRunning = true
    this.logger.info('Ticket escalation service started', { interval })
  }
  
  stop(): void {
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
    this.isRunning = false
    this.logger.info('Ticket escalation service stopped')
  }
  
  async checkAndEscalate(): Promise<void> {
    try {
      // 委托给领域服务
      await this.domain.escalateOverdueTickets()
      
      // 发布服务级事件
      this.eventBus.emit('escalation.check.completed', {
        timestamp: new Date(),
        service: 'TicketEscalation'
      })
    } catch (error) {
      this.logger.error('Escalation check failed', error)
      
      this.eventBus.emit('escalation.check.failed', {
        error,
        timestamp: new Date()
      })
    }
  }
  
  private setupEventListeners(): void {
    // 监听工单创建事件，检查是否需要立即升级
    this.eventBus.on('ticket.created', async (event: TicketCreated) => {
      if (event.priority === TicketPriority.URGENT) {
        // 紧急工单立即通知
        this.notifyUrgentTicket(event.aggregateId)
      }
    })
    
    // 监听SLA即将违规事件
    this.eventBus.on('ticket.nearSLABreach', async (event) => {
      await this.handleNearSLABreach(event)
    })
  }
  
  private async notifyUrgentTicket(ticketId: string): Promise<void> {
    // 通过事件总线通知，而不是直接调用通知服务
    this.eventBus.emit('notification.urgent', {
      type: 'urgent_ticket',
      ticketId,
      recipients: await this.getUrgentRecipients()
    })
  }
  
  private async handleNearSLABreach(event: any): Promise<void> {
    this.eventBus.emit('notification.warning', {
      type: 'sla_warning',
      ticketId: event.ticketId,
      hoursRemaining: event.hoursRemaining
    })
  }
  
  private async getUrgentRecipients(): Promise<string[]> {
    // 从配置或repository获取紧急通知接收人
    return this.config.get('business.ticket.urgentRecipients', [])
  }
}
```

#### 2. 创建事件处理器
```typescript
// src/services/ticket/TicketEventHandler.ts
@Injectable()
export class TicketEventHandler {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('NotificationService') private notificationService: NotificationService,
    @Inject('AuditService') private auditService: AuditService,
    @Inject('EventBus') private eventBus: EventBus
  ) {
    this.registerHandlers()
  }
  
  private registerHandlers(): void {
    // 工单创建
    this.eventBus.on('ticket.created', this.handleTicketCreated.bind(this))
    
    // 工单分配
    this.eventBus.on('ticket.assigned', this.handleTicketAssigned.bind(this))
    
    // 工单升级
    this.eventBus.on('ticket.escalated', this.handleTicketEscalated.bind(this))
    
    // 工单完成
    this.eventBus.on('ticket.completed', this.handleTicketCompleted.bind(this))
  }
  
  private async handleTicketCreated(event: TicketCreated): Promise<void> {
    // 1. 记录审计日志
    await this.auditService.log({
      action: 'TICKET_CREATED',
      entityId: event.aggregateId,
      entityType: 'Ticket',
      userId: event.reporterId,
      timestamp: event.occurredAt,
      details: {
        title: event.title,
        priority: event.priority
      }
    })
    
    // 2. 发送通知
    if (event.priority === TicketPriority.URGENT) {
      await this.notificationService.sendUrgentTicketNotification(event.aggregateId)
    }
    
    // 3. 更新统计
    this.eventBus.emit('statistics.update', {
      type: 'ticket_created',
      data: event
    })
  }
  
  private async handleTicketAssigned(event: TicketAssigned): Promise<void> {
    // 通知被分配人
    await this.notificationService.notifyAssignee(
      event.assigneeId,
      event.aggregateId
    )
    
    // 记录分配历史
    await this.repository.saveAssignmentHistory({
      ticketId: event.aggregateId,
      assigneeId: event.assigneeId,
      assignedBy: event.assignedBy,
      assignedAt: event.occurredAt
    })
  }
  
  private async handleTicketEscalated(event: TicketEscalated): Promise<void> {
    // 通知管理层
    const managers = await this.repository.findManagers()
    
    await this.notificationService.broadcast(managers, {
      type: 'ticket_escalated',
      ticketId: event.aggregateId,
      oldPriority: event.oldPriority,
      newPriority: event.newPriority,
      reason: event.reason
    })
    
    // 记录升级历史
    await this.auditService.log({
      action: 'TICKET_ESCALATED',
      entityId: event.aggregateId,
      details: event
    })
  }
  
  private async handleTicketCompleted(event: TicketCompleted): Promise<void> {
    // 计算处理时长
    const ticket = await this.repository.findById(event.aggregateId)
    const duration = event.occurredAt.getTime() - ticket.createdAt.getTime()
    
    // 更新性能指标
    await this.repository.updatePerformanceMetrics({
      ticketId: event.aggregateId,
      completedBy: event.completedBy,
      duration,
      resolution: event.resolution
    })
    
    // 发送满意度调查
    this.eventBus.emit('survey.send', {
      ticketId: event.aggregateId,
      reporterId: ticket.reporterId
    })
  }
}
```

### Day 5: 实现服务通信（8小时）

#### 1. 事件驱动的服务通信
```typescript
// src/services/core/ServiceOrchestrator.ts
@Injectable()
export class ServiceOrchestrator {
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.setupCrossServiceCommunication()
  }
  
  private setupCrossServiceCommunication(): void {
    // 巡检异常 -> 工单创建
    this.eventBus.on('inspection.anomaly.detected', async (event) => {
      await this.createTicketFromAnomaly(event)
    })
    
    // 维保到期 -> 工单创建
    this.eventBus.on('maintenance.due', async (event) => {
      await this.createMaintenanceTicket(event)
    })
    
    // 工单完成 -> 更新相关实体
    this.eventBus.on('ticket.completed', async (event) => {
      await this.updateRelatedEntities(event)
    })
  }
  
  private async createTicketFromAnomaly(event: any): Promise<void> {
    const ticketDomain = container.get<TicketDomain>('TicketDomain')
    
    try {
      const ticket = await ticketDomain.createTicket({
        title: `[巡检异常] ${event.floor} - ${event.item}`,
        description: event.description,
        priority: this.mapAnomalyToPriority(event.severity),
        reporterId: event.inspectorId,
        sourceType: 'inspection',
        sourceId: event.inspectionId
      })
      
      // 通知巡检服务工单已创建
      this.eventBus.emit('ticket.created.from.inspection', {
        ticketId: ticket.id,
        inspectionId: event.inspectionId
      })
    } catch (error) {
      this.logger.error('Failed to create ticket from anomaly', error)
    }
  }
  
  private async createMaintenanceTicket(event: any): Promise<void> {
    const ticketDomain = container.get<TicketDomain>('TicketDomain')
    
    const ticket = await ticketDomain.createTicket({
      title: `[维保任务] ${event.planTitle}`,
      description: `维保计划即将到期：${event.dueDate}`,
      priority: TicketPriority.HIGH,
      reporterId: event.responsibleId,
      sourceType: 'maintenance',
      sourceId: event.planId
    })
    
    this.eventBus.emit('ticket.created.from.maintenance', {
      ticketId: ticket.id,
      maintenanceId: event.planId
    })
  }
  
  private async updateRelatedEntities(event: TicketCompleted): Promise<void> {
    const ticket = await container.get('TicketRepository').findById(event.aggregateId)
    
    if (ticket.sourceType === 'inspection') {
      this.eventBus.emit('inspection.ticket.completed', {
        inspectionId: ticket.sourceId,
        ticketId: ticket.id
      })
    } else if (ticket.sourceType === 'maintenance') {
      this.eventBus.emit('maintenance.ticket.completed', {
        maintenanceId: ticket.sourceId,
        ticketId: ticket.id
      })
    }
  }
  
  private mapAnomalyToPriority(severity: string): TicketPriority {
    const map = {
      'critical': TicketPriority.URGENT,
      'high': TicketPriority.HIGH,
      'medium': TicketPriority.MEDIUM,
      'low': TicketPriority.LOW
    }
    return map[severity] || TicketPriority.MEDIUM
  }
}
```

---

## Milestone 3.3: 工单视图瘦身（2天）

### Day 6: 拆分工单列表组件（8小时）

#### 1. 主列表组件瘦身
```vue
<!-- src/views/business/ticket/index.vue (瘦身后 <300行) -->
<template>
  <div class="app-container">
    <!-- 搜索栏 -->
    <TicketSearch 
      v-model="queryParams"
      @search="handleSearch"
      @reset="handleReset"
    />
    
    <!-- 工具栏 -->
    <TicketToolbar
      :selected-ids="selectedIds"
      @create="handleCreate"
      @batch-assign="handleBatchAssign"
      @export="handleExport"
    />
    
    <!-- 数据表格 -->
    <TicketTable
      :loading="loading"
      :data="ticketList"
      :total="total"
      v-model:page="queryParams.pageNum"
      v-model:page-size="queryParams.pageSize"
      @sort-change="handleSort"
      @selection-change="handleSelectionChange"
      @row-action="handleRowAction"
    />
  </div>
</template>

<script setup lang="ts" name="TicketList">
import { useTicketList } from '@/composables/useTicketList'
import TicketSearch from './components/TicketSearch.vue'
import TicketToolbar from './components/TicketToolbar.vue'
import TicketTable from './components/TicketTable.vue'

// 使用组合式函数管理业务逻辑
const {
  loading,
  ticketList,
  total,
  queryParams,
  selectedIds,
  handleSearch,
  handleReset,
  handleCreate,
  handleBatchAssign,
  handleExport,
  handleSort,
  handleSelectionChange,
  handleRowAction
} = useTicketList()
</script>
```

#### 2. 抽取组合式函数
```typescript
// src/composables/useTicketList.ts
export function useTicketList() {
  // 依赖注入
  const ticketService = FeatureFlags.isEnabled('USE_NEW_TICKET') 
    ? container.get('TicketDomain')
    : legacyTicketService
    
  const eventBus = container.get('EventBus')
  const router = useRouter()
  const { proxy } = getCurrentInstance()
  
  // 状态管理
  const store = useTicketStore()
  const { ticketList, total, loading } = storeToRefs(store)
  
  // 查询参数
  const queryParams = ref({
    pageNum: 1,
    pageSize: 20,
    title: '',
    status: '',
    priority: '',
    assigneeId: ''
  })
  
  // 选中项
  const selectedIds = ref<string[]>([])
  
  // 数据加载
  const loadData = async () => {
    await store.fetchList(queryParams.value)
  }
  
  // 搜索处理
  const handleSearch = () => {
    queryParams.value.pageNum = 1
    loadData()
  }
  
  // 重置处理
  const handleReset = () => {
    queryParams.value = {
      pageNum: 1,
      pageSize: 20,
      title: '',
      status: '',
      priority: '',
      assigneeId: ''
    }
    loadData()
  }
  
  // 创建工单
  const handleCreate = () => {
    router.push('/business/ticket/create')
  }
  
  // 批量分配
  const handleBatchAssign = async (assigneeId: string) => {
    if (selectedIds.value.length === 0) {
      proxy.$modal.msgWarning('请选择要分配的工单')
      return
    }
    
    try {
      await store.batchAssign(selectedIds.value, assigneeId)
      proxy.$modal.msgSuccess('批量分配成功')
      
      // 发布事件
      eventBus.emit('tickets.batch.assigned', {
        ticketIds: selectedIds.value,
        assigneeId
      })
      
      loadData()
    } catch (error) {
      proxy.$modal.msgError('批量分配失败')
    }
  }
  
  // 导出
  const handleExport = async () => {
    await store.exportTickets(queryParams.value)
  }
  
  // 排序
  const handleSort = ({ prop, order }) => {
    queryParams.value.orderByColumn = prop
    queryParams.value.isAsc = order === 'ascending' ? 'asc' : 'desc'
    loadData()
  }
  
  // 选择变化
  const handleSelectionChange = (selection: Ticket[]) => {
    selectedIds.value = selection.map(item => item.id)
  }
  
  // 行操作
  const handleRowAction = ({ action, row }) => {
    switch (action) {
      case 'view':
        router.push(`/business/ticket/detail/${row.id}`)
        break
      case 'edit':
        router.push(`/business/ticket/edit/${row.id}`)
        break
      case 'delete':
        handleDelete(row)
        break
      case 'assign':
        handleAssign(row)
        break
    }
  }
  
  // 生命周期
  onMounted(() => {
    loadData()
    
    // 监听事件
    eventBus.on('ticket.created', loadData)
    eventBus.on('ticket.updated', loadData)
  })
  
  onUnmounted(() => {
    eventBus.off('ticket.created', loadData)
    eventBus.off('ticket.updated', loadData)
  })
  
  return {
    loading,
    ticketList,
    total,
    queryParams,
    selectedIds,
    handleSearch,
    handleReset,
    handleCreate,
    handleBatchAssign,
    handleExport,
    handleSort,
    handleSelectionChange,
    handleRowAction
  }
}
```

### Day 7: 创建可复用组件（8小时）

#### 1. 搜索组件
```vue
<!-- src/views/business/ticket/components/TicketSearch.vue -->
<template>
  <el-form :model="modelValue" ref="queryRef" :inline="true" v-show="showSearch">
    <el-form-item label="标题" prop="title">
      <el-input
        v-model="modelValue.title"
        placeholder="请输入工单标题"
        clearable
        @keyup.enter="handleSearch"
      />
    </el-form-item>
    
    <el-form-item label="状态" prop="status">
      <el-select v-model="modelValue.status" placeholder="请选择状态" clearable>
        <el-option
          v-for="status in ticketStatuses"
          :key="status.value"
          :label="status.label"
          :value="status.value"
        />
      </el-select>
    </el-form-item>
    
    <el-form-item label="优先级" prop="priority">
      <el-select v-model="modelValue.priority" placeholder="请选择优先级" clearable>
        <el-option
          v-for="priority in ticketPriorities"
          :key="priority.value"
          :label="priority.label"
          :value="priority.value"
        />
      </el-select>
    </el-form-item>
    
    <el-form-item>
      <el-button type="primary" icon="Search" @click="handleSearch">搜索</el-button>
      <el-button icon="Refresh" @click="handleReset">重置</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup lang="ts">
import { ticketStatuses, ticketPriorities } from '@/constants/ticket'

const props = defineProps<{
  modelValue: any
}>()

const emit = defineEmits<{
  'update:modelValue': [value: any]
  'search': []
  'reset': []
}>()

const showSearch = ref(true)
const queryRef = ref()

const handleSearch = () => {
  emit('search')
}

const handleReset = () => {
  queryRef.value?.resetFields()
  emit('reset')
}
</script>
```

#### 2. 表格组件
```vue
<!-- src/views/business/ticket/components/TicketTable.vue -->
<template>
  <div>
    <el-table
      v-loading="loading"
      :data="data"
      @selection-change="handleSelectionChange"
      @sort-change="handleSortChange"
    >
      <el-table-column type="selection" width="55" align="center" />
      <el-table-column label="工单编号" align="center" prop="ticketNo" sortable="custom" />
      <el-table-column label="标题" align="center" prop="title" :show-overflow-tooltip="true" />
      
      <el-table-column label="状态" align="center" prop="status">
        <template #default="scope">
          <TicketStatusTag :status="scope.row.status" />
        </template>
      </el-table-column>
      
      <el-table-column label="优先级" align="center" prop="priority" sortable="custom">
        <template #default="scope">
          <TicketPriorityTag :priority="scope.row.priority" />
        </template>
      </el-table-column>
      
      <el-table-column label="处理人" align="center" prop="assigneeName" />
      <el-table-column label="创建时间" align="center" prop="createTime" sortable="custom" width="180">
        <template #default="scope">
          <span>{{ parseTime(scope.row.createTime) }}</span>
        </template>
      </el-table-column>
      
      <el-table-column label="操作" align="center" class-name="small-padding fixed-width">
        <template #default="scope">
          <TicketActions 
            :ticket="scope.row"
            @action="handleAction($event, scope.row)"
          />
        </template>
      </el-table-column>
    </el-table>
    
    <pagination
      v-show="total > 0"
      :total="total"
      v-model:page="currentPage"
      v-model:limit="pageSize"
      @pagination="handlePagination"
    />
  </div>
</template>

<script setup lang="ts">
import { parseTime } from '@/utils/ruoyi'
import TicketStatusTag from './TicketStatusTag.vue'
import TicketPriorityTag from './TicketPriorityTag.vue'
import TicketActions from './TicketActions.vue'

const props = defineProps<{
  loading: boolean
  data: any[]
  total: number
  page: number
  pageSize: number
}>()

const emit = defineEmits<{
  'update:page': [value: number]
  'update:pageSize': [value: number]
  'sort-change': [value: any]
  'selection-change': [value: any[]]
  'row-action': [value: { action: string; row: any }]
}>()

const currentPage = computed({
  get: () => props.page,
  set: (val) => emit('update:page', val)
})

const pageSize = computed({
  get: () => props.pageSize,
  set: (val) => emit('update:pageSize', val)
})

const handleSelectionChange = (selection: any[]) => {
  emit('selection-change', selection)
}

const handleSortChange = (sort: any) => {
  emit('sort-change', sort)
}

const handleAction = (action: string, row: any) => {
  emit('row-action', { action, row })
}

const handlePagination = () => {
  // 分页组件会自动更新currentPage和pageSize
}
</script>
```

## 📊 Phase 3 完成标准检查清单

### 技术指标
- [ ] 单个文件不超过300行
- [ ] 圈复杂度不超过10
- [ ] 领域模型测试覆盖率 > 90%
- [ ] 服务层测试覆盖率 > 85%
- [ ] 无直接API调用

### 功能验证
- [ ] 工单状态机正常工作
- [ ] 事件驱动通信正常
- [ ] 领域规则验证生效
- [ ] 自动升级功能正常
- [ ] 批量操作功能正常

### 性能指标
- [ ] 列表加载时间 < 500ms
- [ ] 状态转换响应 < 100ms
- [ ] 事件处理延迟 < 50ms

## 🚀 Phase 3 交付物

1. **领域模型**
   - Ticket实体
   - TicketStateMachine
   - TicketDomain服务
   - 领域事件定义

2. **服务层**
   - TicketEscalationService（解耦版）
   - TicketEventHandler
   - ServiceOrchestrator

3. **视图组件**
   - 瘦身后的index.vue (<300行)
   - 可复用组件库
   - 组合式函数

4. **测试文件**
   - 领域模型单元测试
   - 状态机测试
   - 服务集成测试

5. **文档**
   - TICKET-DOMAIN.md
   - STATE-MACHINE.md
   - EVENT-DRIVEN.md

这就是Phase 3的完整实施方案，重点是建立工单的领域模型、实现状态机、解耦服务通信，并将视图层瘦身到合理范围。