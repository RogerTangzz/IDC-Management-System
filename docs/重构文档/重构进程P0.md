我来详细展开 **Phase 0: 准备阶段** 的具体实施方案。这是整个重构的基础，必须做扎实。

## 📋 Phase 0: 准备阶段详细实施方案

### **Day 1: 搭建测试框架**

#### 上午：测试环境配置（4小时）

1. **安装测试依赖**
```bash
# 安装 Vitest 和相关依赖
npm install -D vitest @vue/test-utils happy-dom @vitest/ui
npm install -D @testing-library/vue @testing-library/user-event
```

2. **配置 vitest.config.js**
```javascript
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'happy-dom',
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'dist/']
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

3. **创建测试工具类**
```javascript
// src/__tests__/utils/setup.js
import { config } from '@vue/test-utils'
import ElementPlus from 'element-plus'

config.global.plugins = [ElementPlus]

// Mock $modal
config.global.mocks = {
  $modal: {
    msgSuccess: vi.fn(),
    msgError: vi.fn(),
    confirm: vi.fn(() => Promise.resolve())
  },
  $router: {
    push: vi.fn()
  }
}
```

#### 下午：编写核心功能测试用例（4小时）

1. **工单核心流程测试**
```javascript
// src/__tests__/ticket/ticket.service.spec.js
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { addTicket, updateTicket, listTicket } from '@/api/business/ticket'

vi.mock('@/api/business/ticket')

describe('工单服务测试', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('应该能创建工单', async () => {
    const ticketData = {
      title: '测试工单',
      priority: 'high',
      description: '测试描述'
    }
    
    addTicket.mockResolvedValue({
      code: 200,
      data: { ticketId: 1, ...ticketData }
    })
    
    const result = await addTicket(ticketData)
    expect(result.data.ticketId).toBe(1)
    expect(addTicket).toHaveBeenCalledWith(ticketData)
  })

  it('应该能处理工单状态流转', async () => {
    const transitions = [
      { from: 'pending', to: 'assigned', valid: true },
      { from: 'assigned', to: 'processing', valid: true },
      { from: 'processing', to: 'completed', valid: true },
      { from: 'completed', to: 'closed', valid: true },
      { from: 'closed', to: 'pending', valid: true }, // reopen
      { from: 'pending', to: 'closed', valid: false } // 非法跳转
    ]
    
    // 测试每个状态转换
    for (const t of transitions) {
      // 实现状态转换测试逻辑
    }
  })
})
```

2. **巡检异常检测测试**
```javascript
// src/__tests__/inspection/anomaly.spec.js
describe('巡检异常检测', () => {
  it('应该正确识别温度异常', () => {
    const inspectionData = {
      floor: 'floor1',
      items: {
        temp_room: 30, // 超过阈值25
        humidity: 50
      }
    }
    
    const anomalies = inspectionAnomaly.detectAnomalies(inspectionData)
    expect(anomalies).toHaveLength(1)
    expect(anomalies[0].itemName).toContain('温度')
  })
})
```

---

### **Day 2: 建立新架构骨架**

#### 上午：创建目录结构（2小时）

```bash
# 执行脚本创建目录
mkdir -p src/domain/{ticket,inspection,maintenance}
mkdir -p src/services/{core,business}
mkdir -p src/config
mkdir -p src/adapters
```

#### 下午：实现基础类（6小时）

1. **领域基类**
```javascript
// src/domain/base/BaseDomain.js
export class BaseDomain {
  constructor(repository, eventBus) {
    this.repository = repository
    this.eventBus = eventBus
    this.validators = []
  }

  async validate(data) {
    for (const validator of this.validators) {
      const result = await validator(data)
      if (!result.valid) {
        throw new ValidationError(result.message)
      }
    }
  }

  emit(event, data) {
    this.eventBus.emit(event, {
      ...data,
      timestamp: Date.now(),
      source: this.constructor.name
    })
  }
}
```

2. **事件总线实现**
```javascript
// src/services/core/EventBus.js
export class EventBus {
  constructor() {
    this.events = new Map()
    this.history = []
    this.maxHistorySize = 100
  }

  on(event, handler, options = {}) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    
    const wrappedHandler = {
      handler,
      once: options.once || false,
      priority: options.priority || 0
    }
    
    const handlers = this.events.get(event)
    handlers.push(wrappedHandler)
    handlers.sort((a, b) => b.priority - a.priority)
    
    return () => this.off(event, handler)
  }

  async emit(event, data) {
    console.log(`[EventBus] 发送事件: ${event}`, data)
    
    // 记录历史
    this.history.push({ event, data, timestamp: Date.now() })
    if (this.history.length > this.maxHistorySize) {
      this.history.shift()
    }

    const handlers = this.events.get(event) || []
    const results = []

    for (const { handler, once } of handlers) {
      try {
        const result = await handler(data)
        results.push(result)
        
        if (once) {
          this.off(event, handler)
        }
      } catch (error) {
        console.error(`[EventBus] 处理事件 ${event} 失败:`, error)
      }
    }

    return results
  }

  off(event, handler) {
    const handlers = this.events.get(event) || []
    const index = handlers.findIndex(h => h.handler === handler)
    if (index !== -1) {
      handlers.splice(index, 1)
    }
  }
}

export default new EventBus()
```

3. **依赖注入容器**
```javascript
// src/services/core/Container.js
export class Container {
  constructor() {
    this.services = new Map()
    this.singletons = new Map()
  }

  register(name, factory, options = {}) {
    this.services.set(name, {
      factory,
      singleton: options.singleton !== false,
      dependencies: options.dependencies || []
    })
  }

  get(name) {
    const service = this.services.get(name)
    if (!service) {
      throw new Error(`Service ${name} not found`)
    }

    // 单例模式
    if (service.singleton && this.singletons.has(name)) {
      return this.singletons.get(name)
    }

    // 解析依赖
    const deps = service.dependencies.map(dep => this.get(dep))
    const instance = service.factory(...deps)

    if (service.singleton) {
      this.singletons.set(name, instance)
    }

    return instance
  }
}

export default new Container()
```

---

### **Day 3: 配置特性开关**

#### 上午：实现特性开关系统（4小时）

1. **特性开关管理器**
```javascript
// src/config/FeatureFlags.js
class FeatureFlags {
  constructor() {
    this.flags = new Map()
    this.listeners = new Map()
    this.loadFromStorage()
  }

  // 初始化默认值
  init() {
    this.setFlag('USE_NEW_ARCHITECTURE', false)
    this.setFlag('USE_DOMAIN_LAYER', false)
    this.setFlag('USE_EVENT_BUS', false)
    this.setFlag('ENABLE_PERFORMANCE_MONITOR', true)
    this.setFlag('ENABLE_ERROR_TRACKING', true)
  }

  setFlag(name, value) {
    const oldValue = this.flags.get(name)
    this.flags.set(name, value)
    
    // 持久化到localStorage
    this.saveToStorage()
    
    // 通知监听器
    if (oldValue !== value) {
      this.notify(name, value, oldValue)
    }
  }

  getFlag(name, defaultValue = false) {
    return this.flags.get(name) ?? defaultValue
  }

  isEnabled(name) {
    return this.getFlag(name) === true
  }

  onChange(name, callback) {
    if (!this.listeners.has(name)) {
      this.listeners.set(name, [])
    }
    this.listeners.get(name).push(callback)
  }

  notify(name, newValue, oldValue) {
    const callbacks = this.listeners.get(name) || []
    callbacks.forEach(cb => cb(newValue, oldValue))
  }

  saveToStorage() {
    const data = Object.fromEntries(this.flags)
    localStorage.setItem('FEATURE_FLAGS', JSON.stringify(data))
  }

  loadFromStorage() {
    try {
      const data = localStorage.getItem('FEATURE_FLAGS')
      if (data) {
        const flags = JSON.parse(data)
        Object.entries(flags).forEach(([key, value]) => {
          this.flags.set(key, value)
        })
      }
    } catch (e) {
      console.error('Failed to load feature flags:', e)
    }
  }
}

export default new FeatureFlags()
```

2. **特性开关UI面板**
```vue
<!-- src/components/FeatureFlagsPanel.vue -->
<template>
  <div class="feature-flags-panel" v-if="showPanel">
    <h3>特性开关（开发模式）</h3>
    <el-form>
      <el-form-item 
        v-for="flag in flags" 
        :key="flag.name"
        :label="flag.label"
      >
        <el-switch
          v-model="flag.value"
          @change="handleChange(flag.name, $event)"
        />
        <span class="flag-desc">{{ flag.description }}</span>
      </el-form-item>
    </el-form>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import FeatureFlags from '@/config/FeatureFlags'

const showPanel = ref(import.meta.env.DEV)
const flags = ref([
  {
    name: 'USE_NEW_ARCHITECTURE',
    label: '启用新架构',
    description: '使用重构后的架构',
    value: false
  },
  {
    name: 'USE_DOMAIN_LAYER',
    label: '启用领域层',
    description: '使用领域驱动设计',
    value: false
  },
  {
    name: 'USE_EVENT_BUS',
    label: '启用事件总线',
    description: '使用事件驱动通信',
    value: false
  }
])

onMounted(() => {
  flags.value.forEach(flag => {
    flag.value = FeatureFlags.getFlag(flag.name)
  })
})

function handleChange(name, value) {
  FeatureFlags.setFlag(name, value)
  ElMessage.success(`特性 ${name} 已${value ? '启用' : '禁用'}`)
}
</script>
```

#### 下午：创建回滚机制（4小时）

```javascript
// src/config/Rollback.js
class RollbackManager {
  constructor() {
    this.checkpoints = []
    this.maxCheckpoints = 10
  }

  createCheckpoint(name) {
    const checkpoint = {
      name,
      timestamp: Date.now(),
      flags: new Map(FeatureFlags.flags),
      data: this.captureState()
    }
    
    this.checkpoints.push(checkpoint)
    if (this.checkpoints.length > this.maxCheckpoints) {
      this.checkpoints.shift()
    }
    
    console.log(`[Rollback] 创建检查点: ${name}`)
    return checkpoint
  }

  rollback(checkpointName) {
    const checkpoint = this.checkpoints.find(cp => cp.name === checkpointName)
    if (!checkpoint) {
      throw new Error(`Checkpoint ${checkpointName} not found`)
    }
    
    // 恢复特性开关
    checkpoint.flags.forEach((value, key) => {
      FeatureFlags.setFlag(key, value)
    })
    
    // 恢复应用状态
    this.restoreState(checkpoint.data)
    
    console.log(`[Rollback] 已回滚到检查点: ${checkpointName}`)
  }

  captureState() {
    // 捕获当前应用状态
    return {
      localStorage: { ...localStorage },
      sessionStorage: { ...sessionStorage }
    }
  }

  restoreState(state) {
    // 恢复应用状态
    Object.entries(state.localStorage).forEach(([key, value]) => {
      localStorage.setItem(key, value)
    })
  }
}
```

## 📊 Phase 0 完成标准检查清单

- [ ] **测试覆盖率达到80%**
  - 工单核心流程 ✓
  - 巡检异常检测 ✓
  - 维保状态流转 ✓

- [ ] **架构基础就绪**
  - Domain层结构创建 ✓
  - EventBus实现并测试 ✓
  - Container配置完成 ✓

- [ ] **特性开关可用**
  - 所有开关可独立控制 ✓
  - 支持运行时切换 ✓
  - 有回滚机制 ✓

- [ ] **团队准备就绪**
  - 两人都理解新架构 ✓
  - 分工明确 ✓
  - 沟通机制建立 ✓

这样Phase 0的准备工作就完成了，为后续的大规模重构打下了坚实基础。需要我继续展开Phase 1的详细实施方案吗？