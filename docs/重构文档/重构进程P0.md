æˆ‘æ¥è¯¦ç»†å±•å¼€ **Phase 0: å‡†å¤‡é˜¶æ®µ** çš„å…·ä½“å®æ–½æ–¹æ¡ˆã€‚è¿™æ˜¯æ•´ä¸ªé‡æ„çš„åŸºç¡€ï¼Œå¿…é¡»åšæ‰å®ã€‚

## ğŸ“‹ Phase 0: å‡†å¤‡é˜¶æ®µè¯¦ç»†å®æ–½æ–¹æ¡ˆ

### **Day 1: æ­å»ºæµ‹è¯•æ¡†æ¶**

#### ä¸Šåˆï¼šæµ‹è¯•ç¯å¢ƒé…ç½®ï¼ˆ4å°æ—¶ï¼‰

1. **å®‰è£…æµ‹è¯•ä¾èµ–**
```bash
# å®‰è£… Vitest å’Œç›¸å…³ä¾èµ–
npm install -D vitest @vue/test-utils happy-dom @vitest/ui
npm install -D @testing-library/vue @testing-library/user-event
```

2. **é…ç½® vitest.config.js**
```javascript
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'happy-dom',
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'dist/']
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

3. **åˆ›å»ºæµ‹è¯•å·¥å…·ç±»**
```javascript
// src/__tests__/utils/setup.js
import { config } from '@vue/test-utils'
import ElementPlus from 'element-plus'

config.global.plugins = [ElementPlus]

// Mock $modal
config.global.mocks = {
  $modal: {
    msgSuccess: vi.fn(),
    msgError: vi.fn(),
    confirm: vi.fn(() => Promise.resolve())
  },
  $router: {
    push: vi.fn()
  }
}
```

#### ä¸‹åˆï¼šç¼–å†™æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•ç”¨ä¾‹ï¼ˆ4å°æ—¶ï¼‰

1. **å·¥å•æ ¸å¿ƒæµç¨‹æµ‹è¯•**
```javascript
// src/__tests__/ticket/ticket.service.spec.js
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { addTicket, updateTicket, listTicket } from '@/api/business/ticket'

vi.mock('@/api/business/ticket')

describe('å·¥å•æœåŠ¡æµ‹è¯•', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('åº”è¯¥èƒ½åˆ›å»ºå·¥å•', async () => {
    const ticketData = {
      title: 'æµ‹è¯•å·¥å•',
      priority: 'high',
      description: 'æµ‹è¯•æè¿°'
    }
    
    addTicket.mockResolvedValue({
      code: 200,
      data: { ticketId: 1, ...ticketData }
    })
    
    const result = await addTicket(ticketData)
    expect(result.data.ticketId).toBe(1)
    expect(addTicket).toHaveBeenCalledWith(ticketData)
  })

  it('åº”è¯¥èƒ½å¤„ç†å·¥å•çŠ¶æ€æµè½¬', async () => {
    const transitions = [
      { from: 'pending', to: 'assigned', valid: true },
      { from: 'assigned', to: 'processing', valid: true },
      { from: 'processing', to: 'completed', valid: true },
      { from: 'completed', to: 'closed', valid: true },
      { from: 'closed', to: 'pending', valid: true }, // reopen
      { from: 'pending', to: 'closed', valid: false } // éæ³•è·³è½¬
    ]
    
    // æµ‹è¯•æ¯ä¸ªçŠ¶æ€è½¬æ¢
    for (const t of transitions) {
      // å®ç°çŠ¶æ€è½¬æ¢æµ‹è¯•é€»è¾‘
    }
  })
})
```

2. **å·¡æ£€å¼‚å¸¸æ£€æµ‹æµ‹è¯•**
```javascript
// src/__tests__/inspection/anomaly.spec.js
describe('å·¡æ£€å¼‚å¸¸æ£€æµ‹', () => {
  it('åº”è¯¥æ­£ç¡®è¯†åˆ«æ¸©åº¦å¼‚å¸¸', () => {
    const inspectionData = {
      floor: 'floor1',
      items: {
        temp_room: 30, // è¶…è¿‡é˜ˆå€¼25
        humidity: 50
      }
    }
    
    const anomalies = inspectionAnomaly.detectAnomalies(inspectionData)
    expect(anomalies).toHaveLength(1)
    expect(anomalies[0].itemName).toContain('æ¸©åº¦')
  })
})
```

---

### **Day 2: å»ºç«‹æ–°æ¶æ„éª¨æ¶**

#### ä¸Šåˆï¼šåˆ›å»ºç›®å½•ç»“æ„ï¼ˆ2å°æ—¶ï¼‰

```bash
# æ‰§è¡Œè„šæœ¬åˆ›å»ºç›®å½•
mkdir -p src/domain/{ticket,inspection,maintenance}
mkdir -p src/services/{core,business}
mkdir -p src/config
mkdir -p src/adapters
```

#### ä¸‹åˆï¼šå®ç°åŸºç¡€ç±»ï¼ˆ6å°æ—¶ï¼‰

1. **é¢†åŸŸåŸºç±»**
```javascript
// src/domain/base/BaseDomain.js
export class BaseDomain {
  constructor(repository, eventBus) {
    this.repository = repository
    this.eventBus = eventBus
    this.validators = []
  }

  async validate(data) {
    for (const validator of this.validators) {
      const result = await validator(data)
      if (!result.valid) {
        throw new ValidationError(result.message)
      }
    }
  }

  emit(event, data) {
    this.eventBus.emit(event, {
      ...data,
      timestamp: Date.now(),
      source: this.constructor.name
    })
  }
}
```

2. **äº‹ä»¶æ€»çº¿å®ç°**
```javascript
// src/services/core/EventBus.js
export class EventBus {
  constructor() {
    this.events = new Map()
    this.history = []
    this.maxHistorySize = 100
  }

  on(event, handler, options = {}) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    
    const wrappedHandler = {
      handler,
      once: options.once || false,
      priority: options.priority || 0
    }
    
    const handlers = this.events.get(event)
    handlers.push(wrappedHandler)
    handlers.sort((a, b) => b.priority - a.priority)
    
    return () => this.off(event, handler)
  }

  async emit(event, data) {
    console.log(`[EventBus] å‘é€äº‹ä»¶: ${event}`, data)
    
    // è®°å½•å†å²
    this.history.push({ event, data, timestamp: Date.now() })
    if (this.history.length > this.maxHistorySize) {
      this.history.shift()
    }

    const handlers = this.events.get(event) || []
    const results = []

    for (const { handler, once } of handlers) {
      try {
        const result = await handler(data)
        results.push(result)
        
        if (once) {
          this.off(event, handler)
        }
      } catch (error) {
        console.error(`[EventBus] å¤„ç†äº‹ä»¶ ${event} å¤±è´¥:`, error)
      }
    }

    return results
  }

  off(event, handler) {
    const handlers = this.events.get(event) || []
    const index = handlers.findIndex(h => h.handler === handler)
    if (index !== -1) {
      handlers.splice(index, 1)
    }
  }
}

export default new EventBus()
```

3. **ä¾èµ–æ³¨å…¥å®¹å™¨**
```javascript
// src/services/core/Container.js
export class Container {
  constructor() {
    this.services = new Map()
    this.singletons = new Map()
  }

  register(name, factory, options = {}) {
    this.services.set(name, {
      factory,
      singleton: options.singleton !== false,
      dependencies: options.dependencies || []
    })
  }

  get(name) {
    const service = this.services.get(name)
    if (!service) {
      throw new Error(`Service ${name} not found`)
    }

    // å•ä¾‹æ¨¡å¼
    if (service.singleton && this.singletons.has(name)) {
      return this.singletons.get(name)
    }

    // è§£æä¾èµ–
    const deps = service.dependencies.map(dep => this.get(dep))
    const instance = service.factory(...deps)

    if (service.singleton) {
      this.singletons.set(name, instance)
    }

    return instance
  }
}

export default new Container()
```

---

### **Day 3: é…ç½®ç‰¹æ€§å¼€å…³**

#### ä¸Šåˆï¼šå®ç°ç‰¹æ€§å¼€å…³ç³»ç»Ÿï¼ˆ4å°æ—¶ï¼‰

1. **ç‰¹æ€§å¼€å…³ç®¡ç†å™¨**
```javascript
// src/config/FeatureFlags.js
class FeatureFlags {
  constructor() {
    this.flags = new Map()
    this.listeners = new Map()
    this.loadFromStorage()
  }

  // åˆå§‹åŒ–é»˜è®¤å€¼
  init() {
    this.setFlag('USE_NEW_ARCHITECTURE', false)
    this.setFlag('USE_DOMAIN_LAYER', false)
    this.setFlag('USE_EVENT_BUS', false)
    this.setFlag('ENABLE_PERFORMANCE_MONITOR', true)
    this.setFlag('ENABLE_ERROR_TRACKING', true)
  }

  setFlag(name, value) {
    const oldValue = this.flags.get(name)
    this.flags.set(name, value)
    
    // æŒä¹…åŒ–åˆ°localStorage
    this.saveToStorage()
    
    // é€šçŸ¥ç›‘å¬å™¨
    if (oldValue !== value) {
      this.notify(name, value, oldValue)
    }
  }

  getFlag(name, defaultValue = false) {
    return this.flags.get(name) ?? defaultValue
  }

  isEnabled(name) {
    return this.getFlag(name) === true
  }

  onChange(name, callback) {
    if (!this.listeners.has(name)) {
      this.listeners.set(name, [])
    }
    this.listeners.get(name).push(callback)
  }

  notify(name, newValue, oldValue) {
    const callbacks = this.listeners.get(name) || []
    callbacks.forEach(cb => cb(newValue, oldValue))
  }

  saveToStorage() {
    const data = Object.fromEntries(this.flags)
    localStorage.setItem('FEATURE_FLAGS', JSON.stringify(data))
  }

  loadFromStorage() {
    try {
      const data = localStorage.getItem('FEATURE_FLAGS')
      if (data) {
        const flags = JSON.parse(data)
        Object.entries(flags).forEach(([key, value]) => {
          this.flags.set(key, value)
        })
      }
    } catch (e) {
      console.error('Failed to load feature flags:', e)
    }
  }
}

export default new FeatureFlags()
```

2. **ç‰¹æ€§å¼€å…³UIé¢æ¿**
```vue
<!-- src/components/FeatureFlagsPanel.vue -->
<template>
  <div class="feature-flags-panel" v-if="showPanel">
    <h3>ç‰¹æ€§å¼€å…³ï¼ˆå¼€å‘æ¨¡å¼ï¼‰</h3>
    <el-form>
      <el-form-item 
        v-for="flag in flags" 
        :key="flag.name"
        :label="flag.label"
      >
        <el-switch
          v-model="flag.value"
          @change="handleChange(flag.name, $event)"
        />
        <span class="flag-desc">{{ flag.description }}</span>
      </el-form-item>
    </el-form>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import FeatureFlags from '@/config/FeatureFlags'

const showPanel = ref(import.meta.env.DEV)
const flags = ref([
  {
    name: 'USE_NEW_ARCHITECTURE',
    label: 'å¯ç”¨æ–°æ¶æ„',
    description: 'ä½¿ç”¨é‡æ„åçš„æ¶æ„',
    value: false
  },
  {
    name: 'USE_DOMAIN_LAYER',
    label: 'å¯ç”¨é¢†åŸŸå±‚',
    description: 'ä½¿ç”¨é¢†åŸŸé©±åŠ¨è®¾è®¡',
    value: false
  },
  {
    name: 'USE_EVENT_BUS',
    label: 'å¯ç”¨äº‹ä»¶æ€»çº¿',
    description: 'ä½¿ç”¨äº‹ä»¶é©±åŠ¨é€šä¿¡',
    value: false
  }
])

onMounted(() => {
  flags.value.forEach(flag => {
    flag.value = FeatureFlags.getFlag(flag.name)
  })
})

function handleChange(name, value) {
  FeatureFlags.setFlag(name, value)
  ElMessage.success(`ç‰¹æ€§ ${name} å·²${value ? 'å¯ç”¨' : 'ç¦ç”¨'}`)
}
</script>
```

#### ä¸‹åˆï¼šåˆ›å»ºå›æ»šæœºåˆ¶ï¼ˆ4å°æ—¶ï¼‰

```javascript
// src/config/Rollback.js
class RollbackManager {
  constructor() {
    this.checkpoints = []
    this.maxCheckpoints = 10
  }

  createCheckpoint(name) {
    const checkpoint = {
      name,
      timestamp: Date.now(),
      flags: new Map(FeatureFlags.flags),
      data: this.captureState()
    }
    
    this.checkpoints.push(checkpoint)
    if (this.checkpoints.length > this.maxCheckpoints) {
      this.checkpoints.shift()
    }
    
    console.log(`[Rollback] åˆ›å»ºæ£€æŸ¥ç‚¹: ${name}`)
    return checkpoint
  }

  rollback(checkpointName) {
    const checkpoint = this.checkpoints.find(cp => cp.name === checkpointName)
    if (!checkpoint) {
      throw new Error(`Checkpoint ${checkpointName} not found`)
    }
    
    // æ¢å¤ç‰¹æ€§å¼€å…³
    checkpoint.flags.forEach((value, key) => {
      FeatureFlags.setFlag(key, value)
    })
    
    // æ¢å¤åº”ç”¨çŠ¶æ€
    this.restoreState(checkpoint.data)
    
    console.log(`[Rollback] å·²å›æ»šåˆ°æ£€æŸ¥ç‚¹: ${checkpointName}`)
  }

  captureState() {
    // æ•è·å½“å‰åº”ç”¨çŠ¶æ€
    return {
      localStorage: { ...localStorage },
      sessionStorage: { ...sessionStorage }
    }
  }

  restoreState(state) {
    // æ¢å¤åº”ç”¨çŠ¶æ€
    Object.entries(state.localStorage).forEach(([key, value]) => {
      localStorage.setItem(key, value)
    })
  }
}
```

## ğŸ“Š Phase 0 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

- [ ] **æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°80%**
  - å·¥å•æ ¸å¿ƒæµç¨‹ âœ“
  - å·¡æ£€å¼‚å¸¸æ£€æµ‹ âœ“
  - ç»´ä¿çŠ¶æ€æµè½¬ âœ“

- [ ] **æ¶æ„åŸºç¡€å°±ç»ª**
  - Domainå±‚ç»“æ„åˆ›å»º âœ“
  - EventBuså®ç°å¹¶æµ‹è¯• âœ“
  - Containeré…ç½®å®Œæˆ âœ“

- [ ] **ç‰¹æ€§å¼€å…³å¯ç”¨**
  - æ‰€æœ‰å¼€å…³å¯ç‹¬ç«‹æ§åˆ¶ âœ“
  - æ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢ âœ“
  - æœ‰å›æ»šæœºåˆ¶ âœ“

- [ ] **å›¢é˜Ÿå‡†å¤‡å°±ç»ª**
  - ä¸¤äººéƒ½ç†è§£æ–°æ¶æ„ âœ“
  - åˆ†å·¥æ˜ç¡® âœ“
  - æ²Ÿé€šæœºåˆ¶å»ºç«‹ âœ“

è¿™æ ·Phase 0çš„å‡†å¤‡å·¥ä½œå°±å®Œæˆäº†ï¼Œä¸ºåç»­çš„å¤§è§„æ¨¡é‡æ„æ‰“ä¸‹äº†åšå®åŸºç¡€ã€‚éœ€è¦æˆ‘ç»§ç»­å±•å¼€Phase 1çš„è¯¦ç»†å®æ–½æ–¹æ¡ˆå—ï¼Ÿ