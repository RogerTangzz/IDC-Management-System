æˆ‘ç†è§£ä½ æƒ³è¦Phase 1ï¼ˆåŸºç¡€è®¾æ–½è§£è€¦ï¼‰çš„è¯¦ç»†å®æ–½å†…å®¹ã€‚è®©æˆ‘æä¾›å®Œæ•´çš„Phase 1å®æ–½æ–¹æ¡ˆï¼š

## Phase 1: åŸºç¡€è®¾æ–½è§£è€¦ - è¯¦ç»†å®æ–½æ–¹æ¡ˆï¼ˆ5å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **å¼€å‘è€…Aè´Ÿè´£**: Milestone 1.1 é…ç½®ä¸­å¿ƒåŒ–
- **å¼€å‘è€…Bè´Ÿè´£**: Milestone 1.2 ä¾èµ–æ³¨å…¥å®¹å™¨
- **Day 5**: ä¸¤äººååŒé›†æˆæµ‹è¯•

---

## Milestone 1.1: é…ç½®ä¸­å¿ƒåŒ–ï¼ˆ2å¤©ï¼‰

### Day 1 ä¸Šåˆï¼šé…ç½®æ”¶é›†ä¸åˆ†æï¼ˆ4å°æ—¶ï¼‰

#### 1. æ‰«æç°æœ‰ç¡¬ç¼–ç é…ç½®
```bash
# æ‰§è¡Œé…ç½®æ‰«æè„šæœ¬
node scripts/scan-hardcoded-config.js

# è„šæœ¬å†…å®¹
const glob = require('glob');
const fs = require('fs');

const patterns = [
  /http[s]?:\/\/[^\s'"]+/g,  // URL
  /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g,  // IP
  /[A-Z_]{2,}(?:\s*=\s*['"`].*?['"`])/g,  // å¸¸é‡
  /timeout:\s*\d+/g,  // è¶…æ—¶é…ç½®
  /limit:\s*\d+/g,  // é™åˆ¶é…ç½®
];

const files = glob.sync('src/**/*.{js,ts,vue}');
const hardcoded = [];

files.forEach(file => {
  const content = fs.readFileSync(file, 'utf8');
  patterns.forEach(pattern => {
    const matches = content.match(pattern);
    if (matches) {
      hardcoded.push({ file, matches });
    }
  });
});

fs.writeFileSync('hardcoded-config.json', JSON.stringify(hardcoded, null, 2));
```

#### 2. åˆ›å»ºé…ç½®åˆ†ç±»è¡¨
```javascript
// config-inventory.js
export const configInventory = {
  // APIé…ç½®
  api: {
    baseUrl: 'http://localhost:8088',
    timeout: 10000,
    retryCount: 3,
    retryDelay: 1000
  },
  
  // ä¸šåŠ¡è§„åˆ™é…ç½®
  business: {
    ticket: {
      sla: {
        low: 48,      // å°æ—¶
        medium: 24,
        high: 12,
        urgent: 2
      },
      escalation: {
        checkInterval: 60 * 60 * 1000,  // 1å°æ—¶
        rules: {
          low: { afterHours: 48, nextPriority: 'medium' },
          medium: { afterHours: 24, nextPriority: 'high' },
          high: { afterHours: 12, nextPriority: 'urgent' }
        }
      }
    },
    inspection: {
      floors: {
        floor1: { label: '1æ¥¼', items: 22 },
        floor2: { label: '2æ¥¼', items: 18 },
        floor3: { label: '3æ¥¼', items: 13 },
        floor4: { label: '4æ¥¼', items: 3 }
      },
      anomalyThresholds: {
        temperature: { min: 18, max: 26, unit: 'Â°C' },
        humidity: { min: 40, max: 60, unit: '%' }
      }
    },
    maintenance: {
      reminder: {
        checkInterval: 60 * 60 * 1000,
        reminderPoints: [24 * 60, 12 * 60, 60]  // åˆ†é’Ÿ
      }
    }
  },
  
  // UIé…ç½®
  ui: {
    pagination: {
      defaultPageSize: 20,
      pageSizeOptions: [10, 20, 50, 100]
    },
    dateFormat: 'YYYY-MM-DD HH:mm:ss',
    exportFileNameFormat: 'yyyyMMddHHmmss'
  }
};
```

### Day 1 ä¸‹åˆï¼šå®ç°é…ç½®æœåŠ¡ï¼ˆ4å°æ—¶ï¼‰

#### 1. åˆ›å»ºé…ç½®æœåŠ¡åŸºç¡€æ¶æ„
```typescript
// src/config/ConfigService.ts
export interface ConfigValue {
  value: any;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description?: string;
  validator?: (value: any) => boolean;
  transformer?: (value: any) => any;
}

export class ConfigService {
  private static instance: ConfigService;
  private configs: Map<string, ConfigValue> = new Map();
  private overrides: Map<string, any> = new Map();
  private listeners: Map<string, Set<Function>> = new Map();
  
  private constructor() {
    this.loadDefaultConfigs();
    this.loadEnvironmentConfigs();
    this.loadRuntimeConfigs();
  }
  
  static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }
  
  // è·å–é…ç½®å€¼
  get<T = any>(path: string, defaultValue?: T): T {
    // ä¼˜å…ˆçº§ï¼šè¿è¡Œæ—¶è¦†ç›– > ç¯å¢ƒå˜é‡ > é»˜è®¤é…ç½®
    if (this.overrides.has(path)) {
      return this.overrides.get(path);
    }
    
    const config = this.configs.get(path);
    if (!config) {
      console.warn(`Config not found: ${path}`);
      return defaultValue as T;
    }
    
    let value = config.value;
    
    // åº”ç”¨è½¬æ¢å™¨
    if (config.transformer) {
      value = config.transformer(value);
    }
    
    // åº”ç”¨éªŒè¯å™¨
    if (config.validator && !config.validator(value)) {
      console.error(`Invalid config value for ${path}:`, value);
      return defaultValue as T;
    }
    
    return value;
  }
  
  // è®¾ç½®é…ç½®å€¼ï¼ˆè¿è¡Œæ—¶è¦†ç›–ï¼‰
  set(path: string, value: any): void {
    const oldValue = this.get(path);
    this.overrides.set(path, value);
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.notifyListeners(path, value, oldValue);
    
    // æŒä¹…åŒ–åˆ°localStorageï¼ˆå¯é€‰ï¼‰
    if (typeof window !== 'undefined') {
      const overrides = Object.fromEntries(this.overrides);
      localStorage.setItem('CONFIG_OVERRIDES', JSON.stringify(overrides));
    }
  }
  
  // ç›‘å¬é…ç½®å˜åŒ–
  watch(path: string, callback: (newValue: any, oldValue: any) => void): () => void {
    if (!this.listeners.has(path)) {
      this.listeners.set(path, new Set());
    }
    
    this.listeners.get(path)!.add(callback);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      this.listeners.get(path)?.delete(callback);
    };
  }
  
  // æ‰¹é‡æ›´æ–°é…ç½®
  batch(updates: Record<string, any>): void {
    Object.entries(updates).forEach(([path, value]) => {
      this.set(path, value);
    });
  }
  
  // é‡ç½®é…ç½®
  reset(path?: string): void {
    if (path) {
      this.overrides.delete(path);
    } else {
      this.overrides.clear();
    }
    
    // æ¸…ç†localStorage
    if (typeof window !== 'undefined') {
      localStorage.removeItem('CONFIG_OVERRIDES');
    }
  }
  
  // å¯¼å‡ºé…ç½®
  export(): Record<string, any> {
    const result: Record<string, any> = {};
    
    this.configs.forEach((config, path) => {
      result[path] = this.get(path);
    });
    
    return result;
  }
  
  // ç§æœ‰æ–¹æ³•
  private loadDefaultConfigs(): void {
    // åŠ è½½é»˜è®¤é…ç½®
    this.registerConfig('api.baseUrl', {
      value: 'http://localhost:8088',
      type: 'string',
      description: 'APIåŸºç¡€URL'
    });
    
    this.registerConfig('api.timeout', {
      value: 10000,
      type: 'number',
      description: 'APIè¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰',
      validator: (v) => v > 0 && v < 60000
    });
    
    // ... æ³¨å†Œæ‰€æœ‰é»˜è®¤é…ç½®
  }
  
  private loadEnvironmentConfigs(): void {
    // ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
    if (import.meta.env.VITE_APP_BASE_API) {
      this.configs.set('api.baseUrl', {
        value: import.meta.env.VITE_APP_BASE_API,
        type: 'string'
      });
    }
  }
  
  private loadRuntimeConfigs(): void {
    // ä»localStorageåŠ è½½è¿è¡Œæ—¶è¦†ç›–
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('CONFIG_OVERRIDES');
      if (saved) {
        try {
          const overrides = JSON.parse(saved);
          Object.entries(overrides).forEach(([path, value]) => {
            this.overrides.set(path, value);
          });
        } catch (e) {
          console.error('Failed to load config overrides:', e);
        }
      }
    }
  }
  
  private registerConfig(path: string, config: ConfigValue): void {
    this.configs.set(path, config);
  }
  
  private notifyListeners(path: string, newValue: any, oldValue: any): void {
    const listeners = this.listeners.get(path);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(newValue, oldValue);
        } catch (e) {
          console.error(`Config listener error for ${path}:`, e);
        }
      });
    }
  }
}

// å¯¼å‡ºå•ä¾‹
export const config = ConfigService.getInstance();
```

### Day 2 ä¸Šåˆï¼šè¿ç§»ç°æœ‰é…ç½®ï¼ˆ4å°æ—¶ï¼‰

#### 1. åˆ›å»ºé…ç½®è¿ç§»è„šæœ¬
```javascript
// scripts/migrate-config.js
const fs = require('fs');
const path = require('path');
const { transformSync } = require('@babel/core');

class ConfigMigrator {
  constructor() {
    this.replacements = new Map();
    this.loadReplacementRules();
  }
  
  loadReplacementRules() {
    // å®šä¹‰æ›¿æ¢è§„åˆ™
    this.replacements.set(
      'http://localhost:8088',
      "config.get('api.baseUrl')"
    );
    
    this.replacements.set(
      '60 * 60 * 1000',
      "config.get('business.ticket.escalation.checkInterval')"
    );
    
    // ... æ›´å¤šæ›¿æ¢è§„åˆ™
  }
  
  migrateFile(filePath) {
    let content = fs.readFileSync(filePath, 'utf8');
    let modified = false;
    
    // åº”ç”¨æ›¿æ¢è§„åˆ™
    this.replacements.forEach((replacement, pattern) => {
      if (content.includes(pattern)) {
        content = content.replace(
          new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
          replacement
        );
        modified = true;
      }
    });
    
    // æ·»åŠ importè¯­å¥
    if (modified) {
      if (!content.includes("import { config }")) {
        const importStatement = "import { config } from '@/config/ConfigService';\n";
        content = importStatement + content;
      }
      
      // å†™å›æ–‡ä»¶
      fs.writeFileSync(filePath, content);
      console.log(`âœ… Migrated: ${filePath}`);
    }
    
    return modified;
  }
  
  run() {
    const files = glob.sync('src/**/*.{js,ts,vue}');
    let migratedCount = 0;
    
    files.forEach(file => {
      if (this.migrateFile(file)) {
        migratedCount++;
      }
    });
    
    console.log(`\næ€»è®¡è¿ç§» ${migratedCount} ä¸ªæ–‡ä»¶`);
  }
}

new ConfigMigrator().run();
```

#### 2. é…ç½®ç®¡ç†UIç»„ä»¶
```vue
<!-- src/components/ConfigPanel.vue -->
<template>
  <div class="config-panel" v-if="showPanel">
    <el-drawer
      v-model="visible"
      title="é…ç½®ç®¡ç†"
      direction="rtl"
      size="500px"
    >
      <el-tabs v-model="activeTab">
        <el-tab-pane label="APIé…ç½®" name="api">
          <el-form label-width="120px">
            <el-form-item label="åŸºç¡€URL">
              <el-input v-model="configs.api.baseUrl" />
            </el-form-item>
            <el-form-item label="è¶…æ—¶æ—¶é—´">
              <el-input-number 
                v-model="configs.api.timeout" 
                :min="1000" 
                :max="60000" 
                :step="1000"
              />
            </el-form-item>
          </el-form>
        </el-tab-pane>
        
        <el-tab-pane label="ä¸šåŠ¡è§„åˆ™" name="business">
          <el-collapse>
            <el-collapse-item title="å·¥å•SLAé…ç½®">
              <el-form label-width="100px">
                <el-form-item label="ä½ä¼˜å…ˆçº§">
                  <el-input-number v-model="configs.business.ticket.sla.low" /> å°æ—¶
                </el-form-item>
                <el-form-item label="ä¸­ä¼˜å…ˆçº§">
                  <el-input-number v-model="configs.business.ticket.sla.medium" /> å°æ—¶
                </el-form-item>
                <el-form-item label="é«˜ä¼˜å…ˆçº§">
                  <el-input-number v-model="configs.business.ticket.sla.high" /> å°æ—¶
                </el-form-item>
              </el-form>
            </el-collapse-item>
          </el-collapse>
        </el-tab-pane>
        
        <el-tab-pane label="å¯¼å…¥å¯¼å‡º" name="io">
          <el-button @click="exportConfig">å¯¼å‡ºé…ç½®</el-button>
          <el-button @click="importConfig">å¯¼å…¥é…ç½®</el-button>
          <el-button type="danger" @click="resetConfig">é‡ç½®é…ç½®</el-button>
        </el-tab-pane>
      </el-tabs>
      
      <template #footer>
        <el-button @click="visible = false">å–æ¶ˆ</el-button>
        <el-button type="primary" @click="saveConfig">ä¿å­˜</el-button>
      </template>
    </el-drawer>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { config } from '@/config/ConfigService'

const visible = ref(false)
const activeTab = ref('api')
const showPanel = ref(import.meta.env.DEV)

const configs = reactive({
  api: {},
  business: {},
  ui: {}
})

onMounted(() => {
  loadConfigs()
})

function loadConfigs() {
  // åŠ è½½æ‰€æœ‰é…ç½®
  const allConfigs = config.export()
  
  Object.entries(allConfigs).forEach(([path, value]) => {
    const [category, ...rest] = path.split('.')
    if (configs[category]) {
      setNestedValue(configs[category], rest, value)
    }
  })
}

function saveConfig() {
  // æ‰¹é‡ä¿å­˜é…ç½®
  const updates = {}
  
  Object.entries(configs).forEach(([category, values]) => {
    flattenObject(values, category, updates)
  })
  
  config.batch(updates)
  ElMessage.success('é…ç½®å·²ä¿å­˜')
  visible.value = false
}

function exportConfig() {
  const data = config.export()
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `config_${Date.now()}.json`
  a.click()
}

// å·¥å…·å‡½æ•°
function setNestedValue(obj, path, value) {
  const last = path.pop()
  const target = path.reduce((o, p) => {
    if (!o[p]) o[p] = {}
    return o[p]
  }, obj)
  target[last] = value
}

function flattenObject(obj, prefix, result) {
  Object.entries(obj).forEach(([key, value]) => {
    const path = prefix ? `${prefix}.${key}` : key
    if (typeof value === 'object' && !Array.isArray(value)) {
      flattenObject(value, path, result)
    } else {
      result[path] = value
    }
  })
}
</script>
```

### Day 2 ä¸‹åˆï¼šæµ‹è¯•ä¸éªŒè¯ï¼ˆ4å°æ—¶ï¼‰

#### 1. é…ç½®æœåŠ¡å•å…ƒæµ‹è¯•
```javascript
// src/config/__tests__/ConfigService.test.js
import { describe, it, expect, beforeEach } from 'vitest'
import { ConfigService } from '../ConfigService'

describe('ConfigService', () => {
  let configService
  
  beforeEach(() => {
    configService = new ConfigService()
    configService.reset()
  })
  
  describe('åŸºç¡€åŠŸèƒ½', () => {
    it('åº”è¯¥èƒ½è·å–é»˜è®¤é…ç½®', () => {
      expect(configService.get('api.baseUrl')).toBe('http://localhost:8088')
    })
    
    it('åº”è¯¥èƒ½è®¾ç½®å’Œè·å–é…ç½®', () => {
      configService.set('api.timeout', 5000)
      expect(configService.get('api.timeout')).toBe(5000)
    })
    
    it('åº”è¯¥è¿”å›é»˜è®¤å€¼å½“é…ç½®ä¸å­˜åœ¨', () => {
      expect(configService.get('not.exist', 'default')).toBe('default')
    })
    
    it('åº”è¯¥èƒ½æ‰¹é‡æ›´æ–°é…ç½®', () => {
      configService.batch({
        'api.timeout': 3000,
        'api.retryCount': 5
      })
      
      expect(configService.get('api.timeout')).toBe(3000)
      expect(configService.get('api.retryCount')).toBe(5)
    })
  })
  
  describe('é…ç½®ç›‘å¬', () => {
    it('åº”è¯¥èƒ½ç›‘å¬é…ç½®å˜åŒ–', (done) => {
      configService.watch('api.timeout', (newValue, oldValue) => {
        expect(oldValue).toBe(10000)
        expect(newValue).toBe(5000)
        done()
      })
      
      configService.set('api.timeout', 5000)
    })
    
    it('åº”è¯¥èƒ½å–æ¶ˆç›‘å¬', () => {
      let called = false
      const unwatch = configService.watch('api.timeout', () => {
        called = true
      })
      
      unwatch()
      configService.set('api.timeout', 5000)
      
      expect(called).toBe(false)
    })
  })
  
  describe('é…ç½®éªŒè¯', () => {
    it('åº”è¯¥éªŒè¯é…ç½®å€¼', () => {
      // æ³¨å†Œå¸¦éªŒè¯å™¨çš„é…ç½®
      configService.registerConfig('test.port', {
        value: 8080,
        type: 'number',
        validator: (v) => v > 0 && v < 65536
      })
      
      configService.set('test.port', 70000)
      expect(configService.get('test.port')).toBe(8080) // éªŒè¯å¤±è´¥ï¼Œè¿”å›åŸå€¼
      
      configService.set('test.port', 3000)
      expect(configService.get('test.port')).toBe(3000) // éªŒè¯æˆåŠŸ
    })
  })
  
  describe('é…ç½®è½¬æ¢', () => {
    it('åº”è¯¥åº”ç”¨è½¬æ¢å™¨', () => {
      configService.registerConfig('test.url', {
        value: 'localhost:8080',
        type: 'string',
        transformer: (v) => `http://${v}`
      })
      
      expect(configService.get('test.url')).toBe('http://localhost:8080')
    })
  })
})
```

---

## Milestone 1.2: ä¾èµ–æ³¨å…¥å®¹å™¨ï¼ˆ3å¤©ï¼‰

### Day 3ï¼šå®ç°DIå®¹å™¨æ ¸å¿ƒï¼ˆ8å°æ—¶ï¼‰

#### 1. å®¹å™¨æ ¸å¿ƒå®ç°
```typescript
// src/core/Container.ts
export type Factory<T = any> = (...args: any[]) => T;
export type Token<T = any> = string | symbol | { new(...args: any[]): T };

export interface ServiceDescriptor<T = any> {
  token: Token<T>;
  factory: Factory<T>;
  dependencies?: Token[];
  singleton?: boolean;
  tags?: string[];
}

export class Container {
  private services = new Map<Token, ServiceDescriptor>();
  private instances = new Map<Token, any>();
  private resolving = new Set<Token>();
  
  // æ³¨å†ŒæœåŠ¡
  register<T>(descriptor: ServiceDescriptor<T>): this {
    this.services.set(descriptor.token, descriptor);
    return this;
  }
  
  // ä¾¿æ·æ³¨å†Œæ–¹æ³•
  registerSingleton<T>(token: Token<T>, factory: Factory<T>, deps?: Token[]): this {
    return this.register({
      token,
      factory,
      dependencies: deps,
      singleton: true
    });
  }
  
  registerTransient<T>(token: Token<T>, factory: Factory<T>, deps?: Token[]): this {
    return this.register({
      token,
      factory,
      dependencies: deps,
      singleton: false
    });
  }
  
  // æ³¨å†Œç±»
  registerClass<T>(
    ClassConstructor: new(...args: any[]) => T,
    options?: { singleton?: boolean; dependencies?: Token[] }
  ): this {
    return this.register({
      token: ClassConstructor,
      factory: (...args) => new ClassConstructor(...args),
      ...options
    });
  }
  
  // è§£æä¾èµ–
  resolve<T>(token: Token<T>): T {
    // æ£€æŸ¥å¾ªç¯ä¾èµ–
    if (this.resolving.has(token)) {
      throw new Error(`Circular dependency detected: ${String(token)}`);
    }
    
    // æ£€æŸ¥å•ä¾‹ç¼“å­˜
    if (this.instances.has(token)) {
      return this.instances.get(token);
    }
    
    const descriptor = this.services.get(token);
    if (!descriptor) {
      throw new Error(`Service not found: ${String(token)}`);
    }
    
    this.resolving.add(token);
    
    try {
      // è§£æä¾èµ–
      const dependencies = (descriptor.dependencies || []).map(dep => 
        this.resolve(dep)
      );
      
      // åˆ›å»ºå®ä¾‹
      const instance = descriptor.factory(...dependencies);
      
      // ç¼“å­˜å•ä¾‹
      if (descriptor.singleton !== false) {
        this.instances.set(token, instance);
      }
      
      return instance;
    } finally {
      this.resolving.delete(token);
    }
  }
  
  // æ‰¹é‡è§£æ
  resolveAll<T>(tag: string): T[] {
    const results: T[] = [];
    
    this.services.forEach((descriptor, token) => {
      if (descriptor.tags?.includes(tag)) {
        results.push(this.resolve(token));
      }
    });
    
    return results;
  }
  
  // æ£€æŸ¥æ˜¯å¦æ³¨å†Œ
  has(token: Token): boolean {
    return this.services.has(token);
  }
  
  // æ¸…ç†å®¹å™¨
  clear(): void {
    this.services.clear();
    this.instances.clear();
    this.resolving.clear();
  }
  
  // åˆ›å»ºå­å®¹å™¨
  createScope(): Container {
    const child = new Container();
    
    // å¤åˆ¶æœåŠ¡å®šä¹‰ï¼ˆä¸å¤åˆ¶å®ä¾‹ï¼‰
    this.services.forEach((descriptor, token) => {
      child.services.set(token, descriptor);
    });
    
    return child;
  }
}

// å…¨å±€å®¹å™¨å®ä¾‹
export const container = new Container();

// è£…é¥°å™¨æ”¯æŒ
export function Injectable(options?: { singleton?: boolean }) {
  return function(target: any) {
    // ä»æ„é€ å‡½æ•°å‚æ•°æ¨æ–­ä¾èµ–
    const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];
    
    container.registerClass(target, {
      singleton: options?.singleton !== false,
      dependencies: paramTypes
    });
    
    return target;
  };
}

export function Inject(token: Token) {
  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {
    const existingTokens = Reflect.getMetadata('custom:inject-tokens', target) || [];
    existingTokens[parameterIndex] = token;
    Reflect.defineMetadata('custom:inject-tokens', existingTokens, target);
  };
}
```

#### 2. æœåŠ¡å®šä¹‰å’Œæ³¨å†Œ
```typescript
// src/core/services/index.ts
import { container } from '../Container';
import { EventBus } from './EventBus';
import { Logger } from './Logger';
import { HttpClient } from './HttpClient';

// æ³¨å†ŒåŸºç¡€æœåŠ¡
export function registerCoreServices() {
  // äº‹ä»¶æ€»çº¿
  container.registerSingleton('EventBus', () => new EventBus());
  
  // æ—¥å¿—æœåŠ¡
  container.registerSingleton('Logger', () => new Logger({
    level: import.meta.env.DEV ? 'debug' : 'info'
  }));
  
  // HTTPå®¢æˆ·ç«¯
  container.registerSingleton('HttpClient', () => new HttpClient({
    baseURL: config.get('api.baseUrl'),
    timeout: config.get('api.timeout')
  }));
  
  // è®¤è¯æœåŠ¡
  container.registerSingleton('AuthService', 
    (http: HttpClient, eventBus: EventBus) => {
      return new AuthService(http, eventBus);
    },
    ['HttpClient', 'EventBus']
  );
}

// æ³¨å†Œä¸šåŠ¡æœåŠ¡
export function registerBusinessServices() {
  // å·¥å•æœåŠ¡
  container.registerSingleton('TicketRepository',
    (http: HttpClient) => new TicketRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('TicketDomain',
    (repo: TicketRepository, eventBus: EventBus, logger: Logger) => {
      return new TicketDomain(repo, eventBus, logger);
    },
    ['TicketRepository', 'EventBus', 'Logger']
  );
  
  // å·¡æ£€æœåŠ¡
  container.registerSingleton('InspectionRepository',
    (http: HttpClient) => new InspectionRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('InspectionDomain',
    (repo: InspectionRepository, eventBus: EventBus) => {
      return new InspectionDomain(repo, eventBus);
    },
    ['InspectionRepository', 'EventBus']
  );
  
  // ç»´ä¿æœåŠ¡
  container.registerSingleton('MaintenanceRepository',
    (http: HttpClient) => new MaintenanceRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('MaintenanceDomain',
    (repo: MaintenanceRepository, eventBus: EventBus) => {
      return new MaintenanceDomain(repo, eventBus);
    },
    ['MaintenanceRepository', 'EventBus']
  );
}
```

### Day 4ï¼šæœåŠ¡æ”¹é€ ä¸é€‚é…ï¼ˆ8å°æ—¶ï¼‰

#### 1. æ”¹é€ ç°æœ‰æœåŠ¡ä½¿ç”¨DI
```typescript
// src/services/TicketEscalationService.ts (æ”¹é€ å‰)
class TicketEscalationService {
  constructor() {
    this.checkInterval = 60 * 60 * 1000;
    this.timer = null;
  }
  
  async checkAndEscalate() {
    // ç›´æ¥è°ƒç”¨API
    const tickets = await listTicket({ status: 'pending,processing' });
    // ...
  }
}

// src/services/TicketEscalationService.ts (æ”¹é€ å)
import { Injectable, Inject } from '@/core/Container';

@Injectable({ singleton: true })
export class TicketEscalationService {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.checkInterval = this.config.get('business.ticket.escalation.checkInterval');
    this.timer = null;
  }
  
  async checkAndEscalate() {
    try {
      this.logger.info('Starting ticket escalation check');
      
      const tickets = await this.repository.findOverdue();
      
      for (const ticket of tickets) {
        const shouldEscalate = this.evaluateEscalation(ticket);
        
        if (shouldEscalate) {
          await this.escalate(ticket);
          
          // å‘å¸ƒäº‹ä»¶è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨
          this.eventBus.emit('ticket.escalated', {
            ticketId: ticket.id,
            oldPriority: ticket.priority,
            newPriority: this.getNextPriority(ticket.priority)
          });
        }
      }
      
      this.logger.info(`Escalation check completed. Processed ${tickets.length} tickets`);
    } catch (error) {
      this.logger.error('Escalation check failed', error);
      this.eventBus.emit('service.error', {
        service: 'TicketEscalation',
        error
      });
    }
  }
  
  private evaluateEscalation(ticket: Ticket): boolean {
    const rules = this.config.get('business.ticket.escalation.rules');
    const rule = rules[ticket.priority];
    
    if (!rule) return false;
    
    const hoursOverdue = this.calculateOverdueHours(ticket);
    return hoursOverdue > rule.afterHours;
  }
  
  private async escalate(ticket: Ticket): Promise<void> {
    const newPriority = this.getNextPriority(ticket.priority);
    
    await this.repository.updatePriority(ticket.id, newPriority);
    
    // è®°å½•å®¡è®¡æ—¥å¿—
    this.logger.audit('Ticket escalated', {
      ticketId: ticket.id,
      oldPriority: ticket.priority,
      newPriority,
      automatic: true
    });
  }
}
```

#### 2. åˆ›å»ºæœåŠ¡é€‚é…å™¨ï¼ˆå‘åå…¼å®¹ï¼‰
```typescript
// src/adapters/ServiceAdapter.ts
import { container } from '@/core/Container';
import { FeatureFlags } from '@/config/FeatureFlags';

export class ServiceAdapter {
  static getTicketService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('TicketDomain');
    }
    
    // è¿”å›æ—§çš„æœåŠ¡å®ä¾‹
    return window.legacyTicketService;
  }
  
  static getInspectionService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('InspectionDomain');
    }
    
    return window.legacyInspectionService;
  }
  
  static getMaintenanceService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('MaintenanceDomain');
    }
    
    return window.legacyMaintenanceService;
  }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
export default {
  setup() {
    const ticketService = ServiceAdapter.getTicketService();
    
    const createTicket = async (data) => {
      // æ–°æ—§æœåŠ¡æ¥å£ä¿æŒä¸€è‡´
      return await ticketService.create(data);
    };
    
    return { createTicket };
  }
};
```

### Day 5ï¼šé›†æˆæµ‹è¯•ä¸æ–‡æ¡£ï¼ˆ8å°æ—¶ï¼‰

#### 1. é›†æˆæµ‹è¯•å¥—ä»¶
```javascript
// src/__tests__/integration/phase1.test.js
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ConfigService } from '@/config/ConfigService';
import { Container } from '@/core/Container';
import { FeatureFlags } from '@/config/FeatureFlags';

describe('Phase 1: åŸºç¡€è®¾æ–½é›†æˆæµ‹è¯•', () => {
  let config;
  let container;
  
  beforeEach(() => {
    config = new ConfigService();
    container = new Container();
    
    // å¯ç”¨æ–°ç‰¹æ€§
    FeatureFlags.setFlag('USE_CONFIG_SERVICE', true);
    FeatureFlags.setFlag('USE_DI_CONTAINER', true);
  });
  
  afterEach(() => {
    config.reset();
    container.clear();
    FeatureFlags.reset();
  });
  
  describe('é…ç½®æœåŠ¡é›†æˆ', () => {
    it('åº”è¯¥èƒ½ä»é…ç½®æœåŠ¡è¯»å–APIé…ç½®', () => {
      const baseUrl = config.get('api.baseUrl');
      expect(baseUrl).toBeDefined();
      expect(baseUrl).toMatch(/^https?:\/\//);
    });
    
    it('åº”è¯¥èƒ½åŠ¨æ€æ›´æ–°é…ç½®å¹¶å½±å“æœåŠ¡è¡Œä¸º', async () => {
      // æ›´æ”¹é…ç½®
      config.set('api.timeout', 5000);
      
      // åˆ›å»ºä½¿ç”¨é…ç½®çš„æœåŠ¡
      const httpClient = container.resolve('HttpClient');
      
      // éªŒè¯é…ç½®ç”Ÿæ•ˆ
      expect(httpClient.config.timeout).toBe(5000);
    });
    
    it('é…ç½®å˜åŒ–åº”è¯¥è§¦å‘ç›‘å¬å™¨', (done) => {
      config.watch('business.ticket.sla.high', (newValue, oldValue) => {
        expect(oldValue).toBe(12);
        expect(newValue).toBe(6);
        done();
      });
      
      config.set('business.ticket.sla.high', 6);
    });
  });
  
  describe('ä¾èµ–æ³¨å…¥é›†æˆ', () => {
    it('åº”è¯¥èƒ½è§£æå®Œæ•´çš„æœåŠ¡ä¾èµ–é“¾', () => {
      registerCoreServices();
      registerBusinessServices();
      
      const ticketDomain = container.resolve('TicketDomain');
      
      expect(ticketDomain).toBeDefined();
      expect(ticketDomain.repository).toBeDefined();
      expect(ticketDomain.eventBus).toBeDefined();
      expect(ticketDomain.logger).toBeDefined();
    });
    
    it('å•ä¾‹æœåŠ¡åº”è¯¥è¿”å›ç›¸åŒå®ä¾‹', () => {
      container.registerSingleton('TestService', () => ({ id: Math.random() }));
      
      const instance1 = container.resolve('TestService');
      const instance2 = container.resolve('TestService');
      
      expect(instance1).toBe(instance2);
    });
    
    it('ç¬æ€æœåŠ¡åº”è¯¥è¿”å›ä¸åŒå®ä¾‹', () => {
      container.registerTransient('TestService', () => ({ id: Math.random() }));
      
      const instance1 = container.resolve('TestService');
      const instance2 = container.resolve('TestService');
      
      expect(instance1).not.toBe(instance2);
    });
    
    it('åº”è¯¥æ£€æµ‹å¾ªç¯ä¾èµ–', () => {
      container.register({
        token: 'ServiceA',
        factory: (b) => ({ b }),
        dependencies: ['ServiceB']
      });
      
      container.register({
        token: 'ServiceB',
        factory: (a) => ({ a }),
        dependencies: ['ServiceA']
      });
      
      expect(() => container.resolve('ServiceA')).toThrow('Circular dependency');
    });
  });
  
  describe('æ–°æ—§ç³»ç»Ÿå…¼å®¹æ€§', () => {
    it('å…³é—­ç‰¹æ€§å¼€å…³åº”è¯¥ä½¿ç”¨æ—§ç³»ç»Ÿ', () => {
      FeatureFlags.setFlag('USE_DI_CONTAINER', false);
      
      const service = ServiceAdapter.getTicketService();
      expect(service).toBe(window.legacyTicketService);
    });
    
    it('å¼€å¯ç‰¹æ€§å¼€å…³åº”è¯¥ä½¿ç”¨æ–°ç³»ç»Ÿ', () => {
      FeatureFlags.setFlag('USE_DI_CONTAINER', true);
      
      const service = ServiceAdapter.getTicketService();
      expect(service).toBe(container.resolve('TicketDomain'));
    });
  });
});
```

#### 2. æ€§èƒ½æµ‹è¯•
```javascript
// src/__tests__/performance/phase1-perf.test.js
describe('Phase 1: æ€§èƒ½æµ‹è¯•', () => {
  it('é…ç½®è¯»å–æ€§èƒ½åº”è¯¥ä¼˜äºç›´æ¥è®¿é—®', () => {
    const iterations = 10000;
    
    // æµ‹è¯•ç›´æ¥è®¿é—®
    const directStart = performance.now();
    for (let i = 0; i < iterations; i++) {
      const value = import.meta.env.VITE_APP_BASE_API;
    }
    const directTime = performance.now() - directStart;
    
    // æµ‹è¯•é…ç½®æœåŠ¡
    const configStart = performance.now();
    for (let i = 0; i < iterations; i++) {
      const value = config.get('api.baseUrl');
    }
    const configTime = performance.now() - configStart;
    
    console.log(`ç›´æ¥è®¿é—®: ${directTime}ms, é…ç½®æœåŠ¡: ${configTime}ms`);
    
    // é…ç½®æœåŠ¡åº”è¯¥åœ¨å¯æ¥å—èŒƒå›´å†…ï¼ˆä¸è¶…è¿‡2å€ï¼‰
    expect(configTime).toBeLessThan(directTime * 2);
  });
  
  it('DIå®¹å™¨è§£ææ€§èƒ½æµ‹è¯•', () => {
    const iterations = 1000;
    
    // æ³¨å†Œå¤æ‚ä¾èµ–é“¾
    for (let i = 0; i < 10; i++) {
      container.registerTransient(`Service${i}`, () => ({
        id: i,
        timestamp: Date.now()
      }));
    }
    
    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
      container.resolve('Service5');
    }
    const elapsed = performance.now() - start;
    
    console.log(`è§£æ ${iterations} æ¬¡è€—æ—¶: ${elapsed}ms`);
    
    // å¹³å‡æ¯æ¬¡è§£æåº”è¯¥å°äº1ms
    expect(elapsed / iterations).toBeLessThan(1);
  });
});
```

## ğŸ“Š Phase 1 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] é…ç½®æœåŠ¡æµ‹è¯•è¦†ç›–ç‡ > 90%
- [ ] DIå®¹å™¨æµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] æ‰€æœ‰ç¡¬ç¼–ç é…ç½®å·²è¿ç§»
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] æ— å¾ªç¯ä¾èµ–

### åŠŸèƒ½éªŒè¯
- [ ] é…ç½®å¯ä»¥åŠ¨æ€æ›´æ–°
- [ ] é…ç½®å˜æ›´èƒ½è§¦å‘ç›‘å¬
- [ ] DIå®¹å™¨èƒ½æ­£ç¡®è§£æä¾èµ–
- [ ] æ–°æ—§ç³»ç»Ÿèƒ½å¹³æ»‘åˆ‡æ¢
- [ ] ç‰¹æ€§å¼€å…³å·¥ä½œæ­£å¸¸

### æ–‡æ¡£äº¤ä»˜
- [ ] é…ç½®é¡¹æ¸…å•æ–‡æ¡£
- [ ] DIå®¹å™¨ä½¿ç”¨æŒ‡å—
- [ ] è¿ç§»æŒ‡å—
- [ ] APIæ–‡æ¡£
- [ ] æ•…éšœæ’æŸ¥æŒ‡å—

## ğŸš€ Phase 1 äº¤ä»˜ç‰©

1. **ä»£ç äº¤ä»˜**
   - ConfigServiceå®Œæ•´å®ç°
   - Containerå®Œæ•´å®ç°
   - æ‰€æœ‰æœåŠ¡é€‚é…å™¨
   - æµ‹è¯•å¥—ä»¶

2. **é…ç½®æ–‡ä»¶**
   - config.default.json
   - config.development.json
   - config.production.json

3. **æ–‡æ¡£äº¤ä»˜**
   - CONFIGURATION.md
   - DEPENDENCY-INJECTION.md
   - MIGRATION-GUIDE.md

4. **å·¥å…·è„šæœ¬**
   - migrate-config.js
   - scan-hardcoded.js
   - verify-migration.js

è¿™å°±æ˜¯Phase 1çš„å®Œæ•´å®æ–½æ–¹æ¡ˆã€‚éœ€è¦æˆ‘ç»§ç»­æä¾›Phase 2ï¼ˆStoreå±‚é‡æ„ï¼‰çš„è¯¦ç»†æ–¹æ¡ˆå—ï¼Ÿ