我理解你想要Phase 1（基础设施解耦）的详细实施内容。让我提供完整的Phase 1实施方案：

## Phase 1: 基础设施解耦 - 详细实施方案（5天）

### 📅 时间安排
- **开发者A负责**: Milestone 1.1 配置中心化
- **开发者B负责**: Milestone 1.2 依赖注入容器
- **Day 5**: 两人协同集成测试

---

## Milestone 1.1: 配置中心化（2天）

### Day 1 上午：配置收集与分析（4小时）

#### 1. 扫描现有硬编码配置
```bash
# 执行配置扫描脚本
node scripts/scan-hardcoded-config.js

# 脚本内容
const glob = require('glob');
const fs = require('fs');

const patterns = [
  /http[s]?:\/\/[^\s'"]+/g,  // URL
  /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g,  // IP
  /[A-Z_]{2,}(?:\s*=\s*['"`].*?['"`])/g,  // 常量
  /timeout:\s*\d+/g,  // 超时配置
  /limit:\s*\d+/g,  // 限制配置
];

const files = glob.sync('src/**/*.{js,ts,vue}');
const hardcoded = [];

files.forEach(file => {
  const content = fs.readFileSync(file, 'utf8');
  patterns.forEach(pattern => {
    const matches = content.match(pattern);
    if (matches) {
      hardcoded.push({ file, matches });
    }
  });
});

fs.writeFileSync('hardcoded-config.json', JSON.stringify(hardcoded, null, 2));
```

#### 2. 创建配置分类表
```javascript
// config-inventory.js
export const configInventory = {
  // API配置
  api: {
    baseUrl: 'http://localhost:8088',
    timeout: 10000,
    retryCount: 3,
    retryDelay: 1000
  },
  
  // 业务规则配置
  business: {
    ticket: {
      sla: {
        low: 48,      // 小时
        medium: 24,
        high: 12,
        urgent: 2
      },
      escalation: {
        checkInterval: 60 * 60 * 1000,  // 1小时
        rules: {
          low: { afterHours: 48, nextPriority: 'medium' },
          medium: { afterHours: 24, nextPriority: 'high' },
          high: { afterHours: 12, nextPriority: 'urgent' }
        }
      }
    },
    inspection: {
      floors: {
        floor1: { label: '1楼', items: 22 },
        floor2: { label: '2楼', items: 18 },
        floor3: { label: '3楼', items: 13 },
        floor4: { label: '4楼', items: 3 }
      },
      anomalyThresholds: {
        temperature: { min: 18, max: 26, unit: '°C' },
        humidity: { min: 40, max: 60, unit: '%' }
      }
    },
    maintenance: {
      reminder: {
        checkInterval: 60 * 60 * 1000,
        reminderPoints: [24 * 60, 12 * 60, 60]  // 分钟
      }
    }
  },
  
  // UI配置
  ui: {
    pagination: {
      defaultPageSize: 20,
      pageSizeOptions: [10, 20, 50, 100]
    },
    dateFormat: 'YYYY-MM-DD HH:mm:ss',
    exportFileNameFormat: 'yyyyMMddHHmmss'
  }
};
```

### Day 1 下午：实现配置服务（4小时）

#### 1. 创建配置服务基础架构
```typescript
// src/config/ConfigService.ts
export interface ConfigValue {
  value: any;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description?: string;
  validator?: (value: any) => boolean;
  transformer?: (value: any) => any;
}

export class ConfigService {
  private static instance: ConfigService;
  private configs: Map<string, ConfigValue> = new Map();
  private overrides: Map<string, any> = new Map();
  private listeners: Map<string, Set<Function>> = new Map();
  
  private constructor() {
    this.loadDefaultConfigs();
    this.loadEnvironmentConfigs();
    this.loadRuntimeConfigs();
  }
  
  static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }
  
  // 获取配置值
  get<T = any>(path: string, defaultValue?: T): T {
    // 优先级：运行时覆盖 > 环境变量 > 默认配置
    if (this.overrides.has(path)) {
      return this.overrides.get(path);
    }
    
    const config = this.configs.get(path);
    if (!config) {
      console.warn(`Config not found: ${path}`);
      return defaultValue as T;
    }
    
    let value = config.value;
    
    // 应用转换器
    if (config.transformer) {
      value = config.transformer(value);
    }
    
    // 应用验证器
    if (config.validator && !config.validator(value)) {
      console.error(`Invalid config value for ${path}:`, value);
      return defaultValue as T;
    }
    
    return value;
  }
  
  // 设置配置值（运行时覆盖）
  set(path: string, value: any): void {
    const oldValue = this.get(path);
    this.overrides.set(path, value);
    
    // 通知监听器
    this.notifyListeners(path, value, oldValue);
    
    // 持久化到localStorage（可选）
    if (typeof window !== 'undefined') {
      const overrides = Object.fromEntries(this.overrides);
      localStorage.setItem('CONFIG_OVERRIDES', JSON.stringify(overrides));
    }
  }
  
  // 监听配置变化
  watch(path: string, callback: (newValue: any, oldValue: any) => void): () => void {
    if (!this.listeners.has(path)) {
      this.listeners.set(path, new Set());
    }
    
    this.listeners.get(path)!.add(callback);
    
    // 返回取消监听函数
    return () => {
      this.listeners.get(path)?.delete(callback);
    };
  }
  
  // 批量更新配置
  batch(updates: Record<string, any>): void {
    Object.entries(updates).forEach(([path, value]) => {
      this.set(path, value);
    });
  }
  
  // 重置配置
  reset(path?: string): void {
    if (path) {
      this.overrides.delete(path);
    } else {
      this.overrides.clear();
    }
    
    // 清理localStorage
    if (typeof window !== 'undefined') {
      localStorage.removeItem('CONFIG_OVERRIDES');
    }
  }
  
  // 导出配置
  export(): Record<string, any> {
    const result: Record<string, any> = {};
    
    this.configs.forEach((config, path) => {
      result[path] = this.get(path);
    });
    
    return result;
  }
  
  // 私有方法
  private loadDefaultConfigs(): void {
    // 加载默认配置
    this.registerConfig('api.baseUrl', {
      value: 'http://localhost:8088',
      type: 'string',
      description: 'API基础URL'
    });
    
    this.registerConfig('api.timeout', {
      value: 10000,
      type: 'number',
      description: 'API超时时间（毫秒）',
      validator: (v) => v > 0 && v < 60000
    });
    
    // ... 注册所有默认配置
  }
  
  private loadEnvironmentConfigs(): void {
    // 从环境变量加载配置
    if (import.meta.env.VITE_APP_BASE_API) {
      this.configs.set('api.baseUrl', {
        value: import.meta.env.VITE_APP_BASE_API,
        type: 'string'
      });
    }
  }
  
  private loadRuntimeConfigs(): void {
    // 从localStorage加载运行时覆盖
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('CONFIG_OVERRIDES');
      if (saved) {
        try {
          const overrides = JSON.parse(saved);
          Object.entries(overrides).forEach(([path, value]) => {
            this.overrides.set(path, value);
          });
        } catch (e) {
          console.error('Failed to load config overrides:', e);
        }
      }
    }
  }
  
  private registerConfig(path: string, config: ConfigValue): void {
    this.configs.set(path, config);
  }
  
  private notifyListeners(path: string, newValue: any, oldValue: any): void {
    const listeners = this.listeners.get(path);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(newValue, oldValue);
        } catch (e) {
          console.error(`Config listener error for ${path}:`, e);
        }
      });
    }
  }
}

// 导出单例
export const config = ConfigService.getInstance();
```

### Day 2 上午：迁移现有配置（4小时）

#### 1. 创建配置迁移脚本
```javascript
// scripts/migrate-config.js
const fs = require('fs');
const path = require('path');
const { transformSync } = require('@babel/core');

class ConfigMigrator {
  constructor() {
    this.replacements = new Map();
    this.loadReplacementRules();
  }
  
  loadReplacementRules() {
    // 定义替换规则
    this.replacements.set(
      'http://localhost:8088',
      "config.get('api.baseUrl')"
    );
    
    this.replacements.set(
      '60 * 60 * 1000',
      "config.get('business.ticket.escalation.checkInterval')"
    );
    
    // ... 更多替换规则
  }
  
  migrateFile(filePath) {
    let content = fs.readFileSync(filePath, 'utf8');
    let modified = false;
    
    // 应用替换规则
    this.replacements.forEach((replacement, pattern) => {
      if (content.includes(pattern)) {
        content = content.replace(
          new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
          replacement
        );
        modified = true;
      }
    });
    
    // 添加import语句
    if (modified) {
      if (!content.includes("import { config }")) {
        const importStatement = "import { config } from '@/config/ConfigService';\n";
        content = importStatement + content;
      }
      
      // 写回文件
      fs.writeFileSync(filePath, content);
      console.log(`✅ Migrated: ${filePath}`);
    }
    
    return modified;
  }
  
  run() {
    const files = glob.sync('src/**/*.{js,ts,vue}');
    let migratedCount = 0;
    
    files.forEach(file => {
      if (this.migrateFile(file)) {
        migratedCount++;
      }
    });
    
    console.log(`\n总计迁移 ${migratedCount} 个文件`);
  }
}

new ConfigMigrator().run();
```

#### 2. 配置管理UI组件
```vue
<!-- src/components/ConfigPanel.vue -->
<template>
  <div class="config-panel" v-if="showPanel">
    <el-drawer
      v-model="visible"
      title="配置管理"
      direction="rtl"
      size="500px"
    >
      <el-tabs v-model="activeTab">
        <el-tab-pane label="API配置" name="api">
          <el-form label-width="120px">
            <el-form-item label="基础URL">
              <el-input v-model="configs.api.baseUrl" />
            </el-form-item>
            <el-form-item label="超时时间">
              <el-input-number 
                v-model="configs.api.timeout" 
                :min="1000" 
                :max="60000" 
                :step="1000"
              />
            </el-form-item>
          </el-form>
        </el-tab-pane>
        
        <el-tab-pane label="业务规则" name="business">
          <el-collapse>
            <el-collapse-item title="工单SLA配置">
              <el-form label-width="100px">
                <el-form-item label="低优先级">
                  <el-input-number v-model="configs.business.ticket.sla.low" /> 小时
                </el-form-item>
                <el-form-item label="中优先级">
                  <el-input-number v-model="configs.business.ticket.sla.medium" /> 小时
                </el-form-item>
                <el-form-item label="高优先级">
                  <el-input-number v-model="configs.business.ticket.sla.high" /> 小时
                </el-form-item>
              </el-form>
            </el-collapse-item>
          </el-collapse>
        </el-tab-pane>
        
        <el-tab-pane label="导入导出" name="io">
          <el-button @click="exportConfig">导出配置</el-button>
          <el-button @click="importConfig">导入配置</el-button>
          <el-button type="danger" @click="resetConfig">重置配置</el-button>
        </el-tab-pane>
      </el-tabs>
      
      <template #footer>
        <el-button @click="visible = false">取消</el-button>
        <el-button type="primary" @click="saveConfig">保存</el-button>
      </template>
    </el-drawer>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { config } from '@/config/ConfigService'

const visible = ref(false)
const activeTab = ref('api')
const showPanel = ref(import.meta.env.DEV)

const configs = reactive({
  api: {},
  business: {},
  ui: {}
})

onMounted(() => {
  loadConfigs()
})

function loadConfigs() {
  // 加载所有配置
  const allConfigs = config.export()
  
  Object.entries(allConfigs).forEach(([path, value]) => {
    const [category, ...rest] = path.split('.')
    if (configs[category]) {
      setNestedValue(configs[category], rest, value)
    }
  })
}

function saveConfig() {
  // 批量保存配置
  const updates = {}
  
  Object.entries(configs).forEach(([category, values]) => {
    flattenObject(values, category, updates)
  })
  
  config.batch(updates)
  ElMessage.success('配置已保存')
  visible.value = false
}

function exportConfig() {
  const data = config.export()
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `config_${Date.now()}.json`
  a.click()
}

// 工具函数
function setNestedValue(obj, path, value) {
  const last = path.pop()
  const target = path.reduce((o, p) => {
    if (!o[p]) o[p] = {}
    return o[p]
  }, obj)
  target[last] = value
}

function flattenObject(obj, prefix, result) {
  Object.entries(obj).forEach(([key, value]) => {
    const path = prefix ? `${prefix}.${key}` : key
    if (typeof value === 'object' && !Array.isArray(value)) {
      flattenObject(value, path, result)
    } else {
      result[path] = value
    }
  })
}
</script>
```

### Day 2 下午：测试与验证（4小时）

#### 1. 配置服务单元测试
```javascript
// src/config/__tests__/ConfigService.test.js
import { describe, it, expect, beforeEach } from 'vitest'
import { ConfigService } from '../ConfigService'

describe('ConfigService', () => {
  let configService
  
  beforeEach(() => {
    configService = new ConfigService()
    configService.reset()
  })
  
  describe('基础功能', () => {
    it('应该能获取默认配置', () => {
      expect(configService.get('api.baseUrl')).toBe('http://localhost:8088')
    })
    
    it('应该能设置和获取配置', () => {
      configService.set('api.timeout', 5000)
      expect(configService.get('api.timeout')).toBe(5000)
    })
    
    it('应该返回默认值当配置不存在', () => {
      expect(configService.get('not.exist', 'default')).toBe('default')
    })
    
    it('应该能批量更新配置', () => {
      configService.batch({
        'api.timeout': 3000,
        'api.retryCount': 5
      })
      
      expect(configService.get('api.timeout')).toBe(3000)
      expect(configService.get('api.retryCount')).toBe(5)
    })
  })
  
  describe('配置监听', () => {
    it('应该能监听配置变化', (done) => {
      configService.watch('api.timeout', (newValue, oldValue) => {
        expect(oldValue).toBe(10000)
        expect(newValue).toBe(5000)
        done()
      })
      
      configService.set('api.timeout', 5000)
    })
    
    it('应该能取消监听', () => {
      let called = false
      const unwatch = configService.watch('api.timeout', () => {
        called = true
      })
      
      unwatch()
      configService.set('api.timeout', 5000)
      
      expect(called).toBe(false)
    })
  })
  
  describe('配置验证', () => {
    it('应该验证配置值', () => {
      // 注册带验证器的配置
      configService.registerConfig('test.port', {
        value: 8080,
        type: 'number',
        validator: (v) => v > 0 && v < 65536
      })
      
      configService.set('test.port', 70000)
      expect(configService.get('test.port')).toBe(8080) // 验证失败，返回原值
      
      configService.set('test.port', 3000)
      expect(configService.get('test.port')).toBe(3000) // 验证成功
    })
  })
  
  describe('配置转换', () => {
    it('应该应用转换器', () => {
      configService.registerConfig('test.url', {
        value: 'localhost:8080',
        type: 'string',
        transformer: (v) => `http://${v}`
      })
      
      expect(configService.get('test.url')).toBe('http://localhost:8080')
    })
  })
})
```

---

## Milestone 1.2: 依赖注入容器（3天）

### Day 3：实现DI容器核心（8小时）

#### 1. 容器核心实现
```typescript
// src/core/Container.ts
export type Factory<T = any> = (...args: any[]) => T;
export type Token<T = any> = string | symbol | { new(...args: any[]): T };

export interface ServiceDescriptor<T = any> {
  token: Token<T>;
  factory: Factory<T>;
  dependencies?: Token[];
  singleton?: boolean;
  tags?: string[];
}

export class Container {
  private services = new Map<Token, ServiceDescriptor>();
  private instances = new Map<Token, any>();
  private resolving = new Set<Token>();
  
  // 注册服务
  register<T>(descriptor: ServiceDescriptor<T>): this {
    this.services.set(descriptor.token, descriptor);
    return this;
  }
  
  // 便捷注册方法
  registerSingleton<T>(token: Token<T>, factory: Factory<T>, deps?: Token[]): this {
    return this.register({
      token,
      factory,
      dependencies: deps,
      singleton: true
    });
  }
  
  registerTransient<T>(token: Token<T>, factory: Factory<T>, deps?: Token[]): this {
    return this.register({
      token,
      factory,
      dependencies: deps,
      singleton: false
    });
  }
  
  // 注册类
  registerClass<T>(
    ClassConstructor: new(...args: any[]) => T,
    options?: { singleton?: boolean; dependencies?: Token[] }
  ): this {
    return this.register({
      token: ClassConstructor,
      factory: (...args) => new ClassConstructor(...args),
      ...options
    });
  }
  
  // 解析依赖
  resolve<T>(token: Token<T>): T {
    // 检查循环依赖
    if (this.resolving.has(token)) {
      throw new Error(`Circular dependency detected: ${String(token)}`);
    }
    
    // 检查单例缓存
    if (this.instances.has(token)) {
      return this.instances.get(token);
    }
    
    const descriptor = this.services.get(token);
    if (!descriptor) {
      throw new Error(`Service not found: ${String(token)}`);
    }
    
    this.resolving.add(token);
    
    try {
      // 解析依赖
      const dependencies = (descriptor.dependencies || []).map(dep => 
        this.resolve(dep)
      );
      
      // 创建实例
      const instance = descriptor.factory(...dependencies);
      
      // 缓存单例
      if (descriptor.singleton !== false) {
        this.instances.set(token, instance);
      }
      
      return instance;
    } finally {
      this.resolving.delete(token);
    }
  }
  
  // 批量解析
  resolveAll<T>(tag: string): T[] {
    const results: T[] = [];
    
    this.services.forEach((descriptor, token) => {
      if (descriptor.tags?.includes(tag)) {
        results.push(this.resolve(token));
      }
    });
    
    return results;
  }
  
  // 检查是否注册
  has(token: Token): boolean {
    return this.services.has(token);
  }
  
  // 清理容器
  clear(): void {
    this.services.clear();
    this.instances.clear();
    this.resolving.clear();
  }
  
  // 创建子容器
  createScope(): Container {
    const child = new Container();
    
    // 复制服务定义（不复制实例）
    this.services.forEach((descriptor, token) => {
      child.services.set(token, descriptor);
    });
    
    return child;
  }
}

// 全局容器实例
export const container = new Container();

// 装饰器支持
export function Injectable(options?: { singleton?: boolean }) {
  return function(target: any) {
    // 从构造函数参数推断依赖
    const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];
    
    container.registerClass(target, {
      singleton: options?.singleton !== false,
      dependencies: paramTypes
    });
    
    return target;
  };
}

export function Inject(token: Token) {
  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {
    const existingTokens = Reflect.getMetadata('custom:inject-tokens', target) || [];
    existingTokens[parameterIndex] = token;
    Reflect.defineMetadata('custom:inject-tokens', existingTokens, target);
  };
}
```

#### 2. 服务定义和注册
```typescript
// src/core/services/index.ts
import { container } from '../Container';
import { EventBus } from './EventBus';
import { Logger } from './Logger';
import { HttpClient } from './HttpClient';

// 注册基础服务
export function registerCoreServices() {
  // 事件总线
  container.registerSingleton('EventBus', () => new EventBus());
  
  // 日志服务
  container.registerSingleton('Logger', () => new Logger({
    level: import.meta.env.DEV ? 'debug' : 'info'
  }));
  
  // HTTP客户端
  container.registerSingleton('HttpClient', () => new HttpClient({
    baseURL: config.get('api.baseUrl'),
    timeout: config.get('api.timeout')
  }));
  
  // 认证服务
  container.registerSingleton('AuthService', 
    (http: HttpClient, eventBus: EventBus) => {
      return new AuthService(http, eventBus);
    },
    ['HttpClient', 'EventBus']
  );
}

// 注册业务服务
export function registerBusinessServices() {
  // 工单服务
  container.registerSingleton('TicketRepository',
    (http: HttpClient) => new TicketRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('TicketDomain',
    (repo: TicketRepository, eventBus: EventBus, logger: Logger) => {
      return new TicketDomain(repo, eventBus, logger);
    },
    ['TicketRepository', 'EventBus', 'Logger']
  );
  
  // 巡检服务
  container.registerSingleton('InspectionRepository',
    (http: HttpClient) => new InspectionRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('InspectionDomain',
    (repo: InspectionRepository, eventBus: EventBus) => {
      return new InspectionDomain(repo, eventBus);
    },
    ['InspectionRepository', 'EventBus']
  );
  
  // 维保服务
  container.registerSingleton('MaintenanceRepository',
    (http: HttpClient) => new MaintenanceRepository(http),
    ['HttpClient']
  );
  
  container.registerSingleton('MaintenanceDomain',
    (repo: MaintenanceRepository, eventBus: EventBus) => {
      return new MaintenanceDomain(repo, eventBus);
    },
    ['MaintenanceRepository', 'EventBus']
  );
}
```

### Day 4：服务改造与适配（8小时）

#### 1. 改造现有服务使用DI
```typescript
// src/services/TicketEscalationService.ts (改造前)
class TicketEscalationService {
  constructor() {
    this.checkInterval = 60 * 60 * 1000;
    this.timer = null;
  }
  
  async checkAndEscalate() {
    // 直接调用API
    const tickets = await listTicket({ status: 'pending,processing' });
    // ...
  }
}

// src/services/TicketEscalationService.ts (改造后)
import { Injectable, Inject } from '@/core/Container';

@Injectable({ singleton: true })
export class TicketEscalationService {
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.checkInterval = this.config.get('business.ticket.escalation.checkInterval');
    this.timer = null;
  }
  
  async checkAndEscalate() {
    try {
      this.logger.info('Starting ticket escalation check');
      
      const tickets = await this.repository.findOverdue();
      
      for (const ticket of tickets) {
        const shouldEscalate = this.evaluateEscalation(ticket);
        
        if (shouldEscalate) {
          await this.escalate(ticket);
          
          // 发布事件而不是直接调用
          this.eventBus.emit('ticket.escalated', {
            ticketId: ticket.id,
            oldPriority: ticket.priority,
            newPriority: this.getNextPriority(ticket.priority)
          });
        }
      }
      
      this.logger.info(`Escalation check completed. Processed ${tickets.length} tickets`);
    } catch (error) {
      this.logger.error('Escalation check failed', error);
      this.eventBus.emit('service.error', {
        service: 'TicketEscalation',
        error
      });
    }
  }
  
  private evaluateEscalation(ticket: Ticket): boolean {
    const rules = this.config.get('business.ticket.escalation.rules');
    const rule = rules[ticket.priority];
    
    if (!rule) return false;
    
    const hoursOverdue = this.calculateOverdueHours(ticket);
    return hoursOverdue > rule.afterHours;
  }
  
  private async escalate(ticket: Ticket): Promise<void> {
    const newPriority = this.getNextPriority(ticket.priority);
    
    await this.repository.updatePriority(ticket.id, newPriority);
    
    // 记录审计日志
    this.logger.audit('Ticket escalated', {
      ticketId: ticket.id,
      oldPriority: ticket.priority,
      newPriority,
      automatic: true
    });
  }
}
```

#### 2. 创建服务适配器（向后兼容）
```typescript
// src/adapters/ServiceAdapter.ts
import { container } from '@/core/Container';
import { FeatureFlags } from '@/config/FeatureFlags';

export class ServiceAdapter {
  static getTicketService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('TicketDomain');
    }
    
    // 返回旧的服务实例
    return window.legacyTicketService;
  }
  
  static getInspectionService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('InspectionDomain');
    }
    
    return window.legacyInspectionService;
  }
  
  static getMaintenanceService() {
    if (FeatureFlags.isEnabled('USE_DI_CONTAINER')) {
      return container.resolve('MaintenanceDomain');
    }
    
    return window.legacyMaintenanceService;
  }
}

// 在组件中使用
export default {
  setup() {
    const ticketService = ServiceAdapter.getTicketService();
    
    const createTicket = async (data) => {
      // 新旧服务接口保持一致
      return await ticketService.create(data);
    };
    
    return { createTicket };
  }
};
```

### Day 5：集成测试与文档（8小时）

#### 1. 集成测试套件
```javascript
// src/__tests__/integration/phase1.test.js
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ConfigService } from '@/config/ConfigService';
import { Container } from '@/core/Container';
import { FeatureFlags } from '@/config/FeatureFlags';

describe('Phase 1: 基础设施集成测试', () => {
  let config;
  let container;
  
  beforeEach(() => {
    config = new ConfigService();
    container = new Container();
    
    // 启用新特性
    FeatureFlags.setFlag('USE_CONFIG_SERVICE', true);
    FeatureFlags.setFlag('USE_DI_CONTAINER', true);
  });
  
  afterEach(() => {
    config.reset();
    container.clear();
    FeatureFlags.reset();
  });
  
  describe('配置服务集成', () => {
    it('应该能从配置服务读取API配置', () => {
      const baseUrl = config.get('api.baseUrl');
      expect(baseUrl).toBeDefined();
      expect(baseUrl).toMatch(/^https?:\/\//);
    });
    
    it('应该能动态更新配置并影响服务行为', async () => {
      // 更改配置
      config.set('api.timeout', 5000);
      
      // 创建使用配置的服务
      const httpClient = container.resolve('HttpClient');
      
      // 验证配置生效
      expect(httpClient.config.timeout).toBe(5000);
    });
    
    it('配置变化应该触发监听器', (done) => {
      config.watch('business.ticket.sla.high', (newValue, oldValue) => {
        expect(oldValue).toBe(12);
        expect(newValue).toBe(6);
        done();
      });
      
      config.set('business.ticket.sla.high', 6);
    });
  });
  
  describe('依赖注入集成', () => {
    it('应该能解析完整的服务依赖链', () => {
      registerCoreServices();
      registerBusinessServices();
      
      const ticketDomain = container.resolve('TicketDomain');
      
      expect(ticketDomain).toBeDefined();
      expect(ticketDomain.repository).toBeDefined();
      expect(ticketDomain.eventBus).toBeDefined();
      expect(ticketDomain.logger).toBeDefined();
    });
    
    it('单例服务应该返回相同实例', () => {
      container.registerSingleton('TestService', () => ({ id: Math.random() }));
      
      const instance1 = container.resolve('TestService');
      const instance2 = container.resolve('TestService');
      
      expect(instance1).toBe(instance2);
    });
    
    it('瞬态服务应该返回不同实例', () => {
      container.registerTransient('TestService', () => ({ id: Math.random() }));
      
      const instance1 = container.resolve('TestService');
      const instance2 = container.resolve('TestService');
      
      expect(instance1).not.toBe(instance2);
    });
    
    it('应该检测循环依赖', () => {
      container.register({
        token: 'ServiceA',
        factory: (b) => ({ b }),
        dependencies: ['ServiceB']
      });
      
      container.register({
        token: 'ServiceB',
        factory: (a) => ({ a }),
        dependencies: ['ServiceA']
      });
      
      expect(() => container.resolve('ServiceA')).toThrow('Circular dependency');
    });
  });
  
  describe('新旧系统兼容性', () => {
    it('关闭特性开关应该使用旧系统', () => {
      FeatureFlags.setFlag('USE_DI_CONTAINER', false);
      
      const service = ServiceAdapter.getTicketService();
      expect(service).toBe(window.legacyTicketService);
    });
    
    it('开启特性开关应该使用新系统', () => {
      FeatureFlags.setFlag('USE_DI_CONTAINER', true);
      
      const service = ServiceAdapter.getTicketService();
      expect(service).toBe(container.resolve('TicketDomain'));
    });
  });
});
```

#### 2. 性能测试
```javascript
// src/__tests__/performance/phase1-perf.test.js
describe('Phase 1: 性能测试', () => {
  it('配置读取性能应该优于直接访问', () => {
    const iterations = 10000;
    
    // 测试直接访问
    const directStart = performance.now();
    for (let i = 0; i < iterations; i++) {
      const value = import.meta.env.VITE_APP_BASE_API;
    }
    const directTime = performance.now() - directStart;
    
    // 测试配置服务
    const configStart = performance.now();
    for (let i = 0; i < iterations; i++) {
      const value = config.get('api.baseUrl');
    }
    const configTime = performance.now() - configStart;
    
    console.log(`直接访问: ${directTime}ms, 配置服务: ${configTime}ms`);
    
    // 配置服务应该在可接受范围内（不超过2倍）
    expect(configTime).toBeLessThan(directTime * 2);
  });
  
  it('DI容器解析性能测试', () => {
    const iterations = 1000;
    
    // 注册复杂依赖链
    for (let i = 0; i < 10; i++) {
      container.registerTransient(`Service${i}`, () => ({
        id: i,
        timestamp: Date.now()
      }));
    }
    
    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
      container.resolve('Service5');
    }
    const elapsed = performance.now() - start;
    
    console.log(`解析 ${iterations} 次耗时: ${elapsed}ms`);
    
    // 平均每次解析应该小于1ms
    expect(elapsed / iterations).toBeLessThan(1);
  });
});
```

## 📊 Phase 1 完成标准检查清单

### 技术指标
- [ ] 配置服务测试覆盖率 > 90%
- [ ] DI容器测试覆盖率 > 85%
- [ ] 所有硬编码配置已迁移
- [ ] 性能测试通过
- [ ] 无循环依赖

### 功能验证
- [ ] 配置可以动态更新
- [ ] 配置变更能触发监听
- [ ] DI容器能正确解析依赖
- [ ] 新旧系统能平滑切换
- [ ] 特性开关工作正常

### 文档交付
- [ ] 配置项清单文档
- [ ] DI容器使用指南
- [ ] 迁移指南
- [ ] API文档
- [ ] 故障排查指南

## 🚀 Phase 1 交付物

1. **代码交付**
   - ConfigService完整实现
   - Container完整实现
   - 所有服务适配器
   - 测试套件

2. **配置文件**
   - config.default.json
   - config.development.json
   - config.production.json

3. **文档交付**
   - CONFIGURATION.md
   - DEPENDENCY-INJECTION.md
   - MIGRATION-GUIDE.md

4. **工具脚本**
   - migrate-config.js
   - scan-hardcoded.js
   - verify-migration.js

这就是Phase 1的完整实施方案。需要我继续提供Phase 2（Store层重构）的详细方案吗？