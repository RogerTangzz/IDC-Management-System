## Phase 6: è¾¹ç•Œä¸Šä¸‹æ–‡æ•´åˆï¼ˆ4å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1-2**: Milestone 6.1 æ¨¡å—é—´é€šä¿¡é‡æ„
- **Day 3**: Milestone 6.2 åˆ›å»ºé˜²è…å±‚
- **Day 4**: Milestone 6.3 æ•°æ®åŒæ­¥æœºåˆ¶

---

## Milestone 6.1: æ¨¡å—é—´é€šä¿¡é‡æ„ï¼ˆ2å¤©ï¼‰

### Day 1: äº‹ä»¶é©±åŠ¨æ¶æ„å®Œå–„ï¼ˆ8å°æ—¶ï¼‰

#### 1. é¢†åŸŸäº‹ä»¶æ€»çº¿å¢å¼º
```typescript
// src/core/events/DomainEventBus.ts
export interface DomainEvent {
  aggregateId: string
  eventType: string
  eventVersion: number
  occurredAt: Date
  metadata?: EventMetadata
  payload: any
}

export interface EventMetadata {
  userId?: string
  correlationId?: string
  causationId?: string
  traceId?: string
}

@Injectable()
export class DomainEventBus {
  private handlers = new Map<string, EventHandler[]>()
  private middleware: EventMiddleware[] = []
  private eventStore: EventStore
  private deadLetterQueue: DeadLetterQueue
  
  constructor(
    @Inject('EventStore') eventStore: EventStore,
    @Inject('DeadLetterQueue') deadLetterQueue: DeadLetterQueue,
    @Inject('Logger') private logger: Logger
  ) {
    this.eventStore = eventStore
    this.deadLetterQueue = deadLetterQueue
  }
  
  // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: EventHandler<T>,
    options?: SubscriptionOptions
  ): Unsubscribe {
    const wrappedHandler = this.wrapHandler(handler, options)
    
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, [])
    }
    
    this.handlers.get(eventType)!.push(wrappedHandler)
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      const handlers = this.handlers.get(eventType)
      if (handlers) {
        const index = handlers.indexOf(wrappedHandler)
        if (index > -1) {
          handlers.splice(index, 1)
        }
      }
    }
  }
  
  // å‘å¸ƒäº‹ä»¶
  async publish<T extends DomainEvent>(event: T): Promise<void> {
    // åº”ç”¨ä¸­é—´ä»¶
    const processedEvent = await this.applyMiddleware(event)
    
    // æŒä¹…åŒ–äº‹ä»¶
    await this.eventStore.append(processedEvent)
    
    // è·å–å¤„ç†å™¨
    const handlers = this.handlers.get(event.eventType) || []
    const wildcardHandlers = this.handlers.get('*') || []
    const allHandlers = [...handlers, ...wildcardHandlers]
    
    // å¹¶è¡Œå¤„ç†
    const results = await Promise.allSettled(
      allHandlers.map(handler => this.invokeHandler(handler, processedEvent))
    )
    
    // å¤„ç†å¤±è´¥çš„å¤„ç†å™¨
    results.forEach((result, index) => {
      if (result.status === 'rejected') {
        this.handleFailure(processedEvent, allHandlers[index], result.reason)
      }
    })
    
    // è®°å½•äº‹ä»¶
    this.logger.info('Domain event published', {
      eventType: event.eventType,
      aggregateId: event.aggregateId,
      handlers: allHandlers.length
    })
  }
  
  // æ‰¹é‡å‘å¸ƒäº‹ä»¶
  async publishBatch(events: DomainEvent[]): Promise<void> {
    // ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
    await this.eventStore.transaction(async (trx) => {
      for (const event of events) {
        await this.publish(event)
      }
    })
  }
  
  // æ·»åŠ ä¸­é—´ä»¶
  use(middleware: EventMiddleware): void {
    this.middleware.push(middleware)
  }
  
  private wrapHandler(
    handler: EventHandler,
    options?: SubscriptionOptions
  ): EventHandler {
    return async (event: DomainEvent) => {
      // é‡è¯•é€»è¾‘
      let attempts = 0
      const maxAttempts = options?.maxRetries || 3
      const retryDelay = options?.retryDelay || 1000
      
      while (attempts < maxAttempts) {
        try {
          await handler(event)
          return
        } catch (error) {
          attempts++
          
          if (attempts >= maxAttempts) {
            throw error
          }
          
          // æŒ‡æ•°é€€é¿
          await new Promise(resolve => 
            setTimeout(resolve, retryDelay * Math.pow(2, attempts - 1))
          )
        }
      }
    }
  }
  
  private async applyMiddleware(event: DomainEvent): Promise<DomainEvent> {
    let processedEvent = event
    
    for (const middleware of this.middleware) {
      processedEvent = await middleware(processedEvent)
    }
    
    return processedEvent
  }
  
  private async invokeHandler(
    handler: EventHandler,
    event: DomainEvent
  ): Promise<void> {
    const startTime = Date.now()
    
    try {
      await handler(event)
      
      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      this.logger.debug('Event handler executed', {
        eventType: event.eventType,
        duration: Date.now() - startTime
      })
    } catch (error) {
      // è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­å…¶ä»–å¤„ç†å™¨
      this.logger.error('Event handler failed', {
        eventType: event.eventType,
        error
      })
      
      throw error
    }
  }
  
  private async handleFailure(
    event: DomainEvent,
    handler: EventHandler,
    error: Error
  ): Promise<void> {
    // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
    await this.deadLetterQueue.add({
      event,
      handler: handler.name,
      error: error.message,
      timestamp: new Date()
    })
    
    // å‘å¸ƒå¤„ç†å¤±è´¥äº‹ä»¶
    await this.publish({
      aggregateId: event.aggregateId,
      eventType: 'EventHandlingFailed',
      eventVersion: 1,
      occurredAt: new Date(),
      payload: {
        originalEvent: event,
        error: error.message
      }
    })
  }
}
```

#### 2. è·¨æ¨¡å—äº‹ä»¶æ˜ å°„
```typescript
// src/core/events/EventMapper.ts
@Injectable()
export class EventMapper {
  private mappings = new Map<string, EventMapping[]>()
  
  constructor(
    @Inject('Logger') private logger: Logger
  ) {
    this.registerMappings()
  }
  
  private registerMappings(): void {
    // å·¡æ£€ -> å·¥å•
    this.addMapping({
      source: 'inspection.anomaly.detected',
      target: 'ticket.create.requested',
      transform: (event) => ({
        title: `[å·¡æ£€å¼‚å¸¸] ${event.payload.floor} - ${event.payload.itemName}`,
        description: event.payload.description,
        priority: this.mapSeverityToPriority(event.payload.severity),
        sourceType: 'inspection',
        sourceId: event.aggregateId,
        metadata: {
          anomalyId: event.payload.anomalyId,
          inspectorId: event.payload.inspectorId
        }
      })
    })
    
    // ç»´ä¿ -> å·¥å•
    this.addMapping({
      source: 'maintenance.plan.overdue',
      target: 'ticket.create.requested',
      transform: (event) => ({
        title: `[ç»´ä¿é€¾æœŸ] ${event.payload.planTitle}`,
        description: `ç»´ä¿è®¡åˆ’å·²é€¾æœŸ ${event.payload.overdueDays} å¤©`,
        priority: 'high',
        sourceType: 'maintenance',
        sourceId: event.aggregateId
      })
    })
    
    // å·¥å• -> å·¡æ£€
    this.addMapping({
      source: 'ticket.completed',
      target: 'inspection.ticket.resolved',
      condition: (event) => event.payload.sourceType === 'inspection',
      transform: (event) => ({
        inspectionId: event.payload.sourceId,
        ticketId: event.aggregateId,
        resolution: event.payload.resolution
      })
    })
    
    // å·¥å• -> ç»´ä¿
    this.addMapping({
      source: 'ticket.completed',
      target: 'maintenance.ticket.resolved',
      condition: (event) => event.payload.sourceType === 'maintenance',
      transform: (event) => ({
        maintenanceId: event.payload.sourceId,
        ticketId: event.aggregateId,
        resolution: event.payload.resolution
      })
    })
  }
  
  private addMapping(mapping: EventMapping): void {
    if (!this.mappings.has(mapping.source)) {
      this.mappings.set(mapping.source, [])
    }
    
    this.mappings.get(mapping.source)!.push(mapping)
  }
  
  async mapEvent(event: DomainEvent): Promise<DomainEvent[]> {
    const mappings = this.mappings.get(event.eventType) || []
    const mappedEvents: DomainEvent[] = []
    
    for (const mapping of mappings) {
      // æ£€æŸ¥æ¡ä»¶
      if (mapping.condition && !mapping.condition(event)) {
        continue
      }
      
      try {
        // è½¬æ¢äº‹ä»¶
        const payload = mapping.transform(event)
        
        const mappedEvent: DomainEvent = {
          aggregateId: generateId(),
          eventType: mapping.target,
          eventVersion: 1,
          occurredAt: new Date(),
          metadata: {
            ...event.metadata,
            causationId: event.aggregateId,
            mappedFrom: event.eventType
          },
          payload
        }
        
        mappedEvents.push(mappedEvent)
        
        this.logger.debug('Event mapped', {
          source: event.eventType,
          target: mapping.target
        })
      } catch (error) {
        this.logger.error('Event mapping failed', {
          source: event.eventType,
          target: mapping.target,
          error
        })
      }
    }
    
    return mappedEvents
  }
  
  private mapSeverityToPriority(severity: string): string {
    const map: Record<string, string> = {
      'critical': 'urgent',
      'high': 'high',
      'medium': 'medium',
      'low': 'low'
    }
    
    return map[severity] || 'medium'
  }
}

interface EventMapping {
  source: string
  target: string
  condition?: (event: DomainEvent) => boolean
  transform: (event: DomainEvent) => any
}
```

### Day 2: èšåˆåè°ƒå™¨å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. Sagaç¼–æ’å™¨
```typescript
// src/core/saga/SagaOrchestrator.ts
export abstract class Saga {
  protected sagaId: string
  protected status: SagaStatus
  protected steps: SagaStep[]
  protected currentStep: number
  protected compensations: CompensationStep[]
  protected context: any
  
  constructor() {
    this.sagaId = generateId()
    this.status = SagaStatus.PENDING
    this.steps = []
    this.currentStep = 0
    this.compensations = []
    this.context = {}
  }
  
  abstract defineSteps(): void
  
  protected addStep(step: SagaStep): void {
    this.steps.push(step)
  }
  
  protected addCompensation(compensation: CompensationStep): void {
    this.compensations.push(compensation)
  }
}

@Injectable()
export class SagaOrchestrator {
  private activeSagas = new Map<string, Saga>()
  
  constructor(
    @Inject('EventBus') private eventBus: DomainEventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('SagaRepository') private repository: SagaRepository
  ) {}
  
  async startSaga(saga: Saga, initialContext?: any): Promise<void> {
    saga.context = { ...saga.context, ...initialContext }
    saga.defineSteps()
    saga.status = SagaStatus.RUNNING
    
    this.activeSagas.set(saga.sagaId, saga)
    await this.repository.save(saga)
    
    this.logger.info('Saga started', {
      sagaId: saga.sagaId,
      type: saga.constructor.name
    })
    
    // å¼€å§‹æ‰§è¡Œ
    await this.executeNextStep(saga)
  }
  
  private async executeNextStep(saga: Saga): Promise<void> {
    if (saga.currentStep >= saga.steps.length) {
      // Sagaå®Œæˆ
      await this.completeSaga(saga)
      return
    }
    
    const step = saga.steps[saga.currentStep]
    
    try {
      this.logger.debug('Executing saga step', {
        sagaId: saga.sagaId,
        step: step.name
      })
      
      // æ‰§è¡Œæ­¥éª¤
      const result = await step.execute(saga.context)
      
      // æ›´æ–°ä¸Šä¸‹æ–‡
      saga.context = { ...saga.context, ...result }
      
      // è®°å½•è¡¥å¿ä¿¡æ¯
      if (step.compensate) {
        saga.compensations.unshift({
          step: step.name,
          compensate: step.compensate,
          context: { ...saga.context }
        })
      }
      
      // ç§»åˆ°ä¸‹ä¸€æ­¥
      saga.currentStep++
      await this.repository.update(saga)
      
      // ç»§ç»­æ‰§è¡Œ
      await this.executeNextStep(saga)
    } catch (error) {
      this.logger.error('Saga step failed', {
        sagaId: saga.sagaId,
        step: step.name,
        error
      })
      
      // å¼€å§‹è¡¥å¿
      await this.compensateSaga(saga, error)
    }
  }
  
  private async compensateSaga(saga: Saga, error: Error): Promise<void> {
    saga.status = SagaStatus.COMPENSATING
    
    this.logger.info('Starting saga compensation', {
      sagaId: saga.sagaId,
      error: error.message
    })
    
    for (const compensation of saga.compensations) {
      try {
        await compensation.compensate(compensation.context)
        
        this.logger.debug('Compensation executed', {
          sagaId: saga.sagaId,
          step: compensation.step
        })
      } catch (compensationError) {
        this.logger.error('Compensation failed', {
          sagaId: saga.sagaId,
          step: compensation.step,
          error: compensationError
        })
        
        // è¡¥å¿å¤±è´¥ï¼Œéœ€è¦äººå·¥ä»‹å…¥
        saga.status = SagaStatus.FAILED
        await this.repository.update(saga)
        
        // å‘é€å‘Šè­¦
        await this.eventBus.publish({
          aggregateId: saga.sagaId,
          eventType: 'saga.compensation.failed',
          eventVersion: 1,
          occurredAt: new Date(),
          payload: {
            sagaId: saga.sagaId,
            step: compensation.step,
            error: compensationError.message
          }
        })
        
        return
      }
    }
    
    saga.status = SagaStatus.COMPENSATED
    await this.repository.update(saga)
    
    this.logger.info('Saga compensated successfully', {
      sagaId: saga.sagaId
    })
  }
  
  private async completeSaga(saga: Saga): Promise<void> {
    saga.status = SagaStatus.COMPLETED
    
    await this.repository.update(saga)
    this.activeSagas.delete(saga.sagaId)
    
    this.logger.info('Saga completed', {
      sagaId: saga.sagaId
    })
    
    // å‘å¸ƒå®Œæˆäº‹ä»¶
    await this.eventBus.publish({
      aggregateId: saga.sagaId,
      eventType: 'saga.completed',
      eventVersion: 1,
      occurredAt: new Date(),
      payload: {
        sagaId: saga.sagaId,
        result: saga.context
      }
    })
  }
}
```

#### 2. è·¨æ¨¡å—ä¸šåŠ¡æµç¨‹Saga
```typescript
// src/sagas/InspectionToTicketSaga.ts
export class InspectionToTicketSaga extends Saga {
  defineSteps(): void {
    // æ­¥éª¤1: éªŒè¯å·¡æ£€å¼‚å¸¸
    this.addStep({
      name: 'validateAnomaly',
      execute: async (context) => {
        const inspectionService = container.get('InspectionDomain')
        const inspection = await inspectionService.getInspection(context.inspectionId)
        
        if (!inspection) {
          throw new Error('Inspection not found')
        }
        
        const anomaly = inspection.getAnomaly(context.anomalyId)
        if (!anomaly) {
          throw new Error('Anomaly not found')
        }
        
        return { inspection, anomaly }
      }
    })
    
    // æ­¥éª¤2: æ£€æŸ¥é‡å¤å·¥å•
    this.addStep({
      name: 'checkDuplicateTicket',
      execute: async (context) => {
        const ticketService = container.get('TicketDomain')
        const existingTicket = await ticketService.findBySourceId(
          'inspection',
          context.anomaly.id
        )
        
        if (existingTicket) {
          throw new Error(`Duplicate ticket exists: ${existingTicket.id}`)
        }
        
        return { duplicateCheck: 'passed' }
      }
    })
    
    // æ­¥éª¤3: åˆ›å»ºå·¥å•
    this.addStep({
      name: 'createTicket',
      execute: async (context) => {
        const ticketService = container.get('TicketDomain')
        
        const ticket = await ticketService.createTicket({
          title: `[å·¡æ£€å¼‚å¸¸] ${context.inspection.floor} - ${context.anomaly.itemName}`,
          description: context.anomaly.description,
          priority: context.anomaly.severity === 'critical' ? 'urgent' : 'high',
          sourceType: 'inspection',
          sourceId: context.anomaly.id,
          reporterId: context.inspection.inspectorId
        })
        
        return { ticketId: ticket.id }
      },
      compensate: async (context) => {
        // è¡¥å¿ï¼šåˆ é™¤åˆ›å»ºçš„å·¥å•
        if (context.ticketId) {
          const ticketService = container.get('TicketDomain')
          await ticketService.deleteTicket(context.ticketId)
        }
      }
    })
    
    // æ­¥éª¤4: æ›´æ–°å·¡æ£€è®°å½•
    this.addStep({
      name: 'updateInspection',
      execute: async (context) => {
        const inspectionService = container.get('InspectionDomain')
        
        await inspectionService.markAnomalyHandled(
          context.inspectionId,
          context.anomalyId,
          context.ticketId
        )
        
        return { updated: true }
      },
      compensate: async (context) => {
        // è¡¥å¿ï¼šæ’¤é”€å¼‚å¸¸å¤„ç†æ ‡è®°
        const inspectionService = container.get('InspectionDomain')
        await inspectionService.unmarkAnomalyHandled(
          context.inspectionId,
          context.anomalyId
        )
      }
    })
    
    // æ­¥éª¤5: å‘é€é€šçŸ¥
    this.addStep({
      name: 'sendNotification',
      execute: async (context) => {
        const notificationService = container.get('NotificationService')
        
        await notificationService.send({
          recipientId: context.inspection.inspectorId,
          type: 'anomaly_ticket_created',
          title: 'å¼‚å¸¸å·¥å•å·²åˆ›å»º',
          message: `æ‚¨æŠ¥å‘Šçš„å¼‚å¸¸å·²ç”Ÿæˆå·¥å• #${context.ticketId}`,
          data: {
            ticketId: context.ticketId,
            anomalyId: context.anomalyId
          }
        })
        
        return { notified: true }
      }
      // é€šçŸ¥å¤±è´¥ä¸éœ€è¦è¡¥å¿ï¼Œä¸å½±å“ä¸»æµç¨‹
    })
  }
}
```

---

## Milestone 6.2: åˆ›å»ºé˜²è…å±‚ï¼ˆ1å¤©ï¼‰

### Day 3: é˜²è…å±‚å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. å¤–éƒ¨ç³»ç»Ÿé€‚é…å™¨
```typescript
// src/infrastructure/adapters/ExternalSystemAdapter.ts
export interface ExternalSystemAdapter {
  name: string
  connect(): Promise<void>
  disconnect(): Promise<void>
  healthCheck(): Promise<boolean>
}

// å·¥å•ç³»ç»Ÿé€‚é…å™¨
@Injectable()
export class LegacyTicketSystemAdapter implements ExternalSystemAdapter {
  name = 'LegacyTicketSystem'
  private client: any
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('Logger') private logger: Logger
  ) {}
  
  async connect(): Promise<void> {
    const config = this.config.get('external.legacyTicket')
    this.client = new LegacyClient(config)
    await this.client.connect()
  }
  
  async disconnect(): Promise<void> {
    await this.client?.disconnect()
  }
  
  async healthCheck(): Promise<boolean> {
    try {
      await this.client.ping()
      return true
    } catch {
      return false
    }
  }
  
  // è½¬æ¢æ–¹æ³•ï¼šé¢†åŸŸæ¨¡å‹ -> å¤–éƒ¨ç³»ç»Ÿæ ¼å¼
  async createTicket(domainTicket: Ticket): Promise<string> {
    const legacyTicket = this.transformToLegacy(domainTicket)
    
    try {
      const result = await this.client.createTicket(legacyTicket)
      return result.ticketId
    } catch (error) {
      this.logger.error('Failed to create ticket in legacy system', {
        error,
        ticket: domainTicket.id
      })
      throw new ExternalSystemError('Legacy system unavailable')
    }
  }
  
  // è½¬æ¢æ–¹æ³•ï¼šå¤–éƒ¨ç³»ç»Ÿæ ¼å¼ -> é¢†åŸŸæ¨¡å‹
  async getTicket(legacyId: string): Promise<Ticket | null> {
    try {
      const legacyTicket = await this.client.getTicket(legacyId)
      return this.transformToDomain(legacyTicket)
    } catch (error) {
      this.logger.error('Failed to get ticket from legacy system', {
        error,
        legacyId
      })
      return null
    }
  }
  
  private transformToLegacy(ticket: Ticket): any {
    // æ˜ å°„åˆ°æ—§ç³»ç»Ÿæ ¼å¼
    return {
      ticket_no: ticket.ticketNo,
      title: ticket.title,
      content: ticket.description,
      level: this.mapPriority(ticket.priority),
      status: this.mapStatus(ticket.status),
      create_time: ticket.createdAt.toISOString(),
      create_user: ticket.reporterId
    }
  }
  
  private transformToDomain(legacyTicket: any): Ticket {
    // ä»æ—§ç³»ç»Ÿæ ¼å¼æ˜ å°„å›æ¥
    return new Ticket({
      ticketNo: legacyTicket.ticket_no,
      title: legacyTicket.title,
      description: legacyTicket.content,
      priority: this.unmapPriority(legacyTicket.level),
      status: this.unmapStatus(legacyTicket.status),
      reporterId: legacyTicket.create_user,
      createdAt: new Date(legacyTicket.create_time)
    })
  }
  
  private mapPriority(priority: TicketPriority): number {
    const map: Record<TicketPriority, number> = {
      [TicketPriority.LOW]: 1,
      [TicketPriority.MEDIUM]: 2,
      [TicketPriority.HIGH]: 3,
      [TicketPriority.URGENT]: 4
    }
    return map[priority]
  }
  
  private unmapPriority(level: number): TicketPriority {
    const map: Record<number, TicketPriority> = {
      1: TicketPriority.LOW,
      2: TicketPriority.MEDIUM,
      3: TicketPriority.HIGH,
      4: TicketPriority.URGENT
    }
    return map[level] || TicketPriority.MEDIUM
  }
  
  private mapStatus(status: TicketStatus): string {
    const map: Record<TicketStatus, string> = {
      [TicketStatus.PENDING]: '1',
      [TicketStatus.ASSIGNED]: '2',
      [TicketStatus.PROCESSING]: '3',
      [TicketStatus.COMPLETED]: '4',
      [TicketStatus.CLOSED]: '5'
    }
    return map[status]
  }
  
  private unmapStatus(status: string): TicketStatus {
    const map: Record<string, TicketStatus> = {
      '1': TicketStatus.PENDING,
      '2': TicketStatus.ASSIGNED,
      '3': TicketStatus.PROCESSING,
      '4': TicketStatus.COMPLETED,
      '5': TicketStatus.CLOSED
    }
    return map[status] || TicketStatus.PENDING
  }
}
```

#### 2. é˜²è…å±‚æœåŠ¡
```typescript
// src/infrastructure/anticorruption/AntiCorruptionLayer.ts
@Injectable()
export class AntiCorruptionLayer {
  private adapters = new Map<string, ExternalSystemAdapter>()
  private cache = new Map<string, CacheEntry>()
  
  constructor(
    @Inject('EventBus') private eventBus: DomainEventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.registerAdapters()
  }
  
  private registerAdapters(): void {
    // æ³¨å†Œæ‰€æœ‰å¤–éƒ¨ç³»ç»Ÿé€‚é…å™¨
    this.registerAdapter(new LegacyTicketSystemAdapter())
    this.registerAdapter(new NotificationSystemAdapter())
    this.registerAdapter(new BIMSystemAdapter())
  }
  
  private registerAdapter(adapter: ExternalSystemAdapter): void {
    this.adapters.set(adapter.name, adapter)
    adapter.connect().catch(error => {
      this.logger.error(`Failed to connect to ${adapter.name}`, error)
    })
  }
  
  // ç»Ÿä¸€çš„å¤–éƒ¨è°ƒç”¨æ¥å£
  async callExternalSystem<T>(
    systemName: string,
    operation: string,
    params: any,
    options?: CallOptions
  ): Promise<T> {
    const adapter = this.adapters.get(systemName)
    if (!adapter) {
      throw new Error(`External system ${systemName} not registered`)
    }
    
    // æ£€æŸ¥ç¼“å­˜
    const cacheKey = this.getCacheKey(systemName, operation, params)
    if (options?.useCache) {
      const cached = this.getFromCache(cacheKey)
      if (cached) {
        return cached as T
      }
    }
    
    // æ£€æŸ¥å¥åº·çŠ¶æ€
    const isHealthy = await adapter.healthCheck()
    if (!isHealthy && options?.fallback) {
      return options.fallback()
    }
    
    try {
      // æ‰§è¡Œè°ƒç”¨
      const result = await this.executeCall(adapter, operation, params)
      
      // ç¼“å­˜ç»“æœ
      if (options?.useCache) {
        this.setCache(cacheKey, result, options.cacheTTL)
      }
      
      // å‘å¸ƒæˆåŠŸäº‹ä»¶
      this.eventBus.publish({
        aggregateId: generateId(),
        eventType: 'external.call.success',
        eventVersion: 1,
        occurredAt: new Date(),
        payload: {
          system: systemName,
          operation,
          duration: Date.now()
        }
      })
      
      return result as T
    } catch (error) {
      // å‘å¸ƒå¤±è´¥äº‹ä»¶
      this.eventBus.publish({
        aggregateId: generateId(),
        eventType: 'external.call.failed',
        eventVersion: 1,
        occurredAt: new Date(),
        payload: {
          system: systemName,
          operation,
          error: error.message
        }
      })
      
      throw error
    }
  }
  
  private async executeCall(
    adapter: any,
    operation: string,
    params: any
  ): Promise<any> {
    const method = adapter[operation]
    if (!method) {
      throw new Error(`Operation ${operation} not found`)
    }
    
    return await method.call(adapter, ...params)
  }
  
  private getCacheKey(system: string, operation: string, params: any): string {
    return `${system}:${operation}:${JSON.stringify(params)}`
  }
  
  private getFromCache(key: string): any | null {
    const entry = this.cache.get(key)
    if (!entry) return null
    
    if (entry.expiresAt < Date.now()) {
      this.cache.delete(key)
      return null
    }
    
    return entry.value
  }
  
  private setCache(key: string, value: any, ttl: number = 60000): void {
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttl
    })
  }
}

interface CallOptions {
  useCache?: boolean
  cacheTTL?: number
  fallback?: () => any
  timeout?: number
  retries?: number
}

interface CacheEntry {
  value: any
  expiresAt: number
}
```

---

## Milestone 6.3: æ•°æ®åŒæ­¥æœºåˆ¶ï¼ˆ1å¤©ï¼‰

### Day 4: æœ€ç»ˆä¸€è‡´æ€§å®ç°ï¼ˆ8å°æ—¶ï¼‰

#### 1. æ•°æ®åŒæ­¥æœåŠ¡
```typescript
// src/infrastructure/sync/DataSyncService.ts
@Injectable()
export class DataSyncService {
  private syncJobs = new Map<string, SyncJob>()
  private syncQueue: Queue
  
  constructor(
    @Inject('EventBus') private eventBus: DomainEventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('SyncRepository') private repository: SyncRepository
  ) {
    this.syncQueue = new Queue('data-sync')
    this.setupSyncJobs()
    this.setupEventHandlers()
  }
  
  private setupSyncJobs(): void {
    // å·¥å•åŒæ­¥ä»»åŠ¡
    this.registerSyncJob({
      id: 'ticket-sync',
      source: 'ticket',
      target: 'legacy-ticket',
      schedule: '*/5 * * * *', // æ¯5åˆ†é’Ÿ
      batchSize: 100,
      syncStrategy: SyncStrategy.INCREMENTAL
    })
    
    // å·¡æ£€åŒæ­¥ä»»åŠ¡
    this.registerSyncJob({
      id: 'inspection-sync',
      source: 'inspection',
      target: 'bim-system',
      schedule: '0 * * * *', // æ¯å°æ—¶
      batchSize: 50,
      syncStrategy: SyncStrategy.FULL
    })
  }
  
  private registerSyncJob(config: SyncJobConfig): void {
    const job = new SyncJob(config)
    this.syncJobs.set(config.id, job)
    
    // è°ƒåº¦ä»»åŠ¡
    cron.schedule(config.schedule, () => {
      this.executeSyncJob(job)
    })
  }
  
  private async executeSyncJob(job: SyncJob): Promise<void> {
    this.logger.info(`Starting sync job: ${job.id}`)
    
    try {
      // è·å–éœ€è¦åŒæ­¥çš„æ•°æ®
      const dataToSync = await this.getDataToSync(job)
      
      if (dataToSync.length === 0) {
        this.logger.info(`No data to sync for job: ${job.id}`)
        return
      }
      
      // æ‰¹é‡å¤„ç†
      const batches = this.createBatches(dataToSync, job.batchSize)
      
      for (const batch of batches) {
        await this.syncQueue.add({
          jobId: job.id,
          data: batch,
          timestamp: new Date()
        })
      }
      
      // æ›´æ–°åŒæ­¥çŠ¶æ€
      job.lastSyncTime = new Date()
      await this.repository.updateSyncJob(job)
      
      this.logger.info(`Sync job completed: ${job.id}`, {
        syncedCount: dataToSync.length
      })
    } catch (error) {
      this.logger.error(`Sync job failed: ${job.id}`, error)
      
      // å‘å¸ƒåŒæ­¥å¤±è´¥äº‹ä»¶
      this.eventBus.publish({
        aggregateId: job.id,
        eventType: 'sync.job.failed',
        eventVersion: 1,
        occurredAt: new Date(),
        payload: {
          jobId: job.id,
          error: error.message
        }
      })
    }
  }
  
  private async getDataToSync(job: SyncJob): Promise<any[]> {
    switch (job.syncStrategy) {
      case SyncStrategy.INCREMENTAL:
        return await this.getIncrementalData(job)
      case SyncStrategy.FULL:
        return await this.getFullData(job)
      case SyncStrategy.DIFFERENTIAL:
        return await this.getDifferentialData(job)
      default:
        return []
    }
  }
  
  private async getIncrementalData(job: SyncJob): Promise<any[]> {
    // è·å–è‡ªä¸Šæ¬¡åŒæ­¥ä»¥æ¥çš„å˜æ›´æ•°æ®
    const lastSync = job.lastSyncTime || new Date(0)
    
    switch (job.source) {
      case 'ticket':
        const ticketRepo = container.get('TicketRepository')
        return await ticketRepo.findModifiedSince(lastSync)
      
      case 'inspection':
        const inspectionRepo = container.get('InspectionRepository')
        return await inspectionRepo.findModifiedSince(lastSync)
      
      default:
        return []
    }
  }
  
  private createBatches<T>(data: T[], batchSize: number): T[][] {
    const batches: T[][] = []
    
    for (let i = 0; i < data.length; i += batchSize) {
      batches.push(data.slice(i, i + batchSize))
    }
    
    return batches
  }
  
  // å¤„ç†å®æ—¶äº‹ä»¶
  private setupEventHandlers(): void {
    // ç›‘å¬éœ€è¦å³æ—¶åŒæ­¥çš„äº‹ä»¶
    this.eventBus.subscribe('ticket.created', async (event) => {
      await this.syncEntity('ticket', event.aggregateId)
    })
    
    this.eventBus.subscribe('ticket.updated', async (event) => {
      await this.syncEntity('ticket', event.aggregateId)
    })
  }
  
  private async syncEntity(entityType: string, entityId: string): Promise<void> {
    // å³æ—¶åŒæ­¥å•ä¸ªå®ä½“
    await this.syncQueue.add({
      entityType,
      entityId,
      priority: 'high',
      timestamp: new Date()
    })
  }
}
```

#### 2. å†²çªè§£å†³ç­–ç•¥
```typescript
// src/infrastructure/sync/ConflictResolver.ts
@Injectable()
export class ConflictResolver {
  constructor(
    @Inject('Logger') private logger: Logger
  ) {}
  
  async resolve<T>(
    local: T,
    remote: T,
    strategy: ConflictResolutionStrategy
  ): Promise<T> {
    switch (strategy) {
      case ConflictResolutionStrategy.LOCAL_WINS:
        return local
        
      case ConflictResolutionStrategy.REMOTE_WINS:
        return remote
        
      case ConflictResolutionStrategy.LATEST_WINS:
        return this.resolveByTimestamp(local, remote)
        
      case ConflictResolutionStrategy.MERGE:
        return this.merge(local, remote)
        
      case ConflictResolutionStrategy.MANUAL:
        await this.requestManualResolution(local, remote)
        throw new ConflictResolutionPending()
        
      default:
        throw new Error(`Unknown conflict resolution strategy: ${strategy}`)
    }
  }
  
  private resolveByTimestamp<T>(local: T, remote: T): T {
    const localTime = (local as any).updatedAt || (local as any).modifiedAt
    const remoteTime = (remote as any).updatedAt || (remote as any).modifiedAt
    
    if (!localTime || !remoteTime) {
      throw new Error('Cannot resolve by timestamp: missing timestamp fields')
    }
    
    return new Date(localTime) > new Date(remoteTime) ? local : remote
  }
  
  private merge<T>(local: T, remote: T): T {
    // ä¸‰è·¯åˆå¹¶ç®—æ³•
    const base = this.findCommonAncestor(local, remote)
    const merged = { ...base as any }
    
    // åº”ç”¨æœ¬åœ°æ›´æ”¹
    for (const key in local) {
      if (local[key] !== base[key]) {
        merged[key] = local[key]
      }
    }
    
    // åº”ç”¨è¿œç¨‹æ›´æ”¹
    for (const key in remote) {
      if (remote[key] !== base[key]) {
        // å¦‚æœæœ¬åœ°ä¹Ÿä¿®æ”¹äº†åŒä¸€å­—æ®µï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
        if (merged[key] !== base[key] && merged[key] !== remote[key]) {
          merged[key] = this.mergeField(key, merged[key], remote[key])
        } else {
          merged[key] = remote[key]
        }
      }
    }
    
    return merged as T
  }
  
  private mergeField(key: string, localValue: any, remoteValue: any): any {
    // æ ¹æ®å­—æ®µç±»å‹å†³å®šåˆå¹¶ç­–ç•¥
    if (Array.isArray(localValue) && Array.isArray(remoteValue)) {
      // æ•°ç»„åˆå¹¶ï¼šå»é‡
      return [...new Set([...localValue, ...remoteValue])]
    }
    
    if (typeof localValue === 'number' && typeof remoteValue === 'number') {
      // æ•°å­—ï¼šå–è¾ƒå¤§å€¼ï¼ˆä¾‹å¦‚ç‰ˆæœ¬å·ï¼‰
      return Math.max(localValue, remoteValue)
    }
    
    // é»˜è®¤ï¼šæœ¬åœ°ä¼˜å…ˆ
    return localValue
  }
  
  private findCommonAncestor<T>(local: T, remote: T): T {
    // ç®€åŒ–å®ç°ï¼šè¿”å›ç©ºå¯¹è±¡
    // å®é™…åº”è¯¥ä»ç‰ˆæœ¬å†å²ä¸­æ‰¾åˆ°å…±åŒç¥–å…ˆ
    return {} as T
  }
  
  private async requestManualResolution<T>(
    local: T,
    remote: T
  ): Promise<void> {
    // åˆ›å»ºå†²çªè®°å½•ï¼Œç­‰å¾…äººå·¥å¤„ç†
    const conflictId = generateId()
    
    await this.repository.createConflict({
      id: conflictId,
      entityType: (local as any).constructor.name,
      entityId: (local as any).id,
      localVersion: local,
      remoteVersion: remote,
      status: 'pending',
      createdAt: new Date()
    })
    
    // å‘é€é€šçŸ¥
    await this.eventBus.publish({
      aggregateId: conflictId,
      eventType: 'sync.conflict.detected',
      eventVersion: 1,
      occurredAt: new Date(),
      payload: {
        conflictId,
        entityType: (local as any).constructor.name,
        entityId: (local as any).id
      }
    })
  }
}

enum ConflictResolutionStrategy {
  LOCAL_WINS = 'local_wins',
  REMOTE_WINS = 'remote_wins',
  LATEST_WINS = 'latest_wins',
  MERGE = 'merge',
  MANUAL = 'manual'
}
```

## ğŸ“Š Phase 6 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] äº‹ä»¶æ€»çº¿æ”¯æŒé‡è¯•å’Œæ­»ä¿¡é˜Ÿåˆ—
- [ ] Sagaç¼–æ’å™¨æ­£å¸¸å·¥ä½œ
- [ ] é˜²è…å±‚éš”ç¦»å¤–éƒ¨ç³»ç»Ÿ
- [ ] æ•°æ®åŒæ­¥æœºåˆ¶ç¨³å®š
- [ ] å†²çªè§£å†³ç­–ç•¥å®Œå–„

### åŠŸèƒ½éªŒè¯
- [ ] è·¨æ¨¡å—é€šä¿¡æ­£å¸¸
- [ ] å¤–éƒ¨ç³»ç»Ÿè°ƒç”¨ç¨³å®š
- [ ] æ•°æ®æœ€ç»ˆä¸€è‡´æ€§ä¿è¯
- [ ] è¡¥å¿æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] ç¼“å­˜ç­–ç•¥ç”Ÿæ•ˆ

### æ€§èƒ½æŒ‡æ ‡
- [ ] äº‹ä»¶å¤„ç†å»¶è¿Ÿ < 100ms
- [ ] Sagaæ‰§è¡Œæ—¶é—´ < 2s
- [ ] æ•°æ®åŒæ­¥å»¶è¿Ÿ < 5åˆ†é’Ÿ
- [ ] ç¼“å­˜å‘½ä¸­ç‡ > 70%

## ğŸš€ Phase 6 äº¤ä»˜ç‰©

1. **äº‹ä»¶æ¶æ„**
   - DomainEventBuså¢å¼ºç‰ˆ
   - EventMapperè·¨æ¨¡å—æ˜ å°„
   - DeadLetterQueueæ­»ä¿¡é˜Ÿåˆ—
   - EventStoreäº‹ä»¶å­˜å‚¨

2. **Sagaç¼–æ’**
   - SagaOrchestratorç¼–æ’å™¨
   - InspectionToTicketSagaç¤ºä¾‹
   - è¡¥å¿æœºåˆ¶å®ç°
   - SagaæŒä¹…åŒ–

3. **é˜²è…å±‚**
   - ExternalSystemAdapteræ¥å£
   - LegacyTicketSystemAdapterå®ç°
   - AntiCorruptionLayeræœåŠ¡
   - ç¼“å­˜å’Œé™çº§ç­–ç•¥

4. **æ•°æ®åŒæ­¥**
   - DataSyncServiceåŒæ­¥æœåŠ¡
   - ConflictResolverå†²çªè§£å†³
   - å¢é‡/å…¨é‡åŒæ­¥ç­–ç•¥
   - åŒæ­¥é˜Ÿåˆ—ç®¡ç†

5. **æ–‡æ¡£**
   - EVENT-DRIVEN-ARCHITECTURE.md
   - SAGA-PATTERN.md
   - ANTI-CORRUPTION-LAYER.md
   - DATA-SYNC-STRATEGY.md

è¿™å°±æ˜¯Phase 6çš„å®Œæ•´å®æ–½æ–¹æ¡ˆï¼Œé‡ç‚¹æ˜¯å»ºç«‹å®Œå–„çš„è·¨æ¨¡å—é€šä¿¡æœºåˆ¶ã€å®ç°é˜²è…å±‚éš”ç¦»å¤–éƒ¨ç³»ç»Ÿã€ç¡®ä¿æ•°æ®æœ€ç»ˆä¸€è‡´æ€§ï¼Œä¸ºæ•´ä¸ªç³»ç»Ÿçš„è¾¹ç•Œæ•´åˆæä¾›åšå®åŸºç¡€ã€‚