## Phase 4: 核心业务模块重构 - 巡检（6天）

### 📅 时间安排
- **Day 1-2**: Milestone 4.1 巡检领域模型
- **Day 3-5**: Milestone 4.2 解耦工单生成
- **Day 6**: Milestone 4.3 巡检配置独立

---

## Milestone 4.1: 巡检领域模型（2天）

### Day 1: 巡检实体和值对象设计（8小时）

#### 1. 巡检实体定义
```typescript
// src/domain/inspection/entities/Inspection.ts
export class Inspection {
  private _id: string
  private _inspectionNo: string
  private _floor: Floor
  private _inspectorId: string
  private _inspectionDate: Date
  private _items: Map<string, InspectionItem>
  private _anomalies: Anomaly[]
  private _status: InspectionStatus
  private _startTime?: Date
  private _endTime?: Date
  private _generatedTickets: string[]
  
  constructor(props: InspectionProps) {
    this.validate(props)
    this._id = props.id || generateId()
    this._inspectionNo = props.inspectionNo || this.generateInspectionNo()
    this._floor = props.floor
    this._inspectorId = props.inspectorId
    this._inspectionDate = props.inspectionDate
    this._items = new Map()
    this._anomalies = []
    this._generatedTickets = []
    this._status = InspectionStatus.PENDING
    
    // 初始化巡检项
    this.initializeItems(props.floor)
  }
  
  // 开始巡检
  start(): void {
    if (this._status !== InspectionStatus.PENDING) {
      throw new DomainError('只能开始待执行的巡检')
    }
    
    this._status = InspectionStatus.IN_PROGRESS
    this._startTime = new Date()
  }
  
  // 记录巡检项
  recordItem(itemCode: string, value: any, remark?: string): void {
    if (this._status !== InspectionStatus.IN_PROGRESS) {
      throw new DomainError('只能在进行中的巡检记录数据')
    }
    
    const item = this._items.get(itemCode)
    if (!item) {
      throw new DomainError(`巡检项 ${itemCode} 不存在`)
    }
    
    item.record(value, remark)
    
    // 检测异常
    const anomaly = this.detectAnomaly(item, value)
    if (anomaly) {
      this._anomalies.push(anomaly)
    }
  }
  
  // 完成巡检
  complete(): void {
    if (this._status !== InspectionStatus.IN_PROGRESS) {
      throw new DomainError('只能完成进行中的巡检')
    }
    
    // 验证所有必检项已完成
    this.validateCompletion()
    
    this._status = InspectionStatus.COMPLETED
    this._endTime = new Date()
  }
  
  // 生成异常工单
  generateTicketsForAnomalies(selectedAnomalyIds?: string[]): TicketRequest[] {
    const anomaliesToProcess = selectedAnomalyIds 
      ? this._anomalies.filter(a => selectedAnomalyIds.includes(a.id))
      : this._anomalies
      
    if (anomaliesToProcess.length === 0) {
      throw new DomainError('没有需要处理的异常')
    }
    
    const ticketRequests: TicketRequest[] = []
    
    // 按严重程度和类型分组
    const groupedAnomalies = this.groupAnomalies(anomaliesToProcess)
    
    for (const group of groupedAnomalies) {
      const ticketRequest = this.createTicketRequest(group)
      ticketRequests.push(ticketRequest)
    }
    
    return ticketRequests
  }
  
  // 标记工单已生成
  markTicketsGenerated(ticketIds: string[]): void {
    this._generatedTickets.push(...ticketIds)
    
    // 更新异常状态
    this._anomalies.forEach(anomaly => {
      if (ticketIds.some(id => anomaly.relatedTicketId === id)) {
        anomaly.markHandled()
      }
    })
  }
  
  private initializeItems(floor: Floor): void {
    const template = InspectionTemplate.getByFloor(floor)
    
    for (const itemConfig of template.items) {
      const item = new InspectionItem(itemConfig)
      this._items.set(item.code, item)
    }
  }
  
  private detectAnomaly(item: InspectionItem, value: any): Anomaly | null {
    const detector = new AnomalyDetector()
    return detector.detect(item, value, this._floor)
  }
  
  private validateCompletion(): void {
    const incompleteItems = Array.from(this._items.values())
      .filter(item => item.isRequired && !item.isCompleted)
      
    if (incompleteItems.length > 0) {
      throw new DomainError(
        `还有 ${incompleteItems.length} 个必检项未完成`
      )
    }
  }
  
  private groupAnomalies(anomalies: Anomaly[]): AnomalyGroup[] {
    const groups = new Map<string, Anomaly[]>()
    
    anomalies.forEach(anomaly => {
      const key = `${anomaly.severity}_${anomaly.category}`
      if (!groups.has(key)) {
        groups.set(key, [])
      }
      groups.get(key)!.push(anomaly)
    })
    
    return Array.from(groups.values()).map(anomalies => ({
      anomalies,
      severity: anomalies[0].severity,
      category: anomalies[0].category
    }))
  }
  
  private createTicketRequest(group: AnomalyGroup): TicketRequest {
    const priority = this.mapSeverityToPriority(group.severity)
    const title = this.generateTicketTitle(group)
    const description = this.generateTicketDescription(group)
    
    return {
      title,
      description,
      priority,
      category: group.category,
      sourceType: 'inspection',
      sourceId: this._id,
      anomalyIds: group.anomalies.map(a => a.id)
    }
  }
  
  private mapSeverityToPriority(severity: Severity): TicketPriority {
    const map = {
      [Severity.CRITICAL]: TicketPriority.URGENT,
      [Severity.HIGH]: TicketPriority.HIGH,
      [Severity.MEDIUM]: TicketPriority.MEDIUM,
      [Severity.LOW]: TicketPriority.LOW
    }
    return map[severity]
  }
  
  private generateInspectionNo(): string {
    const date = format(new Date(), 'yyyyMMdd')
    const random = Math.random().toString(36).substr(2, 4).toUpperCase()
    return `INS-${date}-${random}`
  }
}
```

#### 2. 巡检项值对象
```typescript
// src/domain/inspection/value-objects/InspectionItem.ts
export class InspectionItem {
  readonly code: string
  readonly name: string
  readonly category: ItemCategory
  readonly dataType: DataType
  readonly unit?: string
  readonly normalRange?: Range
  readonly warningRange?: Range
  readonly criticalRange?: Range
  readonly isRequired: boolean
  
  private _value?: any
  private _remark?: string
  private _recordedAt?: Date
  private _isCompleted: boolean = false
  
  constructor(config: InspectionItemConfig) {
    this.code = config.code
    this.name = config.name
    this.category = config.category
    this.dataType = config.dataType
    this.unit = config.unit
    this.normalRange = config.normalRange
    this.warningRange = config.warningRange
    this.criticalRange = config.criticalRange
    this.isRequired = config.isRequired ?? true
  }
  
  record(value: any, remark?: string): void {
    this.validateValue(value)
    
    this._value = this.convertValue(value)
    this._remark = remark
    this._recordedAt = new Date()
    this._isCompleted = true
  }
  
  private validateValue(value: any): void {
    switch (this.dataType) {
      case DataType.NUMBER:
        if (typeof value !== 'number' && !Number.isFinite(Number(value))) {
          throw new ValidationError(`${this.name} 必须是数字`)
        }
        break
      case DataType.BOOLEAN:
        if (typeof value !== 'boolean') {
          throw new ValidationError(`${this.name} 必须是布尔值`)
        }
        break
      case DataType.TEXT:
        if (typeof value !== 'string') {
          throw new ValidationError(`${this.name} 必须是文本`)
        }
        break
      case DataType.SELECT:
        if (!this.options?.includes(value)) {
          throw new ValidationError(`${this.name} 的值不在选项中`)
        }
        break
    }
  }
  
  private convertValue(value: any): any {
    if (this.dataType === DataType.NUMBER) {
      return Number(value)
    }
    return value
  }
  
  get value(): any {
    return this._value
  }
  
  get isCompleted(): boolean {
    return this._isCompleted
  }
  
  get isNormal(): boolean {
    if (!this.normalRange || this._value === undefined) return true
    return this._value >= this.normalRange.min && this._value <= this.normalRange.max
  }
  
  get isWarning(): boolean {
    if (!this.warningRange || this._value === undefined) return false
    return (this._value < this.warningRange.min || this._value > this.warningRange.max) &&
           !this.isCritical
  }
  
  get isCritical(): boolean {
    if (!this.criticalRange || this._value === undefined) return false
    return this._value < this.criticalRange.min || this._value > this.criticalRange.max
  }
}
```

### Day 2: 异常检测和巡检配置（8小时）

#### 1. 异常检测器
```typescript
// src/domain/inspection/services/AnomalyDetector.ts
export class AnomalyDetector {
  private rules: DetectionRule[]
  
  constructor() {
    this.rules = this.loadDetectionRules()
  }
  
  detect(item: InspectionItem, value: any, floor: Floor): Anomaly | null {
    // 1. 基于范围的检测
    const rangeAnomaly = this.detectByRange(item, value)
    if (rangeAnomaly) return rangeAnomaly
    
    // 2. 基于规则的检测
    const ruleAnomaly = this.detectByRules(item, value, floor)
    if (ruleAnomaly) return ruleAnomaly
    
    // 3. 基于历史数据的检测
    const historicalAnomaly = this.detectByHistory(item, value)
    if (historicalAnomaly) return historicalAnomaly
    
    return null
  }
  
  private detectByRange(item: InspectionItem, value: any): Anomaly | null {
    if (item.dataType !== DataType.NUMBER) return null
    
    const numValue = Number(value)
    
    if (item.isCritical) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.CRITICAL,
        category: item.category,
        description: `${item.name} 值为 ${numValue}${item.unit || ''}，超出临界范围`,
        threshold: item.criticalRange
      })
    }
    
    if (item.isWarning) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.HIGH,
        category: item.category,
        description: `${item.name} 值为 ${numValue}${item.unit || ''}，超出警告范围`,
        threshold: item.warningRange
      })
    }
    
    return null
  }
  
  private detectByRules(item: InspectionItem, value: any, floor: Floor): Anomaly | null {
    const applicableRules = this.rules.filter(rule => 
      rule.appliesTo(item, floor)
    )
    
    for (const rule of applicableRules) {
      const anomaly = rule.evaluate(item, value)
      if (anomaly) return anomaly
    }
    
    return null
  }
  
  private detectByHistory(item: InspectionItem, value: any): Anomaly | null {
    // 获取历史数据（简化示例）
    const history = this.getHistoricalData(item.code)
    if (history.length < 10) return null // 需要足够的历史数据
    
    const stats = this.calculateStatistics(history)
    const numValue = Number(value)
    
    // 检测异常值（超过3个标准差）
    if (Math.abs(numValue - stats.mean) > 3 * stats.stdDev) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.MEDIUM,
        category: item.category,
        description: `${item.name} 值为 ${numValue}${item.unit || ''}，与历史数据偏差较大`,
        historicalMean: stats.mean,
        historicalStdDev: stats.stdDev
      })
    }
    
    return null
  }
  
  private loadDetectionRules(): DetectionRule[] {
    return [
      new TemperatureHumidityCorrelationRule(),
      new PowerConsumptionRule(),
      new EquipmentStatusRule(),
      new SafetyComplianceRule()
    ]
  }
  
  private getHistoricalData(itemCode: string): number[] {
    // 实际应该从repository获取
    return []
  }
  
  private calculateStatistics(data: number[]): Statistics {
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length
    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length
    const stdDev = Math.sqrt(variance)
    
    return { mean, variance, stdDev }
  }
}
```

#### 2. 巡检模板配置
```typescript
// src/domain/inspection/config/InspectionTemplate.ts
export class InspectionTemplate {
  private static templates: Map<Floor, InspectionItemConfig[]> = new Map()
  
  static {
    // 初始化模板配置
    this.initializeTemplates()
  }
  
  private static initializeTemplates(): void {
    // 1楼配置（22项）
    this.templates.set(Floor.FLOOR_1, [
      // 暖通系统
      {
        code: 'F1_HVAC_001',
        name: '冷冻泵回水压力',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: 'MPa',
        normalRange: { min: 0.4, max: 1.2 },
        warningRange: { min: 0.2, max: 1.5 },
        criticalRange: { min: 0.1, max: 2.0 }
      },
      {
        code: 'F1_HVAC_002',
        name: '冷冻泵出水压力',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: 'MPa',
        normalRange: { min: 0.5, max: 1.3 },
        warningRange: { min: 0.3, max: 1.6 },
        criticalRange: { min: 0.2, max: 2.0 }
      },
      {
        code: 'F1_HVAC_003',
        name: '冷冻水供水温度',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: '°C',
        normalRange: { min: 6, max: 8 },
        warningRange: { min: 5, max: 10 },
        criticalRange: { min: 3, max: 15 }
      },
      // 配电系统
      {
        code: 'F1_POWER_001',
        name: '配电室温度',
        category: ItemCategory.POWER,
        dataType: DataType.NUMBER,
        unit: '°C',
        normalRange: { min: 18, max: 26 },
        warningRange: { min: 15, max: 30 },
        criticalRange: { min: 10, max: 35 }
      },
      {
        code: 'F1_POWER_002',
        name: '配电室湿度',
        category: ItemCategory.POWER,
        dataType: DataType.NUMBER,
        unit: '%',
        normalRange: { min: 40, max: 60 },
        warningRange: { min: 35, max: 65 },
        criticalRange: { min: 30, max: 70 }
      },
      // ... 其他16项
    ])
    
    // 2楼配置（18项）
    this.templates.set(Floor.FLOOR_2, [
      // ... 18项配置
    ])
    
    // 3楼配置（13项）
    this.templates.set(Floor.FLOOR_3, [
      // ... 13项配置
    ])
    
    // 4楼配置（3项）
    this.templates.set(Floor.FLOOR_4, [
      {
        code: 'F4_SAFETY_001',
        name: '油箱间柴油气体浓度',
        category: ItemCategory.SAFETY,
        dataType: DataType.NUMBER,
        unit: 'ppm',
        normalRange: { min: 0, max: 500 },
        warningRange: { min: 0, max: 1000 },
        criticalRange: { min: 0, max: 2000 }
      },
      {
        code: 'F4_SAFETY_002',
        name: '消防系统状态',
        category: ItemCategory.FIRE,
        dataType: DataType.BOOLEAN,
        description: '正常/异常'
      },
      {
        code: 'F4_SAFETY_003',
        name: '应急照明状态',
        category: ItemCategory.ELECTRICAL,
        dataType: DataType.SELECT,
        options: ['正常', '部分故障', '全部故障']
      }
    ])
  }
  
  static getByFloor(floor: Floor): { items: InspectionItemConfig[] } {
    const items = this.templates.get(floor)
    if (!items) {
      throw new Error(`No template found for floor: ${floor}`)
    }
    return { items }
  }
  
  static getTotalItemsCount(): number {
    let total = 0
    this.templates.forEach(items => {
      total += items.length
    })
    return total // 应该返回56
  }
  
  static getFloorItemsCount(floor: Floor): number {
    const items = this.templates.get(floor)
    return items ? items.length : 0
  }
}
```

---

## Milestone 4.2: 解耦工单生成（3天）

### Day 3: 事件驱动的工单生成（8小时）

#### 1. 巡检领域服务
```typescript
// src/domain/inspection/InspectionDomain.ts
@Injectable()
export class InspectionDomain {
  constructor(
    @Inject('InspectionRepository') private repository: InspectionRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {}
  
  async createInspection(dto: CreateInspectionDto): Promise<Inspection> {
    // 创建巡检实体
    const inspection = new Inspection({
      floor: dto.floor,
      inspectorId: dto.inspectorId,
      inspectionDate: dto.inspectionDate || new Date()
    })
    
    // 持久化
    const saved = await this.repository.save(inspection)
    
    // 发布事件
    this.eventBus.emit('inspection.created', {
      inspectionId: saved.id,
      floor: saved.floor,
      inspectorId: saved.inspectorId
    })
    
    return saved
  }
  
  async startInspection(inspectionId: string): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    inspection.start()
    await this.repository.update(inspection)
    
    this.eventBus.emit('inspection.started', {
      inspectionId,
      startTime: inspection.startTime
    })
  }
  
  async recordInspectionItem(
    inspectionId: string,
    itemCode: string,
    value: any,
    remark?: string
  ): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // 记录项目值
    inspection.recordItem(itemCode, value, remark)
    
    // 检查是否产生异常
    const anomalies = inspection.getAnomalies()
    const newAnomaly = anomalies[anomalies.length - 1] // 最新的异常
    
    if (newAnomaly) {
      // 发布异常检测事件
      this.eventBus.emit('inspection.anomaly.detected', {
        inspectionId,
        anomaly: newAnomaly,
        floor: inspection.floor,
        itemCode,
        value
      })
    }
    
    await this.repository.update(inspection)
  }
  
  async completeInspection(inspectionId: string): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    inspection.complete()
    await this.repository.update(inspection)
    
    // 发布完成事件
    this.eventBus.emit('inspection.completed', {
      inspectionId,
      endTime: inspection.endTime,
      totalItems: inspection.getTotalItems(),
      completedItems: inspection.getCompletedItems(),
      anomalyCount: inspection.getAnomalies().length
    })
  }
  
  async generateTicketsForAnomalies(
    inspectionId: string,
    selectedAnomalyIds?: string[]
  ): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // 生成工单请求
    const ticketRequests = inspection.generateTicketsForAnomalies(selectedAnomalyIds)
    
    if (ticketRequests.length === 0) {
      throw new DomainError('没有需要生成工单的异常')
    }
    
    // 发布批量创建工单事件，而不是直接调用工单服务
    this.eventBus.emit('tickets.batch.create.requested', {
      source: 'inspection',
      sourceId: inspectionId,
      requests: ticketRequests,
      metadata: {
        floor: inspection.floor,
        inspectorId: inspection.inspectorId,
        inspectionDate: inspection.inspectionDate
      }
    })
    
    this.logger.info('Ticket creation requested from inspection', {
      inspectionId,
      ticketCount: ticketRequests.length
    })
  }
  
  async handleTicketsCreated(inspectionId: string, ticketIds: string[]): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // 标记工单已生成
    inspection.markTicketsGenerated(ticketIds)
    await this.repository.update(inspection)
    
    this.logger.info('Tickets marked as generated for inspection', {
      inspectionId,
      ticketIds
    })
  }
  
  async getLatestInspection(floor?: Floor): Promise<Inspection | null> {
    return await this.repository.findLatest(floor)
  }
  
  async copyInspection(inspectionId: string): Promise<Inspection> {
    const source = await this.repository.findById(inspectionId)
    
    if (!source) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // 创建副本
    const copy = source.copy()
    const saved = await this.repository.save(copy)
    
    this.eventBus.emit('inspection.copied', {
      sourceId: inspectionId,
      copyId: saved.id
    })
    
    return saved
  }
}
```

### Day 4: 工单生成协调器（8小时）

#### 1. 巡检-工单协调器
```typescript
// src/services/inspection/InspectionTicketOrchestrator.ts
@Injectable()
export class InspectionTicketOrchestrator {
  private pendingRequests = new Map<string, TicketRequest[]>()
  
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.setupEventHandlers()
  }
  
  private setupEventHandlers(): void {
    // 监听工单创建请求
    this.eventBus.on(
      'tickets.batch.create.requested',
      this.handleTicketCreateRequest.bind(this)
    )
    
    // 监听工单创建成功
    this.eventBus.on(
      'tickets.batch.created',
      this.handleTicketsCreated.bind(this)
    )
    
    // 监听工单创建失败
    this.eventBus.on(
      'tickets.batch.create.failed',
      this.handleTicketCreateFailed.bind(this)
    )
  }
  
  private async handleTicketCreateRequest(event: any): Promise<void> {
    if (event.source !== 'inspection') return
    
    const { sourceId, requests, metadata } = event
    
    try {
      // 存储待处理请求
      this.pendingRequests.set(sourceId, requests)
      
      // 应用业务规则
      const processedRequests = await this.applyBusinessRules(requests, metadata)
      
      // 转发给工单服务
      this.eventBus.emit('ticket.service.create.batch', {
        requests: processedRequests,
        source: 'inspection',
        sourceId,
        correlationId: generateCorrelationId()
      })
      
      this.logger.info('Forwarded ticket creation to ticket service', {
        inspectionId: sourceId,
        requestCount: processedRequests.length
      })
    } catch (error) {
      this.logger.error('Failed to process ticket creation request', {
        error,
        inspectionId: sourceId
      })
      
      // 发布失败事件
      this.eventBus.emit('inspection.ticket.creation.failed', {
        inspectionId: sourceId,
        error: error.message
      })
    }
  }
  
  private async applyBusinessRules(
    requests: TicketRequest[],
    metadata: any
  ): Promise<TicketRequest[]> {
    const processed: TicketRequest[] = []
    
    for (const request of requests) {
      // 规则1：合并相似异常
      const merged = this.mergeSimiarAnomalies(request, processed)
      if (merged) continue
      
      // 规则2：调整优先级
      request.priority = await this.adjustPriority(request, metadata)
      
      // 规则3：自动分配
      request.assigneeId = await this.autoAssign(request, metadata)
      
      // 规则4：设置SLA
      request.deadline = this.calculateDeadline(request.priority)
      
      processed.push(request)
    }
    
    return processed
  }
  
  private mergeSimiarAnomalies(
    request: TicketRequest,
    existing: TicketRequest[]
  ): boolean {
    // 查找相似的已存在请求
    const similar = existing.find(e => 
      e.category === request.category &&
      e.priority === request.priority &&
      this.isSimilarDescription(e.description, request.description)
    )
    
    if (similar) {
      // 合并到现有请求
      similar.description += `\n\n${request.description}`
      similar.anomalyIds = [...similar.anomalyIds, ...request.anomalyIds]
      return true
    }
    
    return false
  }
  
  private async adjustPriority(
    request: TicketRequest,
    metadata: any
  ): Promise<TicketPriority> {
    // 基于楼层调整优先级
    const floorPriorityMap = {
      [Floor.FLOOR_1]: 1, // 1楼优先级最高
      [Floor.FLOOR_2]: 2,
      [Floor.FLOOR_3]: 3,
      [Floor.FLOOR_4]: 4
    }
    
    const floorPriority = floorPriorityMap[metadata.floor] || 5
    
    // 如果是高楼层的紧急问题，提升优先级
    if (floorPriority <= 2 && request.priority === TicketPriority.HIGH) {
      return TicketPriority.URGENT
    }
    
    return request.priority
  }
  
  private async autoAssign(
    request: TicketRequest,
    metadata: any
  ): Promise<string | undefined> {
    // 基于类别自动分配
    const categoryAssigneeMap = await this.getCategoryAssigneeMap()
    const assigneeId = categoryAssigneeMap[request.category]
    
    if (assigneeId) {
      this.logger.info('Auto-assigned ticket', {
        category: request.category,
        assigneeId
      })
      return assigneeId
    }
    
    return undefined
  }
  
  private calculateDeadline(priority: TicketPriority): Date {
    const slaHours = this.config.get(`business.ticket.sla.${priority}`)
    const deadline = new Date()
    deadline.setHours(deadline.getHours() + slaHours)
    return deadline
  }
  
  private async handleTicketsCreated(event: any): Promise<void> {
    const { source, sourceId, ticketIds } = event
    
    if (source !== 'inspection') return
    
    // 清理待处理请求
    this.pendingRequests.delete(sourceId)
    
    // 通知巡检服务
    this.eventBus.emit('inspection.tickets.created', {
      inspectionId: sourceId,
      ticketIds
    })
    
    this.logger.info('Tickets created for inspection', {
      inspectionId: sourceId,
      ticketIds
    })
  }
  
  private async handleTicketCreateFailed(event: any): Promise<void> {
    const { source, sourceId, error } = event
    
    if (source !== 'inspection') return
    
    // 获取失败的请求
    const failedRequests = this.pendingRequests.get(sourceId)
    
    if (failedRequests) {
      // 重试逻辑
      await this.retryTicketCreation(sourceId, failedRequests)
    }
    
    this.logger.error('Failed to create tickets for inspection', {
      inspectionId: sourceId,
      error
    })
  }
  
  private async retryTicketCreation(
    inspectionId: string,
    requests: TicketRequest[]
  ): Promise<void> {
    const maxRetries = this.config.get('business.inspection.ticketCreation.maxRetries', 3)
    const retryDelay = this.config.get('business.inspection.ticketCreation.retryDelay', 5000)
    
    // 实现指数退避重试
    for (let i = 0; i < maxRetries; i++) {
      await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, i)))
      
      try {
        this.eventBus.emit('ticket.service.create.batch', {
          requests,
          source: 'inspection',
          sourceId: inspectionId,
          retry: i + 1
        })
        
        this.logger.info('Retrying ticket creation', {
          inspectionId,
          attempt: i + 1
        })
        
        break
      } catch (error) {
        if (i === maxRetries - 1) {
          // 最后一次重试失败，发送告警
          this.eventBus.emit('alert.ticket.creation.failed', {
            inspectionId,
            requests,
            error
          })
        }
      }
    }
  }
  
  private isSimilarDescription(desc1: string, desc2: string): boolean {
    // 简单的相似度判断（实际可以使用更复杂的算法）
    const words1 = new Set(desc1.toLowerCase().split(/\s+/))
    const words2 = new Set(desc2.toLowerCase().split(/\s+/))
    
    const intersection = new Set([...words1].filter(x => words2.has(x)))
    const union = new Set([...words1, ...words2])
    
    const similarity = intersection.size / union.size
    return similarity > 0.7 // 70%相似度
  }
  
  private async getCategoryAssigneeMap(): Promise<Record<string, string>> {
    // 实际应该从配置或数据库获取
    return {
      [ItemCategory.HVAC]: 'user_hvac_001',
      [ItemCategory.POWER]: 'user_power_001',
      [ItemCategory.FIRE]: 'user_fire_001',
      [ItemCategory.ELECTRICAL]: 'user_elec_001'
    }
  }
}
```

### Day 5: 异步工单生成和重试机制（8小时）

#### 1. 工单批量创建服务
```typescript
// src/services/ticket/TicketBatchCreationService.ts
@Injectable()
export class TicketBatchCreationService {
  private queue: Queue<BatchCreateJob>
  
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.queue = new Queue('ticket-batch-creation', {
      concurrency: 5,
      retries: 3
    })
    
    this.setupQueueHandlers()
    this.setupEventHandlers()
  }
  
  private setupQueueHandlers(): void {
    this.queue.process(async (job) => {
      return await this.processBatchCreation(job.data)
    })
    
    this.queue.on('completed', (job, result) => {
      this.handleJobCompleted(job, result)
    })
    
    this.queue.on('failed', (job, error) => {
      this.handleJobFailed(job, error)
    })
  }
  
  private setupEventHandlers(): void {
    this.eventBus.on(
      'ticket.service.create.batch',
      this.handleBatchCreateRequest.bind(this)
    )
  }
  
  private async handleBatchCreateRequest(event: any): Promise<void> {
    const { requests, source, sourceId, correlationId } = event
    
    // 添加到队列
    const job = await this.queue.add({
      requests,
      source,
      sourceId,
      correlationId,
      timestamp: new Date()
    })
    
    this.logger.info('Batch creation job queued', {
      jobId: job.id,
      source,
      sourceId,
      requestCount: requests.length
    })
  }
  
  private async processBatchCreation(data: BatchCreateJob): Promise<BatchCreateResult> {
    const { requests, source, sourceId } = data
    const results: BatchCreateResult = {
      successful: [],
      failed: [],
      total: requests.length
    }
    
    // 使用事务批量创建
    await this.repository.transaction(async (trx) => {
      for (const request of requests) {
        try {
          const ticket = await this.createSingleTicket(request, trx)
          results.successful.push({
            request,
            ticketId: ticket.id
          })
        } catch (error) {
          results.failed.push({
            request,
            error: error.message
          })
          
          // 决定是否继续或回滚
          if (this.shouldAbortBatch(error)) {
            throw error
          }
        }
      }
    })
    
    return results
  }
  
  private async createSingleTicket(
    request: TicketRequest,
    trx: Transaction
  ): Promise<Ticket> {
    // 创建工单实体
    const ticket = new Ticket({
      title: request.title,
      description: request.description,
      priority: request.priority,
      category: request.category,
      sourceType: request.sourceType,
      sourceId: request.sourceId,
      assigneeId: request.assigneeId,
      deadline: request.deadline,
      status: TicketStatus.PENDING
    })
    
    // 验证
    await this.validateTicket(ticket)
    
    // 保存
    const saved = await this.repository.save(ticket, { transaction: trx })
    
    // 记录审计日志
    await this.logTicketCreation(saved, request)
    
    return saved
  }
  
  private async validateTicket(ticket: Ticket): Promise<void> {
    // 检查重复
    const duplicate = await this.repository.findDuplicate(ticket.title)
    if (duplicate) {
      throw new DomainError(`Duplicate ticket: ${duplicate.id}`)
    }
    
    // 其他验证...
  }
  
  private shouldAbortBatch(error: Error): boolean {
    // 某些错误应该中止整个批次
    return error instanceof DatabaseError || 
           error instanceof AuthorizationError
  }
  
  private async handleJobCompleted(job: Job, result: BatchCreateResult): Promise<void> {
    const { source, sourceId } = job.data
    
    // 发布成功事件
    this.eventBus.emit('tickets.batch.created', {
      source,
      sourceId,
      ticketIds: result.successful.map(s => s.ticketId),
      failedCount: result.failed.length,
      totalCount: result.total
    })
    
    // 如果有失败的，发布部分失败事件
    if (result.failed.length > 0) {
      this.eventBus.emit('tickets.batch.partial.failure', {
        source,
        sourceId,
        failed: result.failed
      })
    }
    
    this.logger.info('Batch creation completed', {
      jobId: job.id,
      successful: result.successful.length,
      failed: result.failed.length
    })
  }
  
  private async handleJobFailed(job: Job, error: Error): Promise<void> {
    const { source, sourceId } = job.data
    
    // 发布失败事件
    this.eventBus.emit('tickets.batch.create.failed', {
      source,
      sourceId,
      error: error.message,
      attempts: job.attemptsMade
    })
    
    this.logger.error('Batch creation failed', {
      jobId: job.id,
      error,
      attempts: job.attemptsMade
    })
  }
  
  private async logTicketCreation(ticket: Ticket, request: TicketRequest): Promise<void> {
    await this.repository.saveAuditLog({
      action: 'TICKET_CREATED_FROM_INSPECTION',
      entityId: ticket.id,
      entityType: 'Ticket',
      metadata: {
        sourceType: request.sourceType,
        sourceId: request.sourceId,
        anomalyIds: request.anomalyIds
      },
      timestamp: new Date()
    })
  }
}
```

---

## Milestone 4.3: 巡检配置独立（1天）

### Day 6: 配置服务和UI（8小时）

#### 1. 巡检配置服务
```typescript
// src/services/inspection/InspectionConfigService.ts
@Injectable()
export class InspectionConfigService {
  private configCache = new Map<string, any>()
  private listeners = new Map<string, Set<Function>>()
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.loadConfigurations()
    this.setupConfigSync()
  }
  
  private loadConfigurations(): void {
    // 加载巡检配置
    const inspectionConfig = {
      floors: {
        floor1: {
          label: '1楼',
          itemCount: 22,
          categories: ['hvac', 'power', 'fire']
        },
        floor2: {
          label: '2楼',
          itemCount: 18,
          categories: ['hvac', 'power', 'electrical']
        },
        floor3: {
          label: '3楼',
          itemCount: 13,
          categories: ['hvac', 'ups', 'monitoring']
        },
        floor4: {
          label: '4楼',
          itemCount: 3,
          categories: ['safety', 'fire', 'electrical']
        }
      },
      
      anomalyDetection: {
        enableHistoricalAnalysis: true,
        historicalDataPoints: 30,
        anomalyThreshold: 3, // 标准差
        correlationRules: true
      },
      
      ticketGeneration: {
        autoGenerate: false,
        mergeSimilar: true,
        similarityThreshold: 0.7,
        batchSize: 10,
        retryAttempts: 3,
        retryDelay: 5000
      },
      
      thresholds: {
        temperature: {
          normal: { min: 18, max: 26 },
          warning: { min: 15, max: 30 },
          critical: { min: 10, max: 35 }
        },
        humidity: {
          normal: { min: 40, max: 60 },
          warning: { min: 35, max: 65 },
          critical: { min: 30, max: 70 }
        },
        pressure: {
          normal: { min: 0.4, max: 1.2 },
          warning: { min: 0.2, max: 1.5 },
          critical: { min: 0.1, max: 2.0 }
        }
      }
    }
    
    // 存储到缓存
    this.configCache.set('inspection', inspectionConfig)
    
    // 注册到全局配置服务
    this.registerToGlobalConfig(inspectionConfig)
  }
  
  private registerToGlobalConfig(config: any): void {
    // 注册配置到全局配置服务
    Object.entries(config).forEach(([key, value]) => {
      this.config.set(`business.inspection.${key}`, value)
    })
  }
  
  private setupConfigSync(): void {
    // 监听配置变更事件
    this.eventBus.on('config.updated', (event) => {
      if (event.path.startsWith('business.inspection')) {
        this.handleConfigUpdate(event)
      }
    })
  }
  
  private handleConfigUpdate(event: any): void {
    const { path, value, oldValue } = event
    
    // 更新缓存
    const key = path.replace('business.inspection.', '')
    this.updateCache(key, value)
    
    // 通知监听器
    this.notifyListeners(key, value, oldValue)
    
    // 发布配置变更事件
    this.eventBus.emit('inspection.config.updated', {
      key,
      value,
      oldValue
    })
    
    this.logger.info('Inspection config updated', {
      key,
      value
    })
  }
  
  private updateCache(key: string, value: any): void {
    const parts = key.split('.')
    let target = this.configCache.get('inspection')
    
    for (let i = 0; i < parts.length - 1; i++) {
      target = target[parts[i]]
    }
    
    target[parts[parts.length - 1]] = value
  }
  
  private notifyListeners(key: string, value: any, oldValue: any): void {
    const listeners = this.listeners.get(key)
    if (listeners) {
      listeners.forEach(listener => {
        try {
          listener(value, oldValue)
        } catch (error) {
          this.logger.error('Config listener error', { key, error })
        }
      }
    })
  }
  
  // 公共方法
  get(key: string, defaultValue?: any): any {
    const config = this.configCache.get('inspection')
    const parts = key.split('.')
    
    let value = config
    for (const part of parts) {
      value = value?.[part]
    }
    
    return value ?? defaultValue
  }
  
  set(key: string, value: any): void {
    const fullPath = `business.inspection.${key}`
    this.config.set(fullPath, value)
  }
  
  watch(key: string, callback: Function): () => void {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set())
    }
    
    this.listeners.get(key)!.add(callback)
    
    return () => {
      this.listeners.get(key)?.delete(callback)
    }
  }
  
  getFloorConfig(floor: Floor): any {
    return this.get(`floors.${floor}`)
  }
  
  getThreshold(type: string): any {
    return this.get(`thresholds.${type}`)
  }
  
  getAnomalyDetectionConfig(): any {
    return this.get('anomalyDetection')
  }
  
  getTicketGenerationConfig(): any {
    return this.get('ticketGeneration')
  }
}
```

#### 2. 配置管理UI组件
```vue
<!-- src/views/business/inspection/config/index.vue -->
<template>
  <div class="inspection-config">
    <el-tabs v-model="activeTab">
      <el-tab-pane label="楼层配置" name="floors">
        <FloorConfig v-model="config.floors" @change="handleFloorConfigChange" />
      </el-tab-pane>
      
      <el-tab-pane label="阈值配置" name="thresholds">
        <ThresholdConfig v-model="config.thresholds" @change="handleThresholdChange" />
      </el-tab-pane>
      
      <el-tab-pane label="异常检测" name="anomaly">
        <AnomalyDetectionConfig 
          v-model="config.anomalyDetection" 
          @change="handleAnomalyConfigChange"
        />
      </el-tab-pane>
      
      <el-tab-pane label="工单生成" name="ticket">
        <TicketGenerationConfig 
          v-model="config.ticketGeneration"
          @change="handleTicketConfigChange"
        />
      </el-tab-pane>
    </el-tabs>
    
    <div class="config-actions">
      <el-button @click="resetConfig">重置</el-button>
      <el-button @click="exportConfig">导出配置</el-button>
      <el-button @click="importConfig">导入配置</el-button>
      <el-button type="primary" @click="saveConfig">保存配置</el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useInspectionConfig } from '@/composables/useInspectionConfig'
import FloorConfig from './components/FloorConfig.vue'
import ThresholdConfig from './components/ThresholdConfig.vue'
import AnomalyDetectionConfig from './components/AnomalyDetectionConfig.vue'
import TicketGenerationConfig from './components/TicketGenerationConfig.vue'

const activeTab = ref('floors')

const {
  config,
  loadConfig,
  saveConfig,
  resetConfig,
  exportConfig,
  importConfig,
  handleFloorConfigChange,
  handleThresholdChange,
  handleAnomalyConfigChange,
  handleTicketConfigChange
} = useInspectionConfig()

onMounted(() => {
  loadConfig()
})
</script>

<style scoped>
.inspection-config {
  padding: 20px;
}

.config-actions {
  margin-top: 20px;
  text-align: right;
}
</style>
```

## 📊 Phase 4 完成标准检查清单

### 技术指标
- [ ] 巡检领域模型完整
- [ ] 异常检测准确率 > 95%
- [ ] 工单生成解耦完成
- [ ] 配置独立管理
- [ ] 测试覆盖率 > 85%

### 功能验证
- [ ] 56项巡检配置正确
- [ ] 异常自动检测正常
- [ ] 批量工单生成成功
- [ ] 重试机制工作正常
- [ ] 配置热更新生效

### 性能指标
- [ ] 巡检记录响应 < 100ms
- [ ] 批量工单生成 < 2s（10个）
- [ ] 配置加载 < 50ms

## 🚀 Phase 4 交付物

1. **领域模型**
   - Inspection实体
   - InspectionItem值对象
   - AnomalyDetector服务
   - InspectionTemplate配置

2. **服务层**
   - InspectionDomain领域服务
   - InspectionTicketOrchestrator协调器
   - TicketBatchCreationService批量创建服务
   - InspectionConfigService配置服务

3. **配置管理**
   - 56项巡检配置
   - 阈值配置
   - 异常检测规则
   - 工单生成策略

4. **测试文件**
   - 异常检测测试
   - 工单生成测试
   - 配置管理测试

5. **文档**
   - INSPECTION-DOMAIN.md
   - ANOMALY-DETECTION.md
   - BATCH-TICKET-CREATION.md

这就是Phase 4的完整实施方案，重点实现了巡检领域模型、解耦工单生成逻辑、实现事件驱动的批量工单创建，并独立了配置管理。