## Phase 4: æ ¸å¿ƒä¸šåŠ¡æ¨¡å—é‡æ„ - å·¡æ£€ï¼ˆ6å¤©ï¼‰

### ğŸ“… æ—¶é—´å®‰æ’
- **Day 1-2**: Milestone 4.1 å·¡æ£€é¢†åŸŸæ¨¡å‹
- **Day 3-5**: Milestone 4.2 è§£è€¦å·¥å•ç”Ÿæˆ
- **Day 6**: Milestone 4.3 å·¡æ£€é…ç½®ç‹¬ç«‹

---

## Milestone 4.1: å·¡æ£€é¢†åŸŸæ¨¡å‹ï¼ˆ2å¤©ï¼‰

### Day 1: å·¡æ£€å®ä½“å’Œå€¼å¯¹è±¡è®¾è®¡ï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¡æ£€å®ä½“å®šä¹‰
```typescript
// src/domain/inspection/entities/Inspection.ts
export class Inspection {
  private _id: string
  private _inspectionNo: string
  private _floor: Floor
  private _inspectorId: string
  private _inspectionDate: Date
  private _items: Map<string, InspectionItem>
  private _anomalies: Anomaly[]
  private _status: InspectionStatus
  private _startTime?: Date
  private _endTime?: Date
  private _generatedTickets: string[]
  
  constructor(props: InspectionProps) {
    this.validate(props)
    this._id = props.id || generateId()
    this._inspectionNo = props.inspectionNo || this.generateInspectionNo()
    this._floor = props.floor
    this._inspectorId = props.inspectorId
    this._inspectionDate = props.inspectionDate
    this._items = new Map()
    this._anomalies = []
    this._generatedTickets = []
    this._status = InspectionStatus.PENDING
    
    // åˆå§‹åŒ–å·¡æ£€é¡¹
    this.initializeItems(props.floor)
  }
  
  // å¼€å§‹å·¡æ£€
  start(): void {
    if (this._status !== InspectionStatus.PENDING) {
      throw new DomainError('åªèƒ½å¼€å§‹å¾…æ‰§è¡Œçš„å·¡æ£€')
    }
    
    this._status = InspectionStatus.IN_PROGRESS
    this._startTime = new Date()
  }
  
  // è®°å½•å·¡æ£€é¡¹
  recordItem(itemCode: string, value: any, remark?: string): void {
    if (this._status !== InspectionStatus.IN_PROGRESS) {
      throw new DomainError('åªèƒ½åœ¨è¿›è¡Œä¸­çš„å·¡æ£€è®°å½•æ•°æ®')
    }
    
    const item = this._items.get(itemCode)
    if (!item) {
      throw new DomainError(`å·¡æ£€é¡¹ ${itemCode} ä¸å­˜åœ¨`)
    }
    
    item.record(value, remark)
    
    // æ£€æµ‹å¼‚å¸¸
    const anomaly = this.detectAnomaly(item, value)
    if (anomaly) {
      this._anomalies.push(anomaly)
    }
  }
  
  // å®Œæˆå·¡æ£€
  complete(): void {
    if (this._status !== InspectionStatus.IN_PROGRESS) {
      throw new DomainError('åªèƒ½å®Œæˆè¿›è¡Œä¸­çš„å·¡æ£€')
    }
    
    // éªŒè¯æ‰€æœ‰å¿…æ£€é¡¹å·²å®Œæˆ
    this.validateCompletion()
    
    this._status = InspectionStatus.COMPLETED
    this._endTime = new Date()
  }
  
  // ç”Ÿæˆå¼‚å¸¸å·¥å•
  generateTicketsForAnomalies(selectedAnomalyIds?: string[]): TicketRequest[] {
    const anomaliesToProcess = selectedAnomalyIds 
      ? this._anomalies.filter(a => selectedAnomalyIds.includes(a.id))
      : this._anomalies
      
    if (anomaliesToProcess.length === 0) {
      throw new DomainError('æ²¡æœ‰éœ€è¦å¤„ç†çš„å¼‚å¸¸')
    }
    
    const ticketRequests: TicketRequest[] = []
    
    // æŒ‰ä¸¥é‡ç¨‹åº¦å’Œç±»å‹åˆ†ç»„
    const groupedAnomalies = this.groupAnomalies(anomaliesToProcess)
    
    for (const group of groupedAnomalies) {
      const ticketRequest = this.createTicketRequest(group)
      ticketRequests.push(ticketRequest)
    }
    
    return ticketRequests
  }
  
  // æ ‡è®°å·¥å•å·²ç”Ÿæˆ
  markTicketsGenerated(ticketIds: string[]): void {
    this._generatedTickets.push(...ticketIds)
    
    // æ›´æ–°å¼‚å¸¸çŠ¶æ€
    this._anomalies.forEach(anomaly => {
      if (ticketIds.some(id => anomaly.relatedTicketId === id)) {
        anomaly.markHandled()
      }
    })
  }
  
  private initializeItems(floor: Floor): void {
    const template = InspectionTemplate.getByFloor(floor)
    
    for (const itemConfig of template.items) {
      const item = new InspectionItem(itemConfig)
      this._items.set(item.code, item)
    }
  }
  
  private detectAnomaly(item: InspectionItem, value: any): Anomaly | null {
    const detector = new AnomalyDetector()
    return detector.detect(item, value, this._floor)
  }
  
  private validateCompletion(): void {
    const incompleteItems = Array.from(this._items.values())
      .filter(item => item.isRequired && !item.isCompleted)
      
    if (incompleteItems.length > 0) {
      throw new DomainError(
        `è¿˜æœ‰ ${incompleteItems.length} ä¸ªå¿…æ£€é¡¹æœªå®Œæˆ`
      )
    }
  }
  
  private groupAnomalies(anomalies: Anomaly[]): AnomalyGroup[] {
    const groups = new Map<string, Anomaly[]>()
    
    anomalies.forEach(anomaly => {
      const key = `${anomaly.severity}_${anomaly.category}`
      if (!groups.has(key)) {
        groups.set(key, [])
      }
      groups.get(key)!.push(anomaly)
    })
    
    return Array.from(groups.values()).map(anomalies => ({
      anomalies,
      severity: anomalies[0].severity,
      category: anomalies[0].category
    }))
  }
  
  private createTicketRequest(group: AnomalyGroup): TicketRequest {
    const priority = this.mapSeverityToPriority(group.severity)
    const title = this.generateTicketTitle(group)
    const description = this.generateTicketDescription(group)
    
    return {
      title,
      description,
      priority,
      category: group.category,
      sourceType: 'inspection',
      sourceId: this._id,
      anomalyIds: group.anomalies.map(a => a.id)
    }
  }
  
  private mapSeverityToPriority(severity: Severity): TicketPriority {
    const map = {
      [Severity.CRITICAL]: TicketPriority.URGENT,
      [Severity.HIGH]: TicketPriority.HIGH,
      [Severity.MEDIUM]: TicketPriority.MEDIUM,
      [Severity.LOW]: TicketPriority.LOW
    }
    return map[severity]
  }
  
  private generateInspectionNo(): string {
    const date = format(new Date(), 'yyyyMMdd')
    const random = Math.random().toString(36).substr(2, 4).toUpperCase()
    return `INS-${date}-${random}`
  }
}
```

#### 2. å·¡æ£€é¡¹å€¼å¯¹è±¡
```typescript
// src/domain/inspection/value-objects/InspectionItem.ts
export class InspectionItem {
  readonly code: string
  readonly name: string
  readonly category: ItemCategory
  readonly dataType: DataType
  readonly unit?: string
  readonly normalRange?: Range
  readonly warningRange?: Range
  readonly criticalRange?: Range
  readonly isRequired: boolean
  
  private _value?: any
  private _remark?: string
  private _recordedAt?: Date
  private _isCompleted: boolean = false
  
  constructor(config: InspectionItemConfig) {
    this.code = config.code
    this.name = config.name
    this.category = config.category
    this.dataType = config.dataType
    this.unit = config.unit
    this.normalRange = config.normalRange
    this.warningRange = config.warningRange
    this.criticalRange = config.criticalRange
    this.isRequired = config.isRequired ?? true
  }
  
  record(value: any, remark?: string): void {
    this.validateValue(value)
    
    this._value = this.convertValue(value)
    this._remark = remark
    this._recordedAt = new Date()
    this._isCompleted = true
  }
  
  private validateValue(value: any): void {
    switch (this.dataType) {
      case DataType.NUMBER:
        if (typeof value !== 'number' && !Number.isFinite(Number(value))) {
          throw new ValidationError(`${this.name} å¿…é¡»æ˜¯æ•°å­—`)
        }
        break
      case DataType.BOOLEAN:
        if (typeof value !== 'boolean') {
          throw new ValidationError(`${this.name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`)
        }
        break
      case DataType.TEXT:
        if (typeof value !== 'string') {
          throw new ValidationError(`${this.name} å¿…é¡»æ˜¯æ–‡æœ¬`)
        }
        break
      case DataType.SELECT:
        if (!this.options?.includes(value)) {
          throw new ValidationError(`${this.name} çš„å€¼ä¸åœ¨é€‰é¡¹ä¸­`)
        }
        break
    }
  }
  
  private convertValue(value: any): any {
    if (this.dataType === DataType.NUMBER) {
      return Number(value)
    }
    return value
  }
  
  get value(): any {
    return this._value
  }
  
  get isCompleted(): boolean {
    return this._isCompleted
  }
  
  get isNormal(): boolean {
    if (!this.normalRange || this._value === undefined) return true
    return this._value >= this.normalRange.min && this._value <= this.normalRange.max
  }
  
  get isWarning(): boolean {
    if (!this.warningRange || this._value === undefined) return false
    return (this._value < this.warningRange.min || this._value > this.warningRange.max) &&
           !this.isCritical
  }
  
  get isCritical(): boolean {
    if (!this.criticalRange || this._value === undefined) return false
    return this._value < this.criticalRange.min || this._value > this.criticalRange.max
  }
}
```

### Day 2: å¼‚å¸¸æ£€æµ‹å’Œå·¡æ£€é…ç½®ï¼ˆ8å°æ—¶ï¼‰

#### 1. å¼‚å¸¸æ£€æµ‹å™¨
```typescript
// src/domain/inspection/services/AnomalyDetector.ts
export class AnomalyDetector {
  private rules: DetectionRule[]
  
  constructor() {
    this.rules = this.loadDetectionRules()
  }
  
  detect(item: InspectionItem, value: any, floor: Floor): Anomaly | null {
    // 1. åŸºäºèŒƒå›´çš„æ£€æµ‹
    const rangeAnomaly = this.detectByRange(item, value)
    if (rangeAnomaly) return rangeAnomaly
    
    // 2. åŸºäºè§„åˆ™çš„æ£€æµ‹
    const ruleAnomaly = this.detectByRules(item, value, floor)
    if (ruleAnomaly) return ruleAnomaly
    
    // 3. åŸºäºå†å²æ•°æ®çš„æ£€æµ‹
    const historicalAnomaly = this.detectByHistory(item, value)
    if (historicalAnomaly) return historicalAnomaly
    
    return null
  }
  
  private detectByRange(item: InspectionItem, value: any): Anomaly | null {
    if (item.dataType !== DataType.NUMBER) return null
    
    const numValue = Number(value)
    
    if (item.isCritical) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.CRITICAL,
        category: item.category,
        description: `${item.name} å€¼ä¸º ${numValue}${item.unit || ''}ï¼Œè¶…å‡ºä¸´ç•ŒèŒƒå›´`,
        threshold: item.criticalRange
      })
    }
    
    if (item.isWarning) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.HIGH,
        category: item.category,
        description: `${item.name} å€¼ä¸º ${numValue}${item.unit || ''}ï¼Œè¶…å‡ºè­¦å‘ŠèŒƒå›´`,
        threshold: item.warningRange
      })
    }
    
    return null
  }
  
  private detectByRules(item: InspectionItem, value: any, floor: Floor): Anomaly | null {
    const applicableRules = this.rules.filter(rule => 
      rule.appliesTo(item, floor)
    )
    
    for (const rule of applicableRules) {
      const anomaly = rule.evaluate(item, value)
      if (anomaly) return anomaly
    }
    
    return null
  }
  
  private detectByHistory(item: InspectionItem, value: any): Anomaly | null {
    // è·å–å†å²æ•°æ®ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    const history = this.getHistoricalData(item.code)
    if (history.length < 10) return null // éœ€è¦è¶³å¤Ÿçš„å†å²æ•°æ®
    
    const stats = this.calculateStatistics(history)
    const numValue = Number(value)
    
    // æ£€æµ‹å¼‚å¸¸å€¼ï¼ˆè¶…è¿‡3ä¸ªæ ‡å‡†å·®ï¼‰
    if (Math.abs(numValue - stats.mean) > 3 * stats.stdDev) {
      return new Anomaly({
        itemCode: item.code,
        itemName: item.name,
        value: numValue,
        unit: item.unit,
        severity: Severity.MEDIUM,
        category: item.category,
        description: `${item.name} å€¼ä¸º ${numValue}${item.unit || ''}ï¼Œä¸å†å²æ•°æ®åå·®è¾ƒå¤§`,
        historicalMean: stats.mean,
        historicalStdDev: stats.stdDev
      })
    }
    
    return null
  }
  
  private loadDetectionRules(): DetectionRule[] {
    return [
      new TemperatureHumidityCorrelationRule(),
      new PowerConsumptionRule(),
      new EquipmentStatusRule(),
      new SafetyComplianceRule()
    ]
  }
  
  private getHistoricalData(itemCode: string): number[] {
    // å®é™…åº”è¯¥ä»repositoryè·å–
    return []
  }
  
  private calculateStatistics(data: number[]): Statistics {
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length
    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length
    const stdDev = Math.sqrt(variance)
    
    return { mean, variance, stdDev }
  }
}
```

#### 2. å·¡æ£€æ¨¡æ¿é…ç½®
```typescript
// src/domain/inspection/config/InspectionTemplate.ts
export class InspectionTemplate {
  private static templates: Map<Floor, InspectionItemConfig[]> = new Map()
  
  static {
    // åˆå§‹åŒ–æ¨¡æ¿é…ç½®
    this.initializeTemplates()
  }
  
  private static initializeTemplates(): void {
    // 1æ¥¼é…ç½®ï¼ˆ22é¡¹ï¼‰
    this.templates.set(Floor.FLOOR_1, [
      // æš–é€šç³»ç»Ÿ
      {
        code: 'F1_HVAC_001',
        name: 'å†·å†»æ³µå›æ°´å‹åŠ›',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: 'MPa',
        normalRange: { min: 0.4, max: 1.2 },
        warningRange: { min: 0.2, max: 1.5 },
        criticalRange: { min: 0.1, max: 2.0 }
      },
      {
        code: 'F1_HVAC_002',
        name: 'å†·å†»æ³µå‡ºæ°´å‹åŠ›',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: 'MPa',
        normalRange: { min: 0.5, max: 1.3 },
        warningRange: { min: 0.3, max: 1.6 },
        criticalRange: { min: 0.2, max: 2.0 }
      },
      {
        code: 'F1_HVAC_003',
        name: 'å†·å†»æ°´ä¾›æ°´æ¸©åº¦',
        category: ItemCategory.HVAC,
        dataType: DataType.NUMBER,
        unit: 'Â°C',
        normalRange: { min: 6, max: 8 },
        warningRange: { min: 5, max: 10 },
        criticalRange: { min: 3, max: 15 }
      },
      // é…ç”µç³»ç»Ÿ
      {
        code: 'F1_POWER_001',
        name: 'é…ç”µå®¤æ¸©åº¦',
        category: ItemCategory.POWER,
        dataType: DataType.NUMBER,
        unit: 'Â°C',
        normalRange: { min: 18, max: 26 },
        warningRange: { min: 15, max: 30 },
        criticalRange: { min: 10, max: 35 }
      },
      {
        code: 'F1_POWER_002',
        name: 'é…ç”µå®¤æ¹¿åº¦',
        category: ItemCategory.POWER,
        dataType: DataType.NUMBER,
        unit: '%',
        normalRange: { min: 40, max: 60 },
        warningRange: { min: 35, max: 65 },
        criticalRange: { min: 30, max: 70 }
      },
      // ... å…¶ä»–16é¡¹
    ])
    
    // 2æ¥¼é…ç½®ï¼ˆ18é¡¹ï¼‰
    this.templates.set(Floor.FLOOR_2, [
      // ... 18é¡¹é…ç½®
    ])
    
    // 3æ¥¼é…ç½®ï¼ˆ13é¡¹ï¼‰
    this.templates.set(Floor.FLOOR_3, [
      // ... 13é¡¹é…ç½®
    ])
    
    // 4æ¥¼é…ç½®ï¼ˆ3é¡¹ï¼‰
    this.templates.set(Floor.FLOOR_4, [
      {
        code: 'F4_SAFETY_001',
        name: 'æ²¹ç®±é—´æŸ´æ²¹æ°”ä½“æµ“åº¦',
        category: ItemCategory.SAFETY,
        dataType: DataType.NUMBER,
        unit: 'ppm',
        normalRange: { min: 0, max: 500 },
        warningRange: { min: 0, max: 1000 },
        criticalRange: { min: 0, max: 2000 }
      },
      {
        code: 'F4_SAFETY_002',
        name: 'æ¶ˆé˜²ç³»ç»ŸçŠ¶æ€',
        category: ItemCategory.FIRE,
        dataType: DataType.BOOLEAN,
        description: 'æ­£å¸¸/å¼‚å¸¸'
      },
      {
        code: 'F4_SAFETY_003',
        name: 'åº”æ€¥ç…§æ˜çŠ¶æ€',
        category: ItemCategory.ELECTRICAL,
        dataType: DataType.SELECT,
        options: ['æ­£å¸¸', 'éƒ¨åˆ†æ•…éšœ', 'å…¨éƒ¨æ•…éšœ']
      }
    ])
  }
  
  static getByFloor(floor: Floor): { items: InspectionItemConfig[] } {
    const items = this.templates.get(floor)
    if (!items) {
      throw new Error(`No template found for floor: ${floor}`)
    }
    return { items }
  }
  
  static getTotalItemsCount(): number {
    let total = 0
    this.templates.forEach(items => {
      total += items.length
    })
    return total // åº”è¯¥è¿”å›56
  }
  
  static getFloorItemsCount(floor: Floor): number {
    const items = this.templates.get(floor)
    return items ? items.length : 0
  }
}
```

---

## Milestone 4.2: è§£è€¦å·¥å•ç”Ÿæˆï¼ˆ3å¤©ï¼‰

### Day 3: äº‹ä»¶é©±åŠ¨çš„å·¥å•ç”Ÿæˆï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¡æ£€é¢†åŸŸæœåŠ¡
```typescript
// src/domain/inspection/InspectionDomain.ts
@Injectable()
export class InspectionDomain {
  constructor(
    @Inject('InspectionRepository') private repository: InspectionRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {}
  
  async createInspection(dto: CreateInspectionDto): Promise<Inspection> {
    // åˆ›å»ºå·¡æ£€å®ä½“
    const inspection = new Inspection({
      floor: dto.floor,
      inspectorId: dto.inspectorId,
      inspectionDate: dto.inspectionDate || new Date()
    })
    
    // æŒä¹…åŒ–
    const saved = await this.repository.save(inspection)
    
    // å‘å¸ƒäº‹ä»¶
    this.eventBus.emit('inspection.created', {
      inspectionId: saved.id,
      floor: saved.floor,
      inspectorId: saved.inspectorId
    })
    
    return saved
  }
  
  async startInspection(inspectionId: string): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    inspection.start()
    await this.repository.update(inspection)
    
    this.eventBus.emit('inspection.started', {
      inspectionId,
      startTime: inspection.startTime
    })
  }
  
  async recordInspectionItem(
    inspectionId: string,
    itemCode: string,
    value: any,
    remark?: string
  ): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // è®°å½•é¡¹ç›®å€¼
    inspection.recordItem(itemCode, value, remark)
    
    // æ£€æŸ¥æ˜¯å¦äº§ç”Ÿå¼‚å¸¸
    const anomalies = inspection.getAnomalies()
    const newAnomaly = anomalies[anomalies.length - 1] // æœ€æ–°çš„å¼‚å¸¸
    
    if (newAnomaly) {
      // å‘å¸ƒå¼‚å¸¸æ£€æµ‹äº‹ä»¶
      this.eventBus.emit('inspection.anomaly.detected', {
        inspectionId,
        anomaly: newAnomaly,
        floor: inspection.floor,
        itemCode,
        value
      })
    }
    
    await this.repository.update(inspection)
  }
  
  async completeInspection(inspectionId: string): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    inspection.complete()
    await this.repository.update(inspection)
    
    // å‘å¸ƒå®Œæˆäº‹ä»¶
    this.eventBus.emit('inspection.completed', {
      inspectionId,
      endTime: inspection.endTime,
      totalItems: inspection.getTotalItems(),
      completedItems: inspection.getCompletedItems(),
      anomalyCount: inspection.getAnomalies().length
    })
  }
  
  async generateTicketsForAnomalies(
    inspectionId: string,
    selectedAnomalyIds?: string[]
  ): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // ç”Ÿæˆå·¥å•è¯·æ±‚
    const ticketRequests = inspection.generateTicketsForAnomalies(selectedAnomalyIds)
    
    if (ticketRequests.length === 0) {
      throw new DomainError('æ²¡æœ‰éœ€è¦ç”Ÿæˆå·¥å•çš„å¼‚å¸¸')
    }
    
    // å‘å¸ƒæ‰¹é‡åˆ›å»ºå·¥å•äº‹ä»¶ï¼Œè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨å·¥å•æœåŠ¡
    this.eventBus.emit('tickets.batch.create.requested', {
      source: 'inspection',
      sourceId: inspectionId,
      requests: ticketRequests,
      metadata: {
        floor: inspection.floor,
        inspectorId: inspection.inspectorId,
        inspectionDate: inspection.inspectionDate
      }
    })
    
    this.logger.info('Ticket creation requested from inspection', {
      inspectionId,
      ticketCount: ticketRequests.length
    })
  }
  
  async handleTicketsCreated(inspectionId: string, ticketIds: string[]): Promise<void> {
    const inspection = await this.repository.findById(inspectionId)
    
    if (!inspection) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // æ ‡è®°å·¥å•å·²ç”Ÿæˆ
    inspection.markTicketsGenerated(ticketIds)
    await this.repository.update(inspection)
    
    this.logger.info('Tickets marked as generated for inspection', {
      inspectionId,
      ticketIds
    })
  }
  
  async getLatestInspection(floor?: Floor): Promise<Inspection | null> {
    return await this.repository.findLatest(floor)
  }
  
  async copyInspection(inspectionId: string): Promise<Inspection> {
    const source = await this.repository.findById(inspectionId)
    
    if (!source) {
      throw new NotFoundError(`Inspection ${inspectionId} not found`)
    }
    
    // åˆ›å»ºå‰¯æœ¬
    const copy = source.copy()
    const saved = await this.repository.save(copy)
    
    this.eventBus.emit('inspection.copied', {
      sourceId: inspectionId,
      copyId: saved.id
    })
    
    return saved
  }
}
```

### Day 4: å·¥å•ç”Ÿæˆåè°ƒå™¨ï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¡æ£€-å·¥å•åè°ƒå™¨
```typescript
// src/services/inspection/InspectionTicketOrchestrator.ts
@Injectable()
export class InspectionTicketOrchestrator {
  private pendingRequests = new Map<string, TicketRequest[]>()
  
  constructor(
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger,
    @Inject('ConfigService') private config: ConfigService
  ) {
    this.setupEventHandlers()
  }
  
  private setupEventHandlers(): void {
    // ç›‘å¬å·¥å•åˆ›å»ºè¯·æ±‚
    this.eventBus.on(
      'tickets.batch.create.requested',
      this.handleTicketCreateRequest.bind(this)
    )
    
    // ç›‘å¬å·¥å•åˆ›å»ºæˆåŠŸ
    this.eventBus.on(
      'tickets.batch.created',
      this.handleTicketsCreated.bind(this)
    )
    
    // ç›‘å¬å·¥å•åˆ›å»ºå¤±è´¥
    this.eventBus.on(
      'tickets.batch.create.failed',
      this.handleTicketCreateFailed.bind(this)
    )
  }
  
  private async handleTicketCreateRequest(event: any): Promise<void> {
    if (event.source !== 'inspection') return
    
    const { sourceId, requests, metadata } = event
    
    try {
      // å­˜å‚¨å¾…å¤„ç†è¯·æ±‚
      this.pendingRequests.set(sourceId, requests)
      
      // åº”ç”¨ä¸šåŠ¡è§„åˆ™
      const processedRequests = await this.applyBusinessRules(requests, metadata)
      
      // è½¬å‘ç»™å·¥å•æœåŠ¡
      this.eventBus.emit('ticket.service.create.batch', {
        requests: processedRequests,
        source: 'inspection',
        sourceId,
        correlationId: generateCorrelationId()
      })
      
      this.logger.info('Forwarded ticket creation to ticket service', {
        inspectionId: sourceId,
        requestCount: processedRequests.length
      })
    } catch (error) {
      this.logger.error('Failed to process ticket creation request', {
        error,
        inspectionId: sourceId
      })
      
      // å‘å¸ƒå¤±è´¥äº‹ä»¶
      this.eventBus.emit('inspection.ticket.creation.failed', {
        inspectionId: sourceId,
        error: error.message
      })
    }
  }
  
  private async applyBusinessRules(
    requests: TicketRequest[],
    metadata: any
  ): Promise<TicketRequest[]> {
    const processed: TicketRequest[] = []
    
    for (const request of requests) {
      // è§„åˆ™1ï¼šåˆå¹¶ç›¸ä¼¼å¼‚å¸¸
      const merged = this.mergeSimiarAnomalies(request, processed)
      if (merged) continue
      
      // è§„åˆ™2ï¼šè°ƒæ•´ä¼˜å…ˆçº§
      request.priority = await this.adjustPriority(request, metadata)
      
      // è§„åˆ™3ï¼šè‡ªåŠ¨åˆ†é…
      request.assigneeId = await this.autoAssign(request, metadata)
      
      // è§„åˆ™4ï¼šè®¾ç½®SLA
      request.deadline = this.calculateDeadline(request.priority)
      
      processed.push(request)
    }
    
    return processed
  }
  
  private mergeSimiarAnomalies(
    request: TicketRequest,
    existing: TicketRequest[]
  ): boolean {
    // æŸ¥æ‰¾ç›¸ä¼¼çš„å·²å­˜åœ¨è¯·æ±‚
    const similar = existing.find(e => 
      e.category === request.category &&
      e.priority === request.priority &&
      this.isSimilarDescription(e.description, request.description)
    )
    
    if (similar) {
      // åˆå¹¶åˆ°ç°æœ‰è¯·æ±‚
      similar.description += `\n\n${request.description}`
      similar.anomalyIds = [...similar.anomalyIds, ...request.anomalyIds]
      return true
    }
    
    return false
  }
  
  private async adjustPriority(
    request: TicketRequest,
    metadata: any
  ): Promise<TicketPriority> {
    // åŸºäºæ¥¼å±‚è°ƒæ•´ä¼˜å…ˆçº§
    const floorPriorityMap = {
      [Floor.FLOOR_1]: 1, // 1æ¥¼ä¼˜å…ˆçº§æœ€é«˜
      [Floor.FLOOR_2]: 2,
      [Floor.FLOOR_3]: 3,
      [Floor.FLOOR_4]: 4
    }
    
    const floorPriority = floorPriorityMap[metadata.floor] || 5
    
    // å¦‚æœæ˜¯é«˜æ¥¼å±‚çš„ç´§æ€¥é—®é¢˜ï¼Œæå‡ä¼˜å…ˆçº§
    if (floorPriority <= 2 && request.priority === TicketPriority.HIGH) {
      return TicketPriority.URGENT
    }
    
    return request.priority
  }
  
  private async autoAssign(
    request: TicketRequest,
    metadata: any
  ): Promise<string | undefined> {
    // åŸºäºç±»åˆ«è‡ªåŠ¨åˆ†é…
    const categoryAssigneeMap = await this.getCategoryAssigneeMap()
    const assigneeId = categoryAssigneeMap[request.category]
    
    if (assigneeId) {
      this.logger.info('Auto-assigned ticket', {
        category: request.category,
        assigneeId
      })
      return assigneeId
    }
    
    return undefined
  }
  
  private calculateDeadline(priority: TicketPriority): Date {
    const slaHours = this.config.get(`business.ticket.sla.${priority}`)
    const deadline = new Date()
    deadline.setHours(deadline.getHours() + slaHours)
    return deadline
  }
  
  private async handleTicketsCreated(event: any): Promise<void> {
    const { source, sourceId, ticketIds } = event
    
    if (source !== 'inspection') return
    
    // æ¸…ç†å¾…å¤„ç†è¯·æ±‚
    this.pendingRequests.delete(sourceId)
    
    // é€šçŸ¥å·¡æ£€æœåŠ¡
    this.eventBus.emit('inspection.tickets.created', {
      inspectionId: sourceId,
      ticketIds
    })
    
    this.logger.info('Tickets created for inspection', {
      inspectionId: sourceId,
      ticketIds
    })
  }
  
  private async handleTicketCreateFailed(event: any): Promise<void> {
    const { source, sourceId, error } = event
    
    if (source !== 'inspection') return
    
    // è·å–å¤±è´¥çš„è¯·æ±‚
    const failedRequests = this.pendingRequests.get(sourceId)
    
    if (failedRequests) {
      // é‡è¯•é€»è¾‘
      await this.retryTicketCreation(sourceId, failedRequests)
    }
    
    this.logger.error('Failed to create tickets for inspection', {
      inspectionId: sourceId,
      error
    })
  }
  
  private async retryTicketCreation(
    inspectionId: string,
    requests: TicketRequest[]
  ): Promise<void> {
    const maxRetries = this.config.get('business.inspection.ticketCreation.maxRetries', 3)
    const retryDelay = this.config.get('business.inspection.ticketCreation.retryDelay', 5000)
    
    // å®ç°æŒ‡æ•°é€€é¿é‡è¯•
    for (let i = 0; i < maxRetries; i++) {
      await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, i)))
      
      try {
        this.eventBus.emit('ticket.service.create.batch', {
          requests,
          source: 'inspection',
          sourceId: inspectionId,
          retry: i + 1
        })
        
        this.logger.info('Retrying ticket creation', {
          inspectionId,
          attempt: i + 1
        })
        
        break
      } catch (error) {
        if (i === maxRetries - 1) {
          // æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥ï¼Œå‘é€å‘Šè­¦
          this.eventBus.emit('alert.ticket.creation.failed', {
            inspectionId,
            requests,
            error
          })
        }
      }
    }
  }
  
  private isSimilarDescription(desc1: string, desc2: string): boolean {
    // ç®€å•çš„ç›¸ä¼¼åº¦åˆ¤æ–­ï¼ˆå®é™…å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•ï¼‰
    const words1 = new Set(desc1.toLowerCase().split(/\s+/))
    const words2 = new Set(desc2.toLowerCase().split(/\s+/))
    
    const intersection = new Set([...words1].filter(x => words2.has(x)))
    const union = new Set([...words1, ...words2])
    
    const similarity = intersection.size / union.size
    return similarity > 0.7 // 70%ç›¸ä¼¼åº¦
  }
  
  private async getCategoryAssigneeMap(): Promise<Record<string, string>> {
    // å®é™…åº”è¯¥ä»é…ç½®æˆ–æ•°æ®åº“è·å–
    return {
      [ItemCategory.HVAC]: 'user_hvac_001',
      [ItemCategory.POWER]: 'user_power_001',
      [ItemCategory.FIRE]: 'user_fire_001',
      [ItemCategory.ELECTRICAL]: 'user_elec_001'
    }
  }
}
```

### Day 5: å¼‚æ­¥å·¥å•ç”Ÿæˆå’Œé‡è¯•æœºåˆ¶ï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¥å•æ‰¹é‡åˆ›å»ºæœåŠ¡
```typescript
// src/services/ticket/TicketBatchCreationService.ts
@Injectable()
export class TicketBatchCreationService {
  private queue: Queue<BatchCreateJob>
  
  constructor(
    @Inject('TicketRepository') private repository: TicketRepository,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.queue = new Queue('ticket-batch-creation', {
      concurrency: 5,
      retries: 3
    })
    
    this.setupQueueHandlers()
    this.setupEventHandlers()
  }
  
  private setupQueueHandlers(): void {
    this.queue.process(async (job) => {
      return await this.processBatchCreation(job.data)
    })
    
    this.queue.on('completed', (job, result) => {
      this.handleJobCompleted(job, result)
    })
    
    this.queue.on('failed', (job, error) => {
      this.handleJobFailed(job, error)
    })
  }
  
  private setupEventHandlers(): void {
    this.eventBus.on(
      'ticket.service.create.batch',
      this.handleBatchCreateRequest.bind(this)
    )
  }
  
  private async handleBatchCreateRequest(event: any): Promise<void> {
    const { requests, source, sourceId, correlationId } = event
    
    // æ·»åŠ åˆ°é˜Ÿåˆ—
    const job = await this.queue.add({
      requests,
      source,
      sourceId,
      correlationId,
      timestamp: new Date()
    })
    
    this.logger.info('Batch creation job queued', {
      jobId: job.id,
      source,
      sourceId,
      requestCount: requests.length
    })
  }
  
  private async processBatchCreation(data: BatchCreateJob): Promise<BatchCreateResult> {
    const { requests, source, sourceId } = data
    const results: BatchCreateResult = {
      successful: [],
      failed: [],
      total: requests.length
    }
    
    // ä½¿ç”¨äº‹åŠ¡æ‰¹é‡åˆ›å»º
    await this.repository.transaction(async (trx) => {
      for (const request of requests) {
        try {
          const ticket = await this.createSingleTicket(request, trx)
          results.successful.push({
            request,
            ticketId: ticket.id
          })
        } catch (error) {
          results.failed.push({
            request,
            error: error.message
          })
          
          // å†³å®šæ˜¯å¦ç»§ç»­æˆ–å›æ»š
          if (this.shouldAbortBatch(error)) {
            throw error
          }
        }
      }
    })
    
    return results
  }
  
  private async createSingleTicket(
    request: TicketRequest,
    trx: Transaction
  ): Promise<Ticket> {
    // åˆ›å»ºå·¥å•å®ä½“
    const ticket = new Ticket({
      title: request.title,
      description: request.description,
      priority: request.priority,
      category: request.category,
      sourceType: request.sourceType,
      sourceId: request.sourceId,
      assigneeId: request.assigneeId,
      deadline: request.deadline,
      status: TicketStatus.PENDING
    })
    
    // éªŒè¯
    await this.validateTicket(ticket)
    
    // ä¿å­˜
    const saved = await this.repository.save(ticket, { transaction: trx })
    
    // è®°å½•å®¡è®¡æ—¥å¿—
    await this.logTicketCreation(saved, request)
    
    return saved
  }
  
  private async validateTicket(ticket: Ticket): Promise<void> {
    // æ£€æŸ¥é‡å¤
    const duplicate = await this.repository.findDuplicate(ticket.title)
    if (duplicate) {
      throw new DomainError(`Duplicate ticket: ${duplicate.id}`)
    }
    
    // å…¶ä»–éªŒè¯...
  }
  
  private shouldAbortBatch(error: Error): boolean {
    // æŸäº›é”™è¯¯åº”è¯¥ä¸­æ­¢æ•´ä¸ªæ‰¹æ¬¡
    return error instanceof DatabaseError || 
           error instanceof AuthorizationError
  }
  
  private async handleJobCompleted(job: Job, result: BatchCreateResult): Promise<void> {
    const { source, sourceId } = job.data
    
    // å‘å¸ƒæˆåŠŸäº‹ä»¶
    this.eventBus.emit('tickets.batch.created', {
      source,
      sourceId,
      ticketIds: result.successful.map(s => s.ticketId),
      failedCount: result.failed.length,
      totalCount: result.total
    })
    
    // å¦‚æœæœ‰å¤±è´¥çš„ï¼Œå‘å¸ƒéƒ¨åˆ†å¤±è´¥äº‹ä»¶
    if (result.failed.length > 0) {
      this.eventBus.emit('tickets.batch.partial.failure', {
        source,
        sourceId,
        failed: result.failed
      })
    }
    
    this.logger.info('Batch creation completed', {
      jobId: job.id,
      successful: result.successful.length,
      failed: result.failed.length
    })
  }
  
  private async handleJobFailed(job: Job, error: Error): Promise<void> {
    const { source, sourceId } = job.data
    
    // å‘å¸ƒå¤±è´¥äº‹ä»¶
    this.eventBus.emit('tickets.batch.create.failed', {
      source,
      sourceId,
      error: error.message,
      attempts: job.attemptsMade
    })
    
    this.logger.error('Batch creation failed', {
      jobId: job.id,
      error,
      attempts: job.attemptsMade
    })
  }
  
  private async logTicketCreation(ticket: Ticket, request: TicketRequest): Promise<void> {
    await this.repository.saveAuditLog({
      action: 'TICKET_CREATED_FROM_INSPECTION',
      entityId: ticket.id,
      entityType: 'Ticket',
      metadata: {
        sourceType: request.sourceType,
        sourceId: request.sourceId,
        anomalyIds: request.anomalyIds
      },
      timestamp: new Date()
    })
  }
}
```

---

## Milestone 4.3: å·¡æ£€é…ç½®ç‹¬ç«‹ï¼ˆ1å¤©ï¼‰

### Day 6: é…ç½®æœåŠ¡å’ŒUIï¼ˆ8å°æ—¶ï¼‰

#### 1. å·¡æ£€é…ç½®æœåŠ¡
```typescript
// src/services/inspection/InspectionConfigService.ts
@Injectable()
export class InspectionConfigService {
  private configCache = new Map<string, any>()
  private listeners = new Map<string, Set<Function>>()
  
  constructor(
    @Inject('ConfigService') private config: ConfigService,
    @Inject('EventBus') private eventBus: EventBus,
    @Inject('Logger') private logger: Logger
  ) {
    this.loadConfigurations()
    this.setupConfigSync()
  }
  
  private loadConfigurations(): void {
    // åŠ è½½å·¡æ£€é…ç½®
    const inspectionConfig = {
      floors: {
        floor1: {
          label: '1æ¥¼',
          itemCount: 22,
          categories: ['hvac', 'power', 'fire']
        },
        floor2: {
          label: '2æ¥¼',
          itemCount: 18,
          categories: ['hvac', 'power', 'electrical']
        },
        floor3: {
          label: '3æ¥¼',
          itemCount: 13,
          categories: ['hvac', 'ups', 'monitoring']
        },
        floor4: {
          label: '4æ¥¼',
          itemCount: 3,
          categories: ['safety', 'fire', 'electrical']
        }
      },
      
      anomalyDetection: {
        enableHistoricalAnalysis: true,
        historicalDataPoints: 30,
        anomalyThreshold: 3, // æ ‡å‡†å·®
        correlationRules: true
      },
      
      ticketGeneration: {
        autoGenerate: false,
        mergeSimilar: true,
        similarityThreshold: 0.7,
        batchSize: 10,
        retryAttempts: 3,
        retryDelay: 5000
      },
      
      thresholds: {
        temperature: {
          normal: { min: 18, max: 26 },
          warning: { min: 15, max: 30 },
          critical: { min: 10, max: 35 }
        },
        humidity: {
          normal: { min: 40, max: 60 },
          warning: { min: 35, max: 65 },
          critical: { min: 30, max: 70 }
        },
        pressure: {
          normal: { min: 0.4, max: 1.2 },
          warning: { min: 0.2, max: 1.5 },
          critical: { min: 0.1, max: 2.0 }
        }
      }
    }
    
    // å­˜å‚¨åˆ°ç¼“å­˜
    this.configCache.set('inspection', inspectionConfig)
    
    // æ³¨å†Œåˆ°å…¨å±€é…ç½®æœåŠ¡
    this.registerToGlobalConfig(inspectionConfig)
  }
  
  private registerToGlobalConfig(config: any): void {
    // æ³¨å†Œé…ç½®åˆ°å…¨å±€é…ç½®æœåŠ¡
    Object.entries(config).forEach(([key, value]) => {
      this.config.set(`business.inspection.${key}`, value)
    })
  }
  
  private setupConfigSync(): void {
    // ç›‘å¬é…ç½®å˜æ›´äº‹ä»¶
    this.eventBus.on('config.updated', (event) => {
      if (event.path.startsWith('business.inspection')) {
        this.handleConfigUpdate(event)
      }
    })
  }
  
  private handleConfigUpdate(event: any): void {
    const { path, value, oldValue } = event
    
    // æ›´æ–°ç¼“å­˜
    const key = path.replace('business.inspection.', '')
    this.updateCache(key, value)
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.notifyListeners(key, value, oldValue)
    
    // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
    this.eventBus.emit('inspection.config.updated', {
      key,
      value,
      oldValue
    })
    
    this.logger.info('Inspection config updated', {
      key,
      value
    })
  }
  
  private updateCache(key: string, value: any): void {
    const parts = key.split('.')
    let target = this.configCache.get('inspection')
    
    for (let i = 0; i < parts.length - 1; i++) {
      target = target[parts[i]]
    }
    
    target[parts[parts.length - 1]] = value
  }
  
  private notifyListeners(key: string, value: any, oldValue: any): void {
    const listeners = this.listeners.get(key)
    if (listeners) {
      listeners.forEach(listener => {
        try {
          listener(value, oldValue)
        } catch (error) {
          this.logger.error('Config listener error', { key, error })
        }
      }
    })
  }
  
  // å…¬å…±æ–¹æ³•
  get(key: string, defaultValue?: any): any {
    const config = this.configCache.get('inspection')
    const parts = key.split('.')
    
    let value = config
    for (const part of parts) {
      value = value?.[part]
    }
    
    return value ?? defaultValue
  }
  
  set(key: string, value: any): void {
    const fullPath = `business.inspection.${key}`
    this.config.set(fullPath, value)
  }
  
  watch(key: string, callback: Function): () => void {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set())
    }
    
    this.listeners.get(key)!.add(callback)
    
    return () => {
      this.listeners.get(key)?.delete(callback)
    }
  }
  
  getFloorConfig(floor: Floor): any {
    return this.get(`floors.${floor}`)
  }
  
  getThreshold(type: string): any {
    return this.get(`thresholds.${type}`)
  }
  
  getAnomalyDetectionConfig(): any {
    return this.get('anomalyDetection')
  }
  
  getTicketGenerationConfig(): any {
    return this.get('ticketGeneration')
  }
}
```

#### 2. é…ç½®ç®¡ç†UIç»„ä»¶
```vue
<!-- src/views/business/inspection/config/index.vue -->
<template>
  <div class="inspection-config">
    <el-tabs v-model="activeTab">
      <el-tab-pane label="æ¥¼å±‚é…ç½®" name="floors">
        <FloorConfig v-model="config.floors" @change="handleFloorConfigChange" />
      </el-tab-pane>
      
      <el-tab-pane label="é˜ˆå€¼é…ç½®" name="thresholds">
        <ThresholdConfig v-model="config.thresholds" @change="handleThresholdChange" />
      </el-tab-pane>
      
      <el-tab-pane label="å¼‚å¸¸æ£€æµ‹" name="anomaly">
        <AnomalyDetectionConfig 
          v-model="config.anomalyDetection" 
          @change="handleAnomalyConfigChange"
        />
      </el-tab-pane>
      
      <el-tab-pane label="å·¥å•ç”Ÿæˆ" name="ticket">
        <TicketGenerationConfig 
          v-model="config.ticketGeneration"
          @change="handleTicketConfigChange"
        />
      </el-tab-pane>
    </el-tabs>
    
    <div class="config-actions">
      <el-button @click="resetConfig">é‡ç½®</el-button>
      <el-button @click="exportConfig">å¯¼å‡ºé…ç½®</el-button>
      <el-button @click="importConfig">å¯¼å…¥é…ç½®</el-button>
      <el-button type="primary" @click="saveConfig">ä¿å­˜é…ç½®</el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useInspectionConfig } from '@/composables/useInspectionConfig'
import FloorConfig from './components/FloorConfig.vue'
import ThresholdConfig from './components/ThresholdConfig.vue'
import AnomalyDetectionConfig from './components/AnomalyDetectionConfig.vue'
import TicketGenerationConfig from './components/TicketGenerationConfig.vue'

const activeTab = ref('floors')

const {
  config,
  loadConfig,
  saveConfig,
  resetConfig,
  exportConfig,
  importConfig,
  handleFloorConfigChange,
  handleThresholdChange,
  handleAnomalyConfigChange,
  handleTicketConfigChange
} = useInspectionConfig()

onMounted(() => {
  loadConfig()
})
</script>

<style scoped>
.inspection-config {
  padding: 20px;
}

.config-actions {
  margin-top: 20px;
  text-align: right;
}
</style>
```

## ğŸ“Š Phase 4 å®Œæˆæ ‡å‡†æ£€æŸ¥æ¸…å•

### æŠ€æœ¯æŒ‡æ ‡
- [ ] å·¡æ£€é¢†åŸŸæ¨¡å‹å®Œæ•´
- [ ] å¼‚å¸¸æ£€æµ‹å‡†ç¡®ç‡ > 95%
- [ ] å·¥å•ç”Ÿæˆè§£è€¦å®Œæˆ
- [ ] é…ç½®ç‹¬ç«‹ç®¡ç†
- [ ] æµ‹è¯•è¦†ç›–ç‡ > 85%

### åŠŸèƒ½éªŒè¯
- [ ] 56é¡¹å·¡æ£€é…ç½®æ­£ç¡®
- [ ] å¼‚å¸¸è‡ªåŠ¨æ£€æµ‹æ­£å¸¸
- [ ] æ‰¹é‡å·¥å•ç”ŸæˆæˆåŠŸ
- [ ] é‡è¯•æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] é…ç½®çƒ­æ›´æ–°ç”Ÿæ•ˆ

### æ€§èƒ½æŒ‡æ ‡
- [ ] å·¡æ£€è®°å½•å“åº” < 100ms
- [ ] æ‰¹é‡å·¥å•ç”Ÿæˆ < 2sï¼ˆ10ä¸ªï¼‰
- [ ] é…ç½®åŠ è½½ < 50ms

## ğŸš€ Phase 4 äº¤ä»˜ç‰©

1. **é¢†åŸŸæ¨¡å‹**
   - Inspectionå®ä½“
   - InspectionItemå€¼å¯¹è±¡
   - AnomalyDetectoræœåŠ¡
   - InspectionTemplateé…ç½®

2. **æœåŠ¡å±‚**
   - InspectionDomainé¢†åŸŸæœåŠ¡
   - InspectionTicketOrchestratoråè°ƒå™¨
   - TicketBatchCreationServiceæ‰¹é‡åˆ›å»ºæœåŠ¡
   - InspectionConfigServiceé…ç½®æœåŠ¡

3. **é…ç½®ç®¡ç†**
   - 56é¡¹å·¡æ£€é…ç½®
   - é˜ˆå€¼é…ç½®
   - å¼‚å¸¸æ£€æµ‹è§„åˆ™
   - å·¥å•ç”Ÿæˆç­–ç•¥

4. **æµ‹è¯•æ–‡ä»¶**
   - å¼‚å¸¸æ£€æµ‹æµ‹è¯•
   - å·¥å•ç”Ÿæˆæµ‹è¯•
   - é…ç½®ç®¡ç†æµ‹è¯•

5. **æ–‡æ¡£**
   - INSPECTION-DOMAIN.md
   - ANOMALY-DETECTION.md
   - BATCH-TICKET-CREATION.md

è¿™å°±æ˜¯Phase 4çš„å®Œæ•´å®æ–½æ–¹æ¡ˆï¼Œé‡ç‚¹å®ç°äº†å·¡æ£€é¢†åŸŸæ¨¡å‹ã€è§£è€¦å·¥å•ç”Ÿæˆé€»è¾‘ã€å®ç°äº‹ä»¶é©±åŠ¨çš„æ‰¹é‡å·¥å•åˆ›å»ºï¼Œå¹¶ç‹¬ç«‹äº†é…ç½®ç®¡ç†ã€‚