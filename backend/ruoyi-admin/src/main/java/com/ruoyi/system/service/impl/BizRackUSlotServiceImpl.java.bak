package com.ruoyi.system.service.impl;

import java.util.List;
import java.util.Map;
import com.ruoyi.common.utils.DateUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.ruoyi.system.mapper.BizRackUSlotMapper;
import com.ruoyi.system.domain.BizRackUSlot;
import com.ruoyi.system.service.IBizRackUSlotService;
import com.ruoyi.common.exception.ServiceException;

/**
 * 机柜U位管理Service业务层处理
 *
 * @author ruoyi
 * @date 2025-01-18
 */
@Service
public class BizRackUSlotServiceImpl implements IBizRackUSlotService
{
    @Autowired
    @Autowired
    private IBizAssetRackLogService bizAssetRackLogService;
    private BizRackUSlotMapper bizRackUSlotMapper;

    /**
     * 查询机柜U位管理
     *
     * @param slotId 机柜U位管理主键
     * @return 机柜U位管理
     */
    @Override
    public BizRackUSlot selectBizRackUSlotBySlotId(Long slotId)
    {
        return bizRackUSlotMapper.selectBizRackUSlotBySlotId(slotId);
    }

    /**
     * 查询机柜U位管理列表
     *
     * @param bizRackUSlot 机柜U位管理
     * @return 机柜U位管理
     */
    @Override
    public List<BizRackUSlot> selectBizRackUSlotList(BizRackUSlot bizRackUSlot)
    {
        return bizRackUSlotMapper.selectBizRackUSlotList(bizRackUSlot);
    }

    /**
     * 根据机柜ID查询U位列表
     *
     * @param rackId 机柜ID
     * @return U位列表
     */
    @Override
    public List<BizRackUSlot> selectUSlotsByRackId(Long rackId)
    {
        return bizRackUSlotMapper.selectUSlotsByRackId(rackId);
    }

    /**
     * 检查U位冲突
     *
     * @param rackId 机柜ID
     * @param startU 起始U位
     * @param uCount 占用U位数
     * @return true-有冲突, false-无冲突
     */
    @Override
    public boolean checkUSlotConflict(Long rackId, Integer startU, Integer uCount)
    {
        int conflictCount = bizRackUSlotMapper.checkUSlotConflict(rackId, startU, uCount);
        return conflictCount > 0;
    }

    /**
     * 新增机柜U位管理
     *
     * @param bizRackUSlot 机柜U位管理
     * @return 结果
     */
    @Override
    public int insertBizRackUSlot(BizRackUSlot bizRackUSlot)
    {
        bizRackUSlot.setCreateTime(DateUtils.getNowDate());
        return bizRackUSlotMapper.insertBizRackUSlot(bizRackUSlot);
    }

    /**
     * 修改机柜U位管理
     *
     * @param bizRackUSlot 机柜U位管理
     * @return 结果
     */
    @Override
    public int updateBizRackUSlot(BizRackUSlot bizRackUSlot)
    {
        bizRackUSlot.setUpdateTime(DateUtils.getNowDate());
        return bizRackUSlotMapper.updateBizRackUSlot(bizRackUSlot);
    }

    /**
     * 批量删除机柜U位管理
     *
     * @param slotIds 需要删除的机柜U位管理主键
     * @return 结果
     */
    @Override
    public int deleteBizRackUSlotBySlotIds(Long[] slotIds)
    {
        return bizRackUSlotMapper.deleteBizRackUSlotBySlotIds(slotIds);
    }

    /**
     * 删除机柜U位管理信息
     *
     * @param slotId 机柜U位管理主键
     * @return 结果
     */
    @Override
    public int deleteBizRackUSlotBySlotId(Long slotId)
    {
        return bizRackUSlotMapper.deleteBizRackUSlotBySlotId(slotId);
    }

    /**
     * 分配U位(将指定范围的U位标记为已占用)
     *
     * @param rackId 机柜ID
     * @param startU 起始U位
     * @param uCount 占用U位数
     * @param deviceName 设备名称
     * @param deviceType 设备类型
     * @param allocatedBy 分配人
     * @return 影响行数
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public int allocateUSlots(Long rackId, Integer startU, Integer uCount,
                              String deviceName, String deviceType, String allocatedBy)
    {
        // 1. 检查参数
        if (rackId == null || startU == null || uCount == null || uCount <= 0)
        {
            throw new ServiceException("参数错误:机柜ID、起始U位和占用U位数不能为空");
        }

        // 2. 检查冲突
        boolean hasConflict = checkUSlotConflict(rackId, startU, uCount);
        if (hasConflict)
        {
            throw new ServiceException("U位分配冲突:U" + startU + "~U" + (startU + uCount - 1) + " 范围内存在已占用或已预留的U位");
        }

        // 3. 执行分配
        int affectedRows = bizRackUSlotMapper.allocateUSlots(rackId, startU, uCount, deviceName, deviceType, allocatedBy);

        if (affectedRows != uCount)
        {
            throw new ServiceException("U位分配失败:预期分配" + uCount + "个U位,实际分配" + affectedRows + "个");
        }

        return affectedRows;
    }

    /**
     * 释放U位(将指定范围的U位标记为空闲)
     *
     * @param rackId 机柜ID
     * @param startU 起始U位
     * @param uCount 占用U位数
     * @param releasedBy 释放人
     * @return 影响行数
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public int releaseUSlots(Long rackId, Integer startU, Integer uCount, String releasedBy)
    {
        // 1. 检查参数
        if (rackId == null || startU == null || uCount == null || uCount <= 0)
        {
            throw new ServiceException("参数错误:机柜ID、起始U位和占用U位数不能为空");
        }

        // 2. 执行释放
        int affectedRows = bizRackUSlotMapper.releaseUSlots(rackId, startU, uCount, releasedBy);

        if (affectedRows == 0)
        {
            throw new ServiceException("U位释放失败:U" + startU + "~U" + (startU + uCount - 1) + " 范围内没有已占用的U位");
        }

        return affectedRows;
    }

    /**
     * 统计机柜的U位使用情况
     *
     * @param rackId 机柜ID
     * @return Map包含: total_slots, free_slots, occupied_slots, reserved_slots
     */
    @Override
    public Map<String, Object> countUSlotsByRackId(Long rackId)
    {
        return bizRackUSlotMapper.countUSlotsByRackId(rackId);
    }
}
